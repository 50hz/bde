<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlde_utf8util.h                                                   -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLDE_UTF8UTIL
#define INCLUDED_BDLDE_UTF8UTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide basic utilities for UTF-8 encodings.
//
//@CLASSES:
//  bdlde::Utf8Util: namespace for utilities for UTF-8 encodings
//
//@DESCRIPTION: This component provides, within the &#39;bdlde::Utf8Util&#39; &#39;struct&#39;,
// a suite of static functions supporting UTF-8 encoded strings.  Two
// interfaces are provided for each function, one where the length of the
// string (in *bytes*) is passed as a separate argument, and one where the
// string is passed as a null-terminated C-style string.
//
// A string is deemed to contain valid UTF-8 if it is compliant with RFC 3629,
// meaning that only 1-, 2-, 3-, and 4-byte sequences are allowed.  Values
// above &#39;U+10ffff&#39; are also not allowed.
//
// Three types of functions are provided:
//
//: o &#39;isValid&#39;, which checks for validity, per RFC 3629, of a (candidate)
//:   UTF-8 string.  &quot;Overlong values&quot;, that is, values encoded in more bytes
//:   than necessary, are not tolerated; nor are &quot;surrogate values&quot;, which are
//:   values in the range &#39;[U+d800 .. U+dfff]&#39;.
//:
//: o &#39;advanceIfValid&#39; and &#39;advanceRaw&#39;, which advance some number of UTF-8
//:   characters, each of which may be encoded in multiple bytes in a UTF-8
//:   string.  &#39;advanceRaw&#39; assumes the string is valid UTF-8, while
//:   &#39;advanceIfValid&#39; checks the input for validity and stops advancing if a
//:   sequence is encountered that is not valid UTF-8.
//:
//: o &#39;numCharactersIfValid&#39; and &#39;numCharactersRaw&#39;, which return the length of
//:   a sequence of UTF-8 characters, each of which may be encoded in multiple
//:   bytes.  Note that &#39;numCharactersIfValid&#39; both validates a (candidate)
//:   UTF-8 string and counts the number of UTF-8 characters that it contains.
//
// Embedded null characters are allowed in strings that are accompanied by an
// explicit length argument.  Naturally, null-terminated C-style strings cannot
// contain embedded null characters.
//
// The UTF-8 format is described in the RFC 3629 document at:
//..
//  http://tools.ietf.org/html/rfc3629
//..
// and in Wikipedia at:
//..
//  http://en.wikipedia.org/wiki/Utf-8
//..
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Validating Strings and Counting Unicode Characters
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// For our usage example we will define some functions that can encode UTF-8,
// use them to build some strings, and observe how the functions defined in
// this class perform on them.
//..
//  void utf8AppendOneByte(bsl::string *string, int value)
//      // Append the specified 1-byte UTF-8-encoded &#39;value&#39; to the end of the
//      // specified &#39;string&#39;.
//  {
//      assert(0 == (value &amp; ~0x7f));
//
//      *string += static_cast&lt;char&gt;(value);
//  }
//
//  void utf8AppendTwoBytes(bsl::string *string, int value)
//      // Append the specified 2-byte UTF-8-encoded &#39;value&#39; to the end of the
//      // specified &#39;string&#39;.
//  {
//      assert(0 == (value &amp; ~0x7ff));
//
//      unsigned char buf[3];
//      buf[0] = static_cast&lt;unsigned char&gt;(((value &amp; 0x7c0) &gt;&gt; 6) | 0xc0);
//      buf[1] = static_cast&lt;unsigned char&gt;( (value &amp;  0x3f)       | 0x80);
//      buf[2] = 0;
//
//      *string += reinterpret_cast&lt;char *&gt;(buf);
//  }
//
//  void utf8AppendThreeBytes(bsl::string *string, int value)
//      // Append the specified 3-byte UTF-8-encoded &#39;value&#39; to the end of the
//      // specified &#39;string&#39;.
//  {
//      assert(0 == (value &amp; ~0xffff));
//
//      unsigned char buf[4];
//      buf[0] = static_cast&lt;unsigned char&gt;(((value &amp; 0xf000) &gt;&gt; 12) | 0xe0);
//      buf[1] = static_cast&lt;unsigned char&gt;(((value &amp;  0xfc0) &gt;&gt;  6) | 0x80);
//      buf[2] = static_cast&lt;unsigned char&gt;( (value &amp;   0x3f)        | 0x80);
//      buf[3] = 0;
//
//      *string += reinterpret_cast&lt;char *&gt;(buf);
//  }
//
//  void utf8AppendFourBytes(bsl::string *string, int value)
//      // Append the specified 4-byte UTF-8-encoded &#39;value&#39; to the end of the
//      // specified &#39;string&#39;.
//  {
//      assert(static_cast&lt;unsigned&gt;(value) &lt;= 0x10ffff);
//
//      unsigned char buf[5];
//      buf[0] = static_cast&lt;unsigned char&gt;(((value &amp; 0x1c0000) &gt;&gt; 18) | 0xf0);
//      buf[1] = static_cast&lt;unsigned char&gt;(((value &amp;  0x3f000) &gt;&gt; 12) | 0x80);
//      buf[2] = static_cast&lt;unsigned char&gt;(((value &amp;    0xfc0) &gt;&gt;  6) | 0x80);
//      buf[3] = static_cast&lt;unsigned char&gt;( (value &amp;     0x3f)        | 0x80);
//      buf[4] = 0;
//
//      *string += reinterpret_cast&lt;char *&gt;(buf);
//  }
//
//  void utf8Append(bsl::string *string, int value)
//      // Append the specified UTF-8-encoded &#39;value&#39; in the minimum number of
//      // bytes to the end of the specified &#39;string&#39;.
//  {
//      assert(static_cast&lt;unsigned&gt;(value) &lt;= 0x10ffff);
//
//      if (value &lt;= 0x7f) {
//          utf8AppendOneByte(string, value);
//          return;                                                   // RETURN
//      }
//      if (value &lt;= 0x7ff) {
//          utf8AppendTwoBytes(string, value);
//          return;                                                   // RETURN
//      }
//      if (value &lt;= 0xffff) {
//          utf8AppendThreeBytes(string, value);
//          return;                                                   // RETURN
//      }
//
//      utf8AppendFourBytes(string, value);
//  }
//..
// In this usage example, we will encode some UTF-8 strings and demonstrate
// which ones are valid and which ones are not.
//
// First, we build an unquestionably valid UTF-8 string:
//..
//  bsl::string string;
//  utf8Append(&amp;string, 0xff00);
//  utf8Append(&amp;string, 0x856);
//  utf8Append(&amp;string, &#39;a&#39;);
//  utf8Append(&amp;string, 0x1008aa);
//  utf8Append(&amp;string, 0xfff);
//  utf8Append(&amp;string, &#39;w&#39;);
//  utf8Append(&amp;string, 0x1abcd);
//  utf8Append(&amp;string, &#39;.&#39;);
//  utf8Append(&amp;string, &#39;\n&#39;);
//..
// Next we check its validity and measure its length:
//..
//  assert(true == bdlde::Utf8Util::isValid(string.data(), string.length()));
//  assert(true == bdlde::Utf8Util::isValid(string.c_str()));
//
//  assert(   9 == bdlde::Utf8Util::numCharactersRaw(string.data(),
//                                                  string.length()));
//  assert(   9 == bdlde::Utf8Util::numCharactersRaw(string.c_str()));
//..
// Next we encode a lone surrogate value, which is not allowed:
//..
//  bsl::string stringWithSurrogate = string;
//  utf8Append(&amp;stringWithSurrogate, 0xd8ab);
//
//  assert(false == bdlde::Utf8Util::isValid(stringWithSurrogate.data(),
//                                          stringWithSurrogate.length()));
//  assert(false == bdlde::Utf8Util::isValid(stringWithSurrogate.c_str()));
//..
// We cannot use &#39;numCharactersRaw&#39; to count the characters in
// &#39;stringWithSurrogate&#39;, since the behavior of that method is undefined unless
// the string is valid.  Instead, the &#39;numCharactersIfValid&#39; method can be used
// on strings whose validity we are uncertain of:
//..
//  const char *invalidPosition = 0;
//
//  assert(-1 == bdlde::Utf8Util::numCharactersIfValid(
//                                              &amp;invalidPosition,
//                                              stringWithSurrogate.data(),
//                                              stringWithSurrogate.length()));
//  assert(invalidPosition == stringWithSurrogate.data() + string.length());
//
//  invalidPosition = 0;  // reset
//
//  assert(-1 == bdlde::Utf8Util::numCharactersIfValid(
//                                              &amp;invalidPosition,
//                                              stringWithSurrogate.c_str()));
//  assert(invalidPosition == stringWithSurrogate.data() + string.length());
//..
// Next we encode 0, which is allowed.  However, note that we cannot use any
// interfaces that take a null-terminated string for this case:
//..
//  bsl::string stringWithNull = string;
//  utf8AppendOneByte(&amp;stringWithNull, 0);
//..
//  assert(true == bdlde::Utf8Util::isValid(stringWithNull.data(),
//                                         stringWithNull.length()));
//
//  assert(  10 == bdlde::Utf8Util::numCharactersRaw(stringWithNull.data(),
//                                                  stringWithNull.length()));
//..
// Finally, we encode &#39;0x61&#39; (&#39;a&#39;) as an overlong value using 2 bytes, which is
// not valid UTF-8 (since &#39;a&#39; can be &quot;encoded&quot; in 1 byte):
//..
//  bsl::string stringWithOverlong = string;
//  utf8AppendTwoBytes(&amp;stringWithOverlong, &#39;a&#39;);
//
//  assert(false == bdlde::Utf8Util::isValid(stringWithOverlong.data(),
//                                          stringWithOverlong.length()));
//  assert(false == bdlde::Utf8Util::isValid(stringWithOverlong.c_str()));
//..
//
///Example 2: Advancing Characters
///- - - - - - - - - - - - - - - -
// In this example, we will re-use the &#39;utf8Append&#39; function from Example 1 to
// build a string.
//
// First, build the string, keeping track of how many bytes are in each Unicode
// character:
//..
//  bsl::string string;
//  utf8Append(&amp;string, 0xff00);        // 3 bytes
//  utf8Append(&amp;string, 0x1ff);         // 2 bytes
//  utf8Append(&amp;string, &#39;a&#39;);           // 1 byte
//  utf8Append(&amp;string, 0x1008aa);      // 4 bytes
//  utf8Append(&amp;string, 0x1abcd);       // 4 bytes
//  string += &quot;\xe3\x8f\xfe&quot;;           // 3 bytes (invalid 3-byte sequence,
//                                      // the first 2 bytes are valid but the
//                                      // last continuation byte is invalid)
//  utf8Append(&amp;string, &#39;w&#39;);           // 1 byte
//  utf8Append(&amp;string, &#39;\n&#39;);          // 1 byte
//..
// Then, declare a few variables we&#39;ll need:
//..
//  int rc, status;
//  const char *result;
//  const char *const start = string.c_str();
//..
// Next, try advancing 2 characters, then 3, then 4, observing that the value
// returned is the number of Unicode characters advanced.  Note that since
// we&#39;re only advancing over valid UTF-8, we can use either &#39;advanceRaw&#39; or
// &#39;advanceIfValid&#39;:
//..
//  rc = bdlde::Utf8Util::advanceRaw(              &amp;result, start, 2);
//  assert(2 == rc);
//  assert(3 + 2 == result - start);
//
//  rc = bdlde::Utf8Util::advanceIfValid(&amp;status, &amp;result, start, 2);
//  assert(0 == status);
//  assert(2 == rc);
//  assert(3 + 2 == result - start);
//
//  rc = bdlde::Utf8Util::advanceRaw(             &amp;result, start, 3);
//  assert(0 == status);
//  assert(3 == rc);
//  assert(3 + 2 + 1 == result - start);
//
//  rc = bdlde::Utf8Util::advanceIfValid(&amp;status, &amp;result, start, 3);
//  assert(0 == status);
//  assert(3 == rc);
//  assert(3 + 2 + 1 == result - start);
//
//  rc = bdlde::Utf8Util::advanceRaw(             &amp;result, start, 4);
//  assert(4 == rc);
//  assert(3 + 2 + 1 + 4 == result - start);
//
//  rc = bdlde::Utf8Util::advanceIfValid(&amp;status, &amp;result, start, 4);
//  assert(0 == status);
//  assert(4 == rc);
//  assert(3 + 2 + 1 + 4 == result - start);
//..
// Then, try advancing by more characters than are present using
// &#39;advanceIfValid&#39;, and wind up stopping when we encounter invalid input.  The
// behavior of &#39;advanceRaw&#39; is undefined if it is used on invalid input, so we
// cannot use it here.  Also note that we will stop at the beginning of the
// invalid Unicode character, and not at the first incorrect byte, which is two
// bytes later:
//..
//  rc = bdlde::Utf8Util::advanceIfValid(&amp;status, &amp;result, start, INT_MAX);
//  assert(0 != status);
//  assert(5 == rc);
//  assert(3 + 2 + 1 + 4 + 4                 == result - start);
//  assert(static_cast&lt;int&gt;(string.length()) &gt;  result - start);
//..
// Now, doctor the string to replace the invalid character with a valid one, so
// the string is entirely correct UTF-8:
//.
//  string[3 + 2 + 1 + 4 + 4 + 2] = static_cast&lt;char&gt;(0x8a);
//..
// Finally, advance using both functions by more characters than are in the
// string and in both cases wind up at the end of the string.  Note that
// &#39;advanceIfValid&#39; does not return an error (non-zero) value to &#39;status&#39; when
// it encounters the end of the string:
//..
//  rc = bdlde::Utf8Util::advanceRaw(             &amp;result, start, INT_MAX);
//  assert(8 == rc);
//  assert(3 + 2 + 1 + 4 + 4 + 3 + 1 + 1     == result - start);
//  assert(static_cast&lt;int&gt;(string.length()) == result - start);
//
//  rc = bdlde::Utf8Util::advanceIfValid(&amp;status, &amp;result, start, INT_MAX);
//  assert(0 == status);
//  assert(8 == rc);
//  assert(3 + 2 + 1 + 4 + 4 + 3 + 1 + 1     == result - start);
//  assert(static_cast&lt;int&gt;(string.length()) == result - start);
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {

namespace bdlde {
                              // ===============
                              // struct Utf8Util
                              // ===============

struct Utf8Util {
    // This struct provides a namespace for static methods used for validating
    // UTF-8 strings, for counting the number of UTF-8 characters in them, and
    // for advancing pointers through UTF-8 strings.

    // CLASS METHODS
    static int advanceIfValid(int         *status,
                              const char **result,
                              const char  *string,
                              int          numCharacters);
        // Advance past 0 or more consecutive *valid* UTF-8 characters at the
        // beginning of the specified &#39;string&#39;, until either the specified
        // &#39;numCharacters&#39; have been traversed, or the terminating null
        // character or invalid UTF-8 is encountered (whichever occurs first),
        // and return the number of UTF-8 characters traversed.  Set the
        // specified &#39;*status&#39; to 0 if no invalid UTF-8 is encountered, and to
        // a non-zero value otherwise.  Set the specified &#39;*result&#39; to the
        // address of the byte immediately following the last character
        // traversed, or to &#39;string&#39; if &#39;string&#39; is empty or &#39;numCharacters&#39; is
        // 0.  &#39;string&#39; is necessarily null-terminated, so it cannot contain
        // embedded null characters.  The behavior is undefined unless
        // &#39;0 &lt;= numCharacters&#39;.  Note that the value returned will be in the
        // range &#39;[0 .. numCharacters]&#39;.  Also note that &#39;string&#39; may contain
        // less than &#39;bsl::strlen(string)&#39; UTF-8 characters.

    static int advanceIfValid(int         *status,
                              const char **result,
                              const char  *string,
                              int          length,
                              int          numCharacters);
        // Advance past 0 or more consecutive *valid* UTF-8 characters at the
        // beginning of the specified &#39;string&#39; having the specified &#39;length&#39;
        // (in bytes), until either the specified &#39;numCharacters&#39; or &#39;length&#39;
        // bytes have been traversed, or invalid UTF-8 is encountered
        // (whichever occurs first), and return the number of UTF-8 characters
        // traversed.  Set the specified &#39;*status&#39; to 0 if no invalid UTF-8 is
        // encountered, and to a non-zero value otherwise.  Set the specified
        // &#39;*result&#39; to the address of the byte immediately following the last
        // character traversed, or to &#39;string&#39; if &#39;length&#39; or &#39;numCharacters&#39;
        // is 0.  &#39;string&#39; need not be null-terminated and can contain embedded
        // null characters.  The behavior is undefined unless &#39;0 &lt;= length&#39; and
        // &#39;0 &lt;= numCharacters&#39;.  Note that the value returned will be in the
        // range &#39;[0 .. numCharacters]&#39;.  Also note that &#39;string&#39; may contain
        // less than &#39;length&#39; UTF-8 characters.

    static int advanceRaw(const char **result,
                          const char  *string,
                          int          numCharacters);
        // Advance past 0 or more consecutive UTF-8 characters at the beginning
        // of the specified &#39;string&#39;, until either the specified
        // &#39;numCharacters&#39; have been traversed or the terminating null
        // character is encountered (whichever occurs first), and return the
        // number of UTF-8 characters traversed.  Set the specified &#39;*result&#39;
        // to the address of the byte immediately following the last character
        // traversed, or to &#39;string&#39; if &#39;string&#39; is empty or &#39;numCharacters&#39; is
        // 0.  &#39;string&#39; is necessarily null-terminated, so it cannot contain
        // embedded null characters.  The behavior is undefined unless &#39;string&#39;
        // contains valid UTF-8 and &#39;0 &lt;= numCharacters&#39;.  Note that the value
        // returned will be in the range &#39;[0 .. numCharacters]&#39;.  Also note
        // that &#39;string&#39; may contain less than &#39;bsl::strlen(string)&#39; UTF-8
        // characters.

    static int advanceRaw(const char **result,
                          const char  *string,
                          int          length,
                          int          numCharacters);
        // Advance past 0 or more consecutive UTF-8 characters at the beginning
        // of the specified &#39;string&#39; having the specified &#39;length&#39; (in bytes),
        // until either the specified &#39;numCharacters&#39; or &#39;length&#39; bytes have
        // been traversed (whichever occurs first), and return the number of
        // UTF-8 characters traversed.  Set the specified &#39;*result&#39; to the
        // address of the byte immediately following the last character
        // traversed, or to &#39;string&#39; if &#39;length&#39; or &#39;numCharacters&#39; is 0.
        // &#39;string&#39; need not be null-terminated and can contain embedded null
        // characters.  The behavior is undefined unless &#39;0 &lt;= length&#39;, the
        // initial &#39;length&#39; bytes of &#39;string&#39; contain valid UTF-8, and
        // &#39;0 &lt;= numCharacters&#39;.  Note that the value returned will be in the
        // range &#39;[0 .. numCharacters]&#39;.  Also note that &#39;string&#39; may contain
        // less than &#39;length&#39; UTF-8 characters.

    static bool isValid(const char *string);
        // Return &#39;true&#39; if the specified &#39;string&#39; contains valid UTF-8, and
        // &#39;false&#39; otherwise.  &#39;string&#39; is necessarily null-terminated, so it
        // cannot contain embedded null characters.

    static bool isValid(const char *string, int length);
        // Return &#39;true&#39; if the specified &#39;string&#39; having the specified
        // &#39;length&#39; (in bytes) contains valid UTF-8, and &#39;false&#39; otherwise.
        // &#39;string&#39; need not be null-terminated and can contain embedded null
        // characters.  The behavior is undefined unless &#39;0 &lt;= length&#39;.

    static bool isValid(const char **invalidString, const char *string);
        // Return &#39;true&#39; if the specified &#39;string&#39; contains valid UTF-8, and
        // &#39;false&#39; otherwise.  If &#39;string&#39; contains invalid UTF-8, load into
        // the specified &#39;invalidString&#39; the address of the first character in
        // &#39;string&#39; that does not constitute the start of a valid UTF-8
        // character encoding; &#39;invalidString&#39; is uneffected if &#39;string&#39;
        // contains valid UTF-8.  &#39;string&#39; is necessarily null-terminated, so
        // it cannot contain embedded null characters.

    static bool isValid(const char **invalidString,
                        const char  *string,
                        int          length);
        // Return &#39;true&#39; if the specified &#39;string&#39; having the specified
        // &#39;length&#39; (in bytes) contains valid UTF-8, and &#39;false&#39; otherwise.
        // If &#39;string&#39; contains invalid UTF-8, load into the specified
        // &#39;invalidString&#39; the address of the first character in &#39;string&#39; that
        // does not constitute the start of a valid UTF-8 character encoding;
        // &#39;invalidString&#39; is uneffected if &#39;string&#39; contains valid UTF-8.
        // &#39;string&#39; need not be null-terminated and can contain embedded null
        // characters.  The behavior is undefined unless &#39;0 &lt;= length&#39;.

    static int numCharactersIfValid(const char **invalidString,
                                    const char  *string);
        // Return the number of UTF-8 characters in the specified &#39;string&#39; if
        // it contains valid UTF-8, with no effect on the specified
        // &#39;invalidString&#39;.  Otherwise, return a negative value and load into
        // &#39;invalidString&#39; the address of the first character in &#39;string&#39; that
        // does not constitute the start of a valid UTF-8 character encoding.
        // &#39;string&#39; is necessarily null-terminated, so it cannot contain
        // embedded null characters.  Note that &#39;string&#39; may contain less than
        // &#39;bsl::strlen(string)&#39; UTF-8 characters.

    static int numCharactersIfValid(const char **invalidString,
                                    const char  *string,
                                    int          length);
        // Return the number of UTF-8 characters in the specified &#39;string&#39;
        // having the specified &#39;length&#39; (in bytes) if &#39;string&#39; contains valid
        // UTF-8, with no effect on the specified &#39;invalidString&#39;.  Otherwise,
        // return a negative value and load into &#39;invalidString&#39; the address of
        // the first character in &#39;string&#39; that does not constitute the start
        // of a valid UTF-8 character encoding.  &#39;string&#39; need not be
        // null-terminated and can contain embedded null characters.  The
        // behavior is undefined unless &#39;0 &lt;= length&#39;.  Note that &#39;string&#39; may
        // contain less than &#39;length&#39; UTF-8 characters.

    static int numCharactersRaw(const char *string);
        // Return the number of UTF-8 characters in the specified &#39;string&#39;.
        // &#39;string&#39; is necessarily null-terminated, so it cannot contain
        // embedded null characters.  The behavior is undefined unless &#39;string&#39;
        // contains valid UTF-8.  Note that &#39;string&#39; may contain less than
        // &#39;bsl::strlen(string)&#39; UTF-8 characters.

    static int numCharactersRaw(const char *string, int length);
        // Return the number of UTF-8 characters in the specified &#39;string&#39;
        // having the specified &#39;length&#39; (in bytes).  &#39;string&#39; need not be
        // null-terminated and can contain embedded null characters.  The
        // behavior is undefined unless &#39;0 &lt;= length&#39;, and &#39;string&#39; contains
        // valid UTF-8.  Note that &#39;string&#39; may contain less than &#39;length&#39;
        // UTF-8 characters.

    static int numCharacters(const char *string);
        // Return the number of UTF-8 characters in the specified &#39;string&#39;.
        // &#39;string&#39; is necessarily null-terminated, so it cannot contain
        // embedded null characters.  The behavior is undefined unless &#39;string&#39;
        // contains valid UTF-8.  Note that &#39;string&#39; may contain less than
        // &#39;bsl::strlen(string)&#39; UTF-8 characters.
        //
        // DEPRECATED: Use &#39;numCharactersRaw&#39; instead.

    static int numCharacters(const char *string, int length);
        // Return the number of UTF-8 characters in the specified &#39;string&#39;
        // having the specified &#39;length&#39; (in bytes).  &#39;string&#39; need not be
        // null-terminated and can contain embedded null characters.  The
        // behavior is undefined unless &#39;0 &lt;= length&#39;, and &#39;string&#39; contains
        // valid UTF-8.  Note that &#39;string&#39; may contain less than &#39;length&#39;
        // UTF-8 characters.
        //
        // DEPRECATED: Use &#39;numCharactersRaw&#39; instead.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                              // ---------------
                              // struct Utf8Util
                              // ---------------

// CLASS METHODS
inline
bool Utf8Util::isValid(const char *string)
{
    BSLS_ASSERT_SAFE(string);

    const char *dummy = 0;

    return isValid(&amp;dummy, string);
}

inline
bool Utf8Util::isValid(const char *string, int length)
{
    BSLS_ASSERT_SAFE(string);
    BSLS_ASSERT_SAFE(0 &lt;= length);

    const char *dummy = 0;

    return isValid(&amp;dummy, string, length);
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
