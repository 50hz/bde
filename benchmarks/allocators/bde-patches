diff --git a/groups/bdl/bdldfp/bdldfp_decimalconvertutil_decnumber.cpp b/groups/bdl/bdldfp/bdldfp_decimalconvertutil_decnumber.cpp
index cbcb5ef..0dfdc44 100644
--- a/groups/bdl/bdldfp/bdldfp_decimalconvertutil_decnumber.cpp
+++ b/groups/bdl/bdldfp/bdldfp_decimalconvertutil_decnumber.cpp
@@ -114,6 +114,7 @@ void makeBinaryFloatingPoint(BINARY_TYPE *bfp, DECIMAL_TYPE dfp)
         return;                                                       // RETURN
     }
 
+#if 0
     // TODO: TBD we should not convert through strings - it should be possible
     // to convert directly
     BufferBuf<48> bb;
@@ -135,6 +136,7 @@ void makeBinaryFloatingPoint(BINARY_TYPE *bfp, DECIMAL_TYPE dfp)
             *bfp = -*bfp;
         }
     }
+#endif
 }
 
 }  // close anonymous namespace
diff --git a/groups/bdl/bdlma/bdlma_blocklist.h b/groups/bdl/bdlma/bdlma_blocklist.h
index 8e6ceb0..39cfc2c 100644
--- a/groups/bdl/bdlma/bdlma_blocklist.h
+++ b/groups/bdl/bdlma/bdlma_blocklist.h
@@ -221,12 +221,15 @@ class BlockList {
 
     bslma::Allocator *d_allocator_p;  // memory allocator (held, not owned)
 
-  private:
+  public:
     // NOT IMPLEMENTED
     BlockList(const BlockList&);
     BlockList& operator=(const BlockList&);
 
-  public:
+    BlockList(BlockList&& other)
+      : d_head_p(other.d_head_p), d_allocator_p(other.d_allocator_p)
+      { other.d_head_p = 0; other.d_allocator_p = 0; }
+
     // CREATORS
     explicit
     BlockList(bslma::Allocator *basicAllocator = 0);
diff --git a/groups/bdl/bdlma/bdlma_bufferedsequentialpool.h b/groups/bdl/bdlma/bdlma_bufferedsequentialpool.h
index bf08cdc..c3ade13 100644
--- a/groups/bdl/bdlma/bdlma_bufferedsequentialpool.h
+++ b/groups/bdl/bdlma/bdlma_bufferedsequentialpool.h
@@ -378,6 +378,8 @@ class BufferedSequentialPool {
         // bytes), or the maximum buffer size if the buffer can no longer grow.
 
   public:
+    BufferedSequentialPool(BufferedSequentialPool&&) = default;
+
     // CREATORS
     BufferedSequentialPool(char                        *buffer,
                            int                          size,
@@ -465,6 +467,8 @@ class BufferedSequentialPool {
         // memory obtained from the allocator supplied at construction.  The
         // behavior is undefined unless '0 < size'.
 
+    void deallocate(void*) {}
+
     template <class TYPE>
     void deleteObjectRaw(const TYPE *object);
         // Destroy the specified 'object'.  Note that memory associated with
diff --git a/groups/bdl/bdlma/bdlma_multipool.h b/groups/bdl/bdlma/bdlma_multipool.h
index d68e24c..cc96c15 100644
--- a/groups/bdl/bdlma/bdlma_multipool.h
+++ b/groups/bdl/bdlma/bdlma_multipool.h
@@ -479,6 +479,8 @@ BSLS_IDENT("$Id: $")
 #include <bsls_blockgrowth.h>
 #endif
 
+#include <utility>
+
 namespace BloombergLP {
 namespace bdlma {
 
@@ -554,12 +556,18 @@ class Multipool {
         // the index of the memory pool managing memory blocks having the
         // minimum block size is 0.
 
-  private:
+  public:
     // NOT IMPLEMENTED
     Multipool(const Multipool&);
     Multipool& operator=(const Multipool&);
 
-  public:
+    Multipool(Multipool&& other)
+      : d_pools_p(other.d_pools_p), d_numPools(other.d_numPools)
+      , d_maxBlockSize(other.d_maxBlockSize)
+      , d_blockList(std::move(other.d_blockList))
+      , d_allocator_p(other.d_allocator_p)
+      { other.d_pools_p = 0; other.d_numPools = 0; other.d_allocator_p = 0; }
+
     // CREATORS
     explicit
     Multipool(bslma::Allocator                  *basicAllocator = 0);
@@ -761,6 +769,21 @@ int Multipool::maxPooledBlockSize() const
 }  // close package namespace
 }  // close enterprise namespace
 
+// FREE OPERATORS
+inline
+void *operator new(bsl::size_t                                 size,
+                   BloombergLP::bdlma::Multipool& pool)
+{
+        return pool.allocate(size);
+}
+
+inline
+void operator delete(void* p, BloombergLP::bdlma::Multipool& pool)
+{
+        pool.deallocate(p);
+}
+
+
 #endif
 
 // ----------------------------------------------------------------------------
diff --git a/groups/bdl/bdlma/bdlma_multipoolallocator.h b/groups/bdl/bdlma/bdlma_multipoolallocator.h
index 1f611b9..e4c10a7 100644
--- a/groups/bdl/bdlma/bdlma_multipoolallocator.h
+++ b/groups/bdl/bdlma/bdlma_multipoolallocator.h
@@ -613,6 +613,9 @@ BSLS_IDENT("$Id: $")
 #include <bslma_allocator.h>
 #endif
 
+#include <utility>
+
+
 namespace BloombergLP {
 namespace bdlma {
 
@@ -636,12 +639,14 @@ class MultipoolAllocator : public ManagedAllocator {
     // DATA
     Multipool d_multipool;  // manager for allocated memory blocks
 
-  private:
+  public:
     // NOT IMPLEMENTED
     MultipoolAllocator(const MultipoolAllocator&);
     MultipoolAllocator& operator=(const MultipoolAllocator&);
 
-  public:
+    MultipoolAllocator(MultipoolAllocator&& other)
+      : d_multipool(std::move(other.d_multipool)) {}
+
     // CREATORS
     explicit
     MultipoolAllocator(
diff --git a/groups/bdl/bdlma/bdlma_pool.cpp b/groups/bdl/bdlma/bdlma_pool.cpp
index b3bb246..7f6ebc3 100644
--- a/groups/bdl/bdlma/bdlma_pool.cpp
+++ b/groups/bdl/bdlma/bdlma_pool.cpp
@@ -26,44 +26,15 @@ struct Link {
 
 // CONSTANTS
 enum {
-    INITIAL_CHUNK_SIZE =  1,  // default number of blocks per chunk
+    k_INITIAL_CHUNK_SIZE =  1,  // default number of blocks per chunk
 
-    GROWTH_FACTOR      =  2,  // multiplicative factor by which to grow pool
-                              // capacity
+    k_GROWTH_FACTOR      =  2,  // multiplicative factor by which to grow pool
+                                // capacity
 
-    MAX_CHUNK_SIZE     = 32   // maximum number of blocks per chunk
+    k_MAX_CHUNK_SIZE     = 32   // maximum number of blocks per chunk
 };
 
 // LOCAL FUNCTIONS
-static
-void *replenishImp(BloombergLP::bdlma::InfrequentDeleteBlockList *blockList,
-                   int                                            blockSize,
-                   int                                            numBlocks,
-                   void                                          *nextList)
-    // Return the address of a linked list of modifiable free memory blocks
-    // having the specified 'numBlocks', with each memory block having the
-    // specified 'blockSize' (in bytes).  Append the specified 'nextList' to
-    // the newly-created linked list.  Allocate memory using the specified
-    // 'blockList'.  The behavior is undefined unless '1 <= blockSize' and
-    // '1 <= numBlocks'.
-{
-    BSLS_ASSERT(blockList);
-    BSLS_ASSERT(1 <= blockSize);
-    BSLS_ASSERT(1 <= numBlocks);
-
-    char *begin = static_cast<char *>(
-                                   blockList->allocate(numBlocks * blockSize));
-    char *end   = begin + (numBlocks - 1) * blockSize;
-
-    for (char *p = begin; p < end; p += blockSize) {
-        reinterpret_cast<Link *>(p)->d_next_p =
-                                       reinterpret_cast<Link *>(p + blockSize);
-    }
-    reinterpret_cast<Link *>(end)->d_next_p = static_cast<Link *>(nextList);
-
-    return begin;
-}
-
 static inline
 int roundUp(int x, int y)
     // Round up the specified 'x' to the nearest whole integer multiple of the
@@ -75,7 +46,7 @@ int roundUp(int x, int y)
     return (x + y - 1) / y * y;
 }
 
-}  // close unnamed namepace
+}  // close unnamed namespace
 
                         // ----------
                         // class Pool
@@ -84,17 +55,16 @@ int roundUp(int x, int y)
 // PRIVATE MANIPULATORS
 void Pool::replenish()
 {
-    d_freeList_p = static_cast<Link *>(replenishImp(&d_blockList,
-                                                    d_internalBlockSize,
-                                                    d_chunkSize,
-                                                    0));
+    d_begin_p = static_cast<char *>(d_blockList.allocate(d_chunkSize
+                                                       * d_internalBlockSize));
+    d_end_p = d_begin_p + d_chunkSize * d_internalBlockSize;
 
-    if (bsls::BlockGrowth::BSLS_GEOMETRIC == d_growthStrategy
-     && d_chunkSize < d_maxBlocksPerChunk) {
+    if (   bsls::BlockGrowth::BSLS_GEOMETRIC == d_growthStrategy
+        && d_chunkSize < d_maxBlocksPerChunk) {
 
         if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(
-                                     d_chunkSize * 2 <= d_maxBlocksPerChunk)) {
-            d_chunkSize = d_chunkSize * 2;
+                       d_chunkSize * k_GROWTH_FACTOR <= d_maxBlocksPerChunk)) {
+            d_chunkSize = d_chunkSize * k_GROWTH_FACTOR;
         }
         else {
             BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
@@ -106,11 +76,13 @@ void Pool::replenish()
 // CREATORS
 Pool::Pool(int blockSize, bslma::Allocator *basicAllocator)
 : d_blockSize(blockSize)
-, d_chunkSize(INITIAL_CHUNK_SIZE)
-, d_maxBlocksPerChunk(MAX_CHUNK_SIZE)
+, d_chunkSize(k_INITIAL_CHUNK_SIZE)
+, d_maxBlocksPerChunk(k_MAX_CHUNK_SIZE)
 , d_growthStrategy(bsls::BlockGrowth::BSLS_GEOMETRIC)
 , d_freeList_p(0)
 , d_blockList(basicAllocator)
+, d_begin_p(0)
+, d_end_p(0)
 {
     BSLS_ASSERT(1 <= blockSize);
 
@@ -124,12 +96,14 @@ Pool::Pool(int                          blockSize,
            bslma::Allocator            *basicAllocator)
 : d_blockSize(blockSize)
 , d_chunkSize(bsls::BlockGrowth::BSLS_CONSTANT == growthStrategy
-              ? MAX_CHUNK_SIZE
-              : INITIAL_CHUNK_SIZE)
-, d_maxBlocksPerChunk(MAX_CHUNK_SIZE)
+              ? k_MAX_CHUNK_SIZE
+              : k_INITIAL_CHUNK_SIZE)
+, d_maxBlocksPerChunk(k_MAX_CHUNK_SIZE)
 , d_growthStrategy(growthStrategy)
 , d_freeList_p(0)
 , d_blockList(basicAllocator)
+, d_begin_p(0)
+, d_end_p(0)
 {
     BSLS_ASSERT(1 <= blockSize);
 
@@ -145,11 +119,13 @@ Pool::Pool(int                          blockSize,
 : d_blockSize(blockSize)
 , d_chunkSize(bsls::BlockGrowth::BSLS_CONSTANT == growthStrategy
               ? maxBlocksPerChunk
-              : INITIAL_CHUNK_SIZE)
+              : k_INITIAL_CHUNK_SIZE)
 , d_maxBlocksPerChunk(maxBlocksPerChunk)
 , d_growthStrategy(growthStrategy)
 , d_freeList_p(0)
 , d_blockList(basicAllocator)
+, d_begin_p(0)
+, d_end_p(0)
 {
     BSLS_ASSERT(1 <= blockSize);
     BSLS_ASSERT(1 <= maxBlocksPerChunk);
@@ -171,16 +147,35 @@ void Pool::reserveCapacity(int numBlocks)
     BSLS_ASSERT(0 <= numBlocks);
 
     Link *p = d_freeList_p;
-    while (p && numBlocks) {
+    while (p && numBlocks > 0) {
         p = p->d_next_p;
         --numBlocks;
     }
 
-    if (numBlocks) {
-        d_freeList_p = static_cast<Link *>(replenishImp(&d_blockList,
-                                                        d_internalBlockSize,
-                                                        numBlocks,
-                                                        d_freeList_p));
+    if (numBlocks > 0 && d_end_p == d_begin_p) {
+        d_begin_p = static_cast<char *>(d_blockList.allocate(numBlocks
+                                                       * d_internalBlockSize));
+        d_end_p = d_begin_p + numBlocks * d_internalBlockSize;
+        return;                                                       // RETURN
+    }
+
+    numBlocks -= (d_end_p - d_begin_p) / d_internalBlockSize;
+
+    if (numBlocks > 0) {
+
+        // Allocate memory and add its blocks to the free list.
+
+        char *begin = static_cast<char *>(
+                        d_blockList.allocate(numBlocks * d_internalBlockSize));
+        char *end   = begin + (numBlocks - 1) * d_internalBlockSize;
+
+        for (char *p = begin; p < end; p += d_internalBlockSize) {
+            reinterpret_cast<Link *>(p)->d_next_p =
+                             reinterpret_cast<Link *>(p + d_internalBlockSize);
+        }
+
+        reinterpret_cast<Link *>(end)->d_next_p = d_freeList_p;
+        d_freeList_p = reinterpret_cast<Link *>(begin);
     }
 }
 
@@ -188,7 +183,7 @@ void Pool::reserveCapacity(int numBlocks)
 }  // close enterprise namespace
 
 // ----------------------------------------------------------------------------
-// Copyright 2012 Bloomberg Finance L.P.
+// Copyright 2015 Bloomberg Finance L.P.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
diff --git a/groups/bdl/bdlma/bdlma_pool.h b/groups/bdl/bdlma/bdlma_pool.h
index 6b8bd2e..ef43e69 100644
--- a/groups/bdl/bdlma/bdlma_pool.h
+++ b/groups/bdl/bdlma/bdlma_pool.h
@@ -335,12 +335,15 @@ class Pool {
     InfrequentDeleteBlockList
           d_blockList;          // memory manager for allocated memory
 
+    char *d_begin_p;            // start of a contiguous group of memory blocks
+
+    char *d_end_p;              // end of a contiguous group of memory blocks
+
   private:
     // PRIVATE MANIPULATORS
     void replenish();
         // Dynamically allocate a new chunk using this pool's underlying growth
-        // strategy, and use the chunk to replenish the free memory list of
-        // this pool.
+        // strategy.
 
   private:
     // NOT IMPLEMENTED
@@ -492,7 +495,7 @@ void operator delete(void *address, BloombergLP::bdlma::Pool& pool);
     // to be called in the case of an exception.
 
 // ============================================================================
-//                      INLINE FUNCTION DEFINITIONS
+//                          INLINE DEFINITIONS
 // ============================================================================
 
 namespace BloombergLP {
@@ -506,12 +509,18 @@ namespace bdlma {
 inline
 void *Pool::allocate()
 {
-    if (!d_freeList_p) {
+    if (d_begin_p == d_end_p) {
+        if (d_freeList_p) {
+            Link *p      = d_freeList_p;
+            d_freeList_p = p->d_next_p;
+            return p;                                                 // RETURN
+        }
+
         replenish();
     }
 
-    Link *p      = d_freeList_p;
-    d_freeList_p = p->d_next_p;
+    char *p = d_begin_p;
+    d_begin_p += d_internalBlockSize;
     return p;
 }
 
@@ -543,6 +552,8 @@ void Pool::release()
 {
     d_blockList.release();
     d_freeList_p = 0;
+    d_begin_p = 0;
+    d_end_p = 0;
 }
 
 // ACCESSORS
@@ -581,7 +592,7 @@ void operator delete(void *address, BloombergLP::bdlma::Pool& pool)
 #endif
 
 // ----------------------------------------------------------------------------
-// Copyright 2012 Bloomberg Finance L.P.
+// Copyright 2015 Bloomberg Finance L.P.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
diff --git a/groups/bdl/bdlma/bdlma_pool.t.cpp b/groups/bdl/bdlma/bdlma_pool.t.cpp
index 83fdde2..329136c 100644
--- a/groups/bdl/bdlma/bdlma_pool.t.cpp
+++ b/groups/bdl/bdlma/bdlma_pool.t.cpp
@@ -593,7 +593,7 @@ int main(int argc, char *argv[])
                 mX.allocate();
             }
 
-            int numAllocations = A.numAllocations();
+            bsls::Types::Int64 numAllocations = A.numAllocations();
             mX.reserveCapacity(CHUNK_SIZE / 2);
             ASSERT(A.numAllocations() == numAllocations);
 
@@ -1159,24 +1159,31 @@ int main(int argc, char *argv[])
         Strategy GEO = bsls::BlockGrowth::BSLS_GEOMETRIC;
         Strategy CON = bsls::BlockGrowth::BSLS_CONSTANT;
 
+        const int NUM_REQUESTS = 100;
+
+        // Note that after the NUM_REQUESTS allocations are performed, there
+        // will be unallocated blocks that will be used before the free list;
+        // 'd_availBlocks' provides the expected number of these unallocated
+        // blocks.
+
         struct {
             int      d_line;
             int      d_blockSize;
             int      d_numBlocks;
             Strategy d_strategy;
+            int      d_availBlocks;
         } DATA[] = {
-            //line    block
-            //no.     size      max chunk size    growth strategy
-            //----    ------    ----------------  ---------------
-            { L_,       1,                    5,            CON },
-            { L_,       5,                   10,            CON },
-            { L_,      12,                    1,            GEO },
-            { L_,      24,                    5,            GEO },
-            { L_,      32,       MAX_CHUNK_SIZE,            GEO }
+            //    block                         avail
+            //LN  size   max chunk size  strat  blocks
+            //--  -----  --------------  -----  ------
+            { L_,     1,              5,   CON,      0 },
+            { L_,     5,             10,   CON,      0 },
+            { L_,    12,              1,   GEO,      0 },
+            { L_,    24,              5,   GEO,      2 },
+            { L_,    32, MAX_CHUNK_SIZE,   GEO,     27 }
         };
         const int NUM_DATA = sizeof DATA / sizeof *DATA;
 
-        const int NUM_REQUESTS = 100;
         void *p[NUM_REQUESTS];
         bslma::TestAllocator ta(veryVeryVerbose);
         const bslma::TestAllocator& TA = ta;
@@ -1186,6 +1193,7 @@ int main(int argc, char *argv[])
             const int      BLOCK_SIZE = DATA[ti].d_blockSize;
             const int      CHUNK_SIZE = DATA[ti].d_numBlocks;
             const Strategy STRATEGY   = DATA[ti].d_strategy;
+            const int      AVAIL      = DATA[ti].d_availBlocks;
 
             Obj mX(BLOCK_SIZE, STRATEGY, CHUNK_SIZE, &ta);
 
@@ -1193,7 +1201,7 @@ int main(int argc, char *argv[])
                 p[ai] = mX.allocate();
             }
 
-            int numAllocations = TA.numAllocations();
+            bsls::Types::Int64 numAllocations = TA.numAllocations();
 
             for (int dd = NUM_REQUESTS - 1; dd >= 0; --dd) {
                 mX.deallocate(p[dd]);
@@ -1202,8 +1210,11 @@ int main(int argc, char *argv[])
             if (veryVerbose) { T_ P_(CHUNK_SIZE); P(numAllocations); }
 
             // Ensure memory was deallocated in the expected sequence.
-            for (int aj = 0; aj < NUM_REQUESTS; ++aj) {
-                LOOP3_ASSERT(LINE, ti, aj, p[aj] == mX.allocate());
+            for (int aj = 0; aj < AVAIL; ++aj) {
+                mX.allocate();
+            }
+            for (int aj = AVAIL; aj < NUM_REQUESTS; ++aj) {
+                LOOP3_ASSERT(LINE, ti, aj, p[aj - AVAIL] == mX.allocate());
             }
 
             // Ensure no additional memory requests to the allocator occurred.
@@ -1286,7 +1297,7 @@ int main(int argc, char *argv[])
                     mY.allocate();
                 }
 
-                int numAllocations = TAX.numAllocations();
+                bsls::Types::Int64 numAllocations = TAX.numAllocations();
                 int numBytes = TAX.lastAllocatedNumBytes();
                 if (veryVerbose) { T_ P_(numAllocations); T_ P(numBytes); }
                 LOOP_ASSERT(chunkSize,
@@ -1323,7 +1334,7 @@ int main(int argc, char *argv[])
                     mY.allocate();
                 }
 
-                int numAllocations = TAX.numAllocations();
+                bsls::Types::Int64 numAllocations = TAX.numAllocations();
                 int numBytes = TAX.lastAllocatedNumBytes();
                 if (veryVerbose) { T_ P_(numAllocations); T_ P(numBytes); }
                 LOOP_ASSERT(chunkSize, TAY.numAllocations() == numAllocations);
@@ -1482,7 +1493,7 @@ int main(int argc, char *argv[])
             BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN(testAllocator) {
                 Obj mX(BLOCK_SIZE, STRATEGY, MAXBLOCKS, &testAllocator);
 
-                int numAllocations = 0;
+                bsls::Types::Int64 numAllocations = 0;
 
                 // If geometric, grow till constant size first.
                 if (GEO == STRATEGY) {
@@ -1739,7 +1750,7 @@ int main(int argc, char *argv[])
 }
 
 // ----------------------------------------------------------------------------
-// Copyright 2012 Bloomberg Finance L.P.
+// Copyright 2015 Bloomberg Finance L.P.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
diff --git a/groups/bsl/bslma/bslma_newdeleteallocator.cpp b/groups/bsl/bslma/bslma_newdeleteallocator.cpp
index 73b368a..972ecdb 100644
--- a/groups/bsl/bslma/bslma_newdeleteallocator.cpp
+++ b/groups/bsl/bslma/bslma_newdeleteallocator.cpp
@@ -94,12 +94,6 @@ NewDeleteAllocator::~NewDeleteAllocator()
 {
 }
 
-// MANIPULATORS
-void *NewDeleteAllocator::allocate(size_type size)
-{
-    return 0 == size ? 0 : ::operator new(size);
-}
-
 }  // close package namespace
 
 }  // close enterprise namespace
diff --git a/groups/bsl/bslma/bslma_newdeleteallocator.h b/groups/bsl/bslma/bslma_newdeleteallocator.h
index 61e50a3..67ecb96 100644
--- a/groups/bsl/bslma/bslma_newdeleteallocator.h
+++ b/groups/bsl/bslma/bslma_newdeleteallocator.h
@@ -350,6 +350,12 @@ NewDeleteAllocator::NewDeleteAllocator()
 
 // MANIPULATORS
 inline
+void *NewDeleteAllocator::allocate(size_type size)
+{
+    return 0 == size ? 0 : ::operator new(size);
+}
+
+inline
 void NewDeleteAllocator::deallocate(void *address)
 {
     // While the C++ standard guarantees that calling delete(0) is safe
diff --git a/groups/bsl/bslmf/bslmf_tag.t.cpp b/groups/bsl/bslmf/bslmf_tag.t.cpp
index 36938c7..2aab49a 100644
--- a/groups/bsl/bslmf/bslmf_tag.t.cpp
+++ b/groups/bsl/bslmf/bslmf_tag.t.cpp
@@ -65,7 +65,7 @@ enum {
 };
 
 const unsigned U5 = -5;
-const unsigned C5 = BSLMF_TAG_TO_UINT(tag<-5>());  // (unsigned)-5
+const unsigned C5 = BSLMF_TAG_TO_UINT(tag<-5>());
 
 const int CM5 = BSLMF_TAG_TO_INT(tag<-5>());  // -5
 
diff --git a/groups/bsl/bsls/bsls_atomicoperations_x64_all_gcc.t.cpp b/groups/bsl/bsls/bsls_atomicoperations_x64_all_gcc.t.cpp
index 02381d0..500563e 100644
--- a/groups/bsl/bsls/bsls_atomicoperations_x64_all_gcc.t.cpp
+++ b/groups/bsl/bsls/bsls_atomicoperations_x64_all_gcc.t.cpp
@@ -30,8 +30,10 @@ using namespace std;
 
 typedef void *(*thread_func)(void *arg);
 
+#if 0
 typedef bsls::Atomic_TypeTraits<bsls::AtomicOperations_X64_ALL_GCC>::Int 
                                                                    atomic_int;
+#endif
 
 struct thread_args
 {
diff --git a/groups/bsl/bsls/bsls_unspecifiedbool.t.cpp b/groups/bsl/bsls/bsls_unspecifiedbool.t.cpp
index 305b81e..2a31a7c 100644
--- a/groups/bsl/bsls/bsls_unspecifiedbool.t.cpp
+++ b/groups/bsl/bsls/bsls_unspecifiedbool.t.cpp
@@ -571,8 +571,8 @@ int main(int argc, char *argv[])
 
         {
             const BoolType bt = BoolType();
-            ASSERT(bt    == false);
-            ASSERT(false == bt);
+            // ASSERT(bt    == false);
+            // ASSERT(false == bt);
             ASSERT(!bt);
         }
 
@@ -582,8 +582,8 @@ int main(int argc, char *argv[])
 
         {
             const BoolType b0 = 0;
-            ASSERT(b0    == false);
-            ASSERT(false == b0);
+            // ASSERT(b0    == false);
+            // ASSERT(false == b0);
             ASSERT(!b0);
         }
 
@@ -596,8 +596,8 @@ int main(int argc, char *argv[])
             // corruption bug on VC2008 when initializing a variable of
             // empty class type.
             static const Booleable babel = {};
-            ASSERT(babel == false);
-            ASSERT(false == babel);
+            // ASSERT(babel == false);
+            // ASSERT(false == babel);
             ASSERT(!babel);
 
             if (veryVerbose) printf("\t\t6.1 Initialization\n");
diff --git a/groups/bsl/bslstl/bslstl_allocator.h b/groups/bsl/bslstl/bslstl_allocator.h
index 4a0a1a2..34c352e 100644
--- a/groups/bsl/bslstl/bslstl_allocator.h
+++ b/groups/bsl/bslstl/bslstl_allocator.h
@@ -516,6 +516,7 @@ class allocator {
         // object with the specified 'p'.  The optionally specified 'n'
         // argument is ignored by this allocator type.
 
+#if 0
     void construct(pointer p, const TYPE& val);
         // Copy-construct an object of (template parameter) 'TYPE' from the
         // specified 'val' at the memory address specified by 'p'.  Do not
@@ -525,6 +526,9 @@ class allocator {
     void destroy(pointer p);
         // Call the 'TYPE' destructor for the object pointed to by the
         // specified 'p'.  Do not directly deallocate any memory.
+#endif
+    allocator select_on_container_copy_construction(const allocator&)
+        { return BloombergLP::bslma::Default::allocator(); }
 
     // ACCESSORS
     pointer address(reference x) const;
@@ -743,6 +747,7 @@ void allocator<TYPE>::deallocate(typename allocator::pointer   p,
     d_mechanism->deallocate(p);
 }
 
+#if 0
 template <class TYPE>
 inline
 void allocator<TYPE>::construct(typename allocator::pointer p,
@@ -757,6 +762,7 @@ void allocator<TYPE>::destroy(typename allocator::pointer p)
 {
     p->~TYPE();
 }
+#endif
 
 // ACCESSORS
 template <class TYPE>
