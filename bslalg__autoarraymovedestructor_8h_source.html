<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslalg_autoarraymovedestructor.h                                   -*-C++-*-
#ifndef INCLUDED_BSLALG_AUTOARRAYMOVEDESTRUCTOR
#define INCLUDED_BSLALG_AUTOARRAYMOVEDESTRUCTOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a proctor for destroying arrays.
//
//@CLASSES:
//  bslalg::AutoArrayMoveDestructor: exception-neutrality guard for arrays
//
//@SEE_ALSO: bslma_autodestructor, bslalg_autoarraydestructor
//
//@DESCRIPTION: This component provides a proctor object to manage a contiguous
// (in-place) sequence of otherwise-unmanaged instances of a user-defined type.
// If not explicitly released, all objects managed by the proctor object are
// automatically destroyed by the proctor&#39;s destructor or moved back to their
// original area, using the &#39;bslalg_arraydestructionprimitives&#39; and
// &#39;std::memmove&#39;.  This component is intended to be used only with bit-wise
// moveable types, and for a very special purpose as shown in the usage
// example.
//
///Usage
///-----
// TBD

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_ARRAYDESTRUCTIONPRIMITIVES
#include &lt;bslalg_arraydestructionprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;        // std::size_t
#define INCLUDED_CSTDDEF
#endif

#ifndef INCLUDED_CSTRING
#include &lt;cstring&gt;        // memset, memcpy, memmove
#define INCLUDED_CSTRING
#endif

namespace BloombergLP {

namespace bslalg {

                    // =============================
                    // class AutoArrayMoveDestructor
                    // =============================

template &lt;class OBJECT_TYPE&gt;
class AutoArrayMoveDestructor {
    // This &#39;class&#39; provides a specialized proctor object that, upon
    // destruction and unless the &#39;release&#39; method has been called, bit-wise
    // moves the elements in a segment of an array of parameterized
    // &#39;OBJECT_TYPE&#39; back to some destination, and destroys some other elements
    // in an adjacent segment of the same array.  The elements destroyed are
    // delimited by the range &#39;[ begin(), middle() )&#39; and those moved to
    // &#39;destination()&#39; and in the range &#39;[ middle(), end() )&#39;.  Note that, once
    // constructed, &#39;begin()&#39; and &#39;end()&#39; remain fixed.  As the guard advances,
    // &#39;middle()&#39; and &#39;destination()&#39; move, reflecting the successful transfer
    // of data between the moving range and the destination.

    // DATA
    OBJECT_TYPE *d_dst_p;    // destination of the bit-wise move

    OBJECT_TYPE *d_begin_p;  // address of first element in guarded range

    OBJECT_TYPE *d_middle_p; // address of first moved element in guarded range
                             // which is also first address beyond last element
                             // destroyed in same guarded range

    OBJECT_TYPE *d_end_p;    // first address beyond last (moved) element in
                             // guarded range

    // CLASS INVARIANT
    BSLMF_ASSERT(bslmf::IsBitwiseMoveable&lt;OBJECT_TYPE&gt;::value);

  private:
    // NOT IMPLEMENTED
    AutoArrayMoveDestructor(const AutoArrayMoveDestructor&amp;);
    AutoArrayMoveDestructor&amp; operator=(const AutoArrayMoveDestructor&amp;);

  public:
    // CREATORS
    AutoArrayMoveDestructor(OBJECT_TYPE *destination,
                            OBJECT_TYPE *begin,
                            OBJECT_TYPE *middle,
                            OBJECT_TYPE *end);
        // Create a proctor for the sequence of elements of the parameterized
        // &#39;OBJECT_TYPE&#39; in the specified range &#39;[ begin, end )&#39; which, upon
        // destruction, moves the range &#39;[ begin, middle )&#39; to the specified
        // &#39;destination&#39; and destroys the &#39;[ middle, end )&#39; range.  The
        // behavior is undefined unless &#39;begin &lt;= middle &lt;= end&#39;, either
        // &#39;destination &lt; begin&#39; or &#39;end &lt;= destination&#39;, and each element in
        // the range &#39;[ begin, end )&#39; has been initialized.

    ~AutoArrayMoveDestructor();
        // Bit-wise move the range &#39;[ middle(), end() )&#39; to the &#39;destination()&#39;
        // address and destroy &#39;[ begin(), middle() )&#39;.

    // MANIPULATORS
    void advance();
        // Increment both middle and destination pointers by one position.  The
        // behavior is undefined if this operation result in &#39;destination()&#39;
        // entering the &#39;[ begin(), end() )&#39; range.

    // ACCESSORS
    OBJECT_TYPE *begin() const;
        // Return the address at the beginning of the guarded range.

    OBJECT_TYPE *destination() const;
        // Return the destination address, to which the second portion of the
        // guarded range, delimited by &#39;[ middle(), end() )&#39;, will be moved
        // upon destruction, or 0 if this guard has been released.

    OBJECT_TYPE *end() const;
        // Return the address at the end of the guarded range.

    OBJECT_TYPE *middle() const;
        // Return the address at the middle of the guarded range.
};

// ===========================================================================
//                         INLINE FUNCTION DEFINITIONS
// ===========================================================================

                    // -----------------------------
                    // class AutoArrayMoveDestructor
                    // -----------------------------

// CREATORS
template &lt;class OBJECT_TYPE&gt;
inline
AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::AutoArrayMoveDestructor(
                                                      OBJECT_TYPE *destination,
                                                      OBJECT_TYPE *begin,
                                                      OBJECT_TYPE *middle,
                                                      OBJECT_TYPE *end)
: d_dst_p(destination)
, d_begin_p(begin)
, d_middle_p(middle)
, d_end_p(end)
{
    BSLS_ASSERT_SAFE(!begin  == !middle);  // neither or both are null
    BSLS_ASSERT_SAFE(!middle == !end);     // neither or both are null
    BSLS_ASSERT_SAFE(destination || begin == middle);
    BSLS_ASSERT_SAFE(begin  &lt;= middle);
    BSLS_ASSERT_SAFE(middle &lt;= end);
    BSLS_ASSERT_SAFE(destination &lt; begin || end &lt;= destination);
}

template &lt;class OBJECT_TYPE&gt;
AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::~AutoArrayMoveDestructor()
{
    BSLS_ASSERT_SAFE(!d_begin_p  == !d_middle_p);  // neither or both are null
    BSLS_ASSERT_SAFE(!d_middle_p == !d_end_p);     // neither or both are null
    BSLS_ASSERT_SAFE(d_dst_p || d_begin_p == d_middle_p);
    BSLS_ASSERT_SAFE(d_begin_p  &lt;= d_middle_p);
    BSLS_ASSERT_SAFE(d_middle_p &lt;= d_end_p);
    BSLS_ASSERT_SAFE(d_dst_p    &lt;  d_begin_p
                  || d_end_p    &lt;= d_dst_p
                  || d_middle_p == d_end_p);

    if (d_middle_p != d_end_p) {
        std::size_t numBytes = (char *)d_end_p - (char *)d_middle_p;
        std::memcpy(d_dst_p, d_middle_p, numBytes);
        ArrayDestructionPrimitives::destroy(d_begin_p, d_middle_p);
    }
}

// MANIPULATORS
template &lt;class OBJECT_TYPE&gt;
inline
void AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::advance()
{
    BSLS_ASSERT_SAFE(d_middle_p &lt; d_end_p);

    ++d_middle_p;
    ++d_dst_p;

    BSLS_ASSERT_SAFE(d_dst_p != d_begin_p || d_middle_p == d_end_p);
}

// ACCESSORS
template &lt;class OBJECT_TYPE&gt;
inline
OBJECT_TYPE *AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::begin() const
{
    return d_begin_p;
}

template &lt;class OBJECT_TYPE&gt;
inline
OBJECT_TYPE *AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::middle() const
{
    return d_middle_p;
}

template &lt;class OBJECT_TYPE&gt;
inline
OBJECT_TYPE *AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::end() const
{
    return d_end_p;
}

template &lt;class OBJECT_TYPE&gt;
inline
OBJECT_TYPE *AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::destination() const
{
    return d_dst_p;
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
