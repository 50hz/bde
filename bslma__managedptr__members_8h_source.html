<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BSL 2.19 OSS</title>
<html>
<pre>
// bslma_managedptr_members.h                                         -*-C++-*-
#ifndef INCLUDED_BSLMA_MANAGEDPTR_MEMBERS
#define INCLUDED_BSLMA_MANAGEDPTR_MEMBERS

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide the internal state of a managed pointer class.
//
//@CLASSES:
//  bslma::ManagedPtr_Members: internal state of a bcema_ManagedPtr object
//
//@SEE_ALSO: bslma_managedptr
//
//@DESCRIPTION: This component provides a class to store and manage the
// internal state of a &#39;bslma::ManagedPtr&#39; object.  It enforces the rules for
// correct transfer of ownership from one &#39;bslma::ManagedPtr_Members&#39; object to
// another.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTRDELETER
#include &lt;bslma_managedptrdeleter.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {
namespace bslma {

                     // ==============================
                     // class ManagedPtr_Members
                     // ==============================

class ManagedPtr_Members {
    // Non-type-specific managed pointer member variables.  This type exists so
    // that a &#39;ManagedPtr_Ref&#39; can point to the representation of a
    // &#39;ManagedPtr&#39; even if the &#39;_Ref&#39; object is instantiated on a different
    // type than the managed pointer type (e.g., in the case of conversions or
    // aliasing).  &#39;ManagerPtr_Members&#39; also &quot;erases&quot; the types of each member,
    // so that the same object code can be shared between multiple
    // instantiations of the &#39;ManagedPtr&#39; class template, reducing template
    // bloat.  Note that objects of this type may have an &quot;unset&quot; state, where
    // the &#39;d_obj_p&#39; pointer has a null value, and the &#39;d_deleter&#39; member does
    // not have a specified value.  If &#39;d_obj_p&#39; has a null pointer value, then
    // this object must be in an unset state.

  private:
    // PRIVATE TYPES
    typedef ManagedPtrDeleter::Deleter DeleterFunc;

    void              *d_obj_p;     // pointer to the managed object.
                                    // A pointer to void is used so that this
                                    // single (non-template) class may be used
                                    // for any instantiation of the
                                    // &#39;bslma::ManagedPtrRef&#39; template.

    ManagedPtrDeleter  d_deleter;   // deleter-related information

  private:
    // NOT IMPLEMENTED
    ManagedPtr_Members&amp; operator=(const ManagedPtr_Members&amp;);

  public:
    // CREATORS
    ManagedPtr_Members();
        // Create a &#39;ManagedPtr_Members&#39; object in an unset state.  Sets
        // &#39;pointer&#39; to 0.

    explicit ManagedPtr_Members(ManagedPtr_Members&amp; other);
        // Create a &#39;ManagedPtr_Members&#39; object having the same &#39;pointer&#39; as
        // the specified &#39;other&#39; object, and, if &#39;pointer&#39; is not 0, the same
        // deleter as &#39;other&#39;, and then put &#39;other&#39; into an unset state.

    ManagedPtr_Members(void *object, void *factory, DeleterFunc deleter);
        // If &#39;object&#39; is 0, create a &#39;ManagedPtr_Members&#39; object that does not
        // manage a pointer; otherwise create a &#39;ManagedPtr_Members&#39; object
        // having the specified &#39;object&#39;, &#39;factory&#39; and &#39;deleter&#39;.

    ManagedPtr_Members(void        *object,
                       void        *factory,
                       DeleterFunc  deleter,
                       void        *alias);
        // If &#39;object&#39; is 0, create a &#39;ManagedPtr_Members&#39; object that does not
        // manage a pointer; otherwise create a &#39;ManagedPtr_Members&#39; object
        // having the specified &#39;object&#39;, &#39;factory&#39; and &#39;deleter&#39;, but aliasing
        // &#39;alias&#39;.  Note that this constructor is important for managed
        // pointers pointing to one of multiple base classes of a class using
        // multiple inheritance.

    //! ~ManagedPtr_Members() = default;
        // Destroy this &#39;ManagedPtr_Members&#39; object.  Note that this trivial
        // destructor&#39;s definition is compiler generated.

    // MANIPULATORS
    void clear();
        // Reset this object to an unset state.  Note that any previously
        // managed object will not be destroyed.

    void move(ManagedPtr_Members *other);
        // Re-initialize this object,  having the same &#39;pointer&#39; as the
        // specified &#39;other&#39; object, and, if &#39;pointer&#39; is not 0, the same
        // deleter as &#39;other&#39;, and then put &#39;other&#39; into an unset set.  Note
        // that any previously managed object will not be destroyed.

    void moveAssign(ManagedPtr_Members *other);
        // Destroy the currently managed object (if any) unless the specified
        // &#39;other&#39; refers to this object, then re-initialize this object,
        // having the same &#39;pointer&#39; as the specified &#39;other&#39; object, and, if
        // &#39;pointer&#39; is not 0, the same deleter as &#39;other&#39;, and then put
        // &#39;other&#39; into an unset set.

    void set(void *object, void *factory, DeleterFunc deleter);
        // Re-initialize this object with the specified &#39;object&#39; pointer value,
        // and the specified &#39;deleter&#39; function, using the specified &#39;factory&#39;.
        // Note that any previously managed object will not be destroyed.

    void setAliasPtr(void *ptr);
        // Set &#39;pointer&#39; to have the specified &#39;ptr&#39; value.  If &#39;ptr&#39; is 0 then
        // this object will have an unset state.

    void swap(ManagedPtr_Members&amp; other);
        // Efficiently exchange the state of this object with the state of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee.  Note that if either object is in an
        // unset state, there are no guarantees about the unset state that may
        // be exchanged, other than &#39;pointer&#39; shall be null.

    // ACCESSORS
    void runDeleter() const;
        // Destroy the currently managed object(if any).  Note that calling
        // this method twice without assigning a new pointer to manage will
        // produce undefined behavior, unless this object&#39;s current deleter
        // specifically supports such usage.

    void *pointer() const;
        // Return a pointer to the currently managed object.

    const ManagedPtrDeleter&amp; deleter() const;
        // Return the &#39;ManagedPtrDeleter&#39; object that should be used to destroy
        // the currently managed object, if any.  Behavior is undefined unless
        // &#39;pointer&#39; is not null.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                    // ------------------------------
                    // class ManagedPtr_Members
                    // ------------------------------

// CREATORS
inline
ManagedPtr_Members::ManagedPtr_Members()
: d_obj_p(0)
{
}

inline
ManagedPtr_Members::ManagedPtr_Members(void        *object,
                                       void        *factory,
                                       DeleterFunc  deleter)
: d_obj_p(object)
, d_deleter(object, factory, deleter)
{
    BSLS_ASSERT_SAFE(0 != deleter || 0 == object);
}

inline
ManagedPtr_Members::ManagedPtr_Members(void        *object,
                                       void        *factory,
                                       DeleterFunc  deleter,
                                       void        *alias)
: d_obj_p(alias)
, d_deleter(object, factory, deleter)
{
    BSLS_ASSERT_SAFE(0 != deleter || 0 == object);
}


// MANIPULATORS
inline
void ManagedPtr_Members::setAliasPtr(void *ptr)
{
    BSLS_ASSERT_SAFE(!ptr == !d_obj_p); // both are null, or neither is null

    d_obj_p = ptr;
}

inline
void ManagedPtr_Members::runDeleter() const
{
    if (d_obj_p) {
        d_deleter.deleteManagedObject();
    }
}

inline
void *ManagedPtr_Members::pointer() const
{
    return d_obj_p;
}

inline
const ManagedPtrDeleter&amp; ManagedPtr_Members::deleter() const
{
    BSLS_ASSERT_SAFE(d_obj_p);

    return d_deleter;
}

}  // close package namespace

// TYPE TRAITS
namespace bslmf {

template &lt;&gt;
struct IsBitwiseMoveable&lt;bslma::ManagedPtr_Members&gt; : bsl::true_type {};

}  // close package namespace
}  // close enterprise namespace

#endif


// ----------------------------------------------------------------------------
// Copyright (C) 2013 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
