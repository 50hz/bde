<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmf_isempty.h                  -*-C++-*-
#ifndef INCLUDED_BSLMF_ISEMPTY
#define INCLUDED_BSLMF_ISEMPTY

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a compile-time check for detecting an empty class type.
//
//@CLASSES: bsl::is_empty: standard meta-function for detecting empty classes
//
//@SEE_ALSO: bslmf_isclass.h
//
//@DESCRIPTION: This component defines a metafunction, &#39;bsl::is_empty&#39;, which
// may be used to determine whether a type is a &#39;class&#39; or &#39;struct&#39; with no
// non-static data members other than bit-fields of length 0, no virtual
// member functions, no virtual base classes, and no base class &#39;B&#39; for which
// &#39;is_empty&lt;B&gt;::value&#39; is false. This metafunction conforms to the definition
// of the C++11 standard &#39;is_empty metafunction in section [meta.unary.prop].
//
// An empty class type type is *usually* stateless and, can be &quot;stored&quot; in a
// zero-length memory region. (Hypothetically, an empty object can hold state
// by means a global address-to-state map, but such a design is rare and is
// discouraged.) When a class inherits from an empty type, the compiler is
// expected to optimize away the storage requirements of the empty base
// class.  This optimization is known as the &quot;Empty Base Optimization&quot; or
// &quot;EBO&quot;.
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Compute Storage Requirements for a Type
/// - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we wish to create a generic function which will allocate a record
// comprising a value of specified &#39;TYPE&#39; and a description in the form of a
// null-terminated character string.  First, we declare the function
// prototype:
//..
//  template &lt;class TYPE&gt;
//  void *makeRecord(const TYPE&amp; value, const char* description);
//..
// Next, we implement the function so that the copy of &#39;value&#39; takes up no
// space if &#39;TYPE&#39; is an empty class.  We manage this by computing a zero
// storage requirement if &#39;is_empty&lt;TYPE&gt;::value&#39; is true:
//..
//  #include &lt;cstring&gt;
//  #include &lt;new&gt;
//
//  template &lt;class TYPE&gt;
//  void *makeRecord(const TYPE&amp; value, const char* description)
//  {
//      // &#39;ValueSize&#39; is computed at compile time.
//      static const std::size_t ValueSize = bsl::is_empty&lt;TYPE&gt;::value ?
//          0 : sizeof(TYPE);
//
//      // Allocate memory for value and description
//      const std::size_t MemSize = ValueSize + std::strlen(description) + 1;
//      void *mem = ::operator new(MemSize);
//
//      // Construct copy of value at front of allocated memory
//      ::new(mem) TYPE(value);
//
//      // Copy description into space following value.
//      std::strcpy(static_cast&lt;char*&gt;(mem) + ValueSize, description);
//
//      return mem;
//  }
//..
// Finally, we use &#39;makeRecord&#39; with both an empty and non-empty value type:
//..
//  struct EmptyMarker { };
//
//  int main()
//  {
//      void *record1 = makeRecord(9999, &quot;four nines&quot;);
//      // Value takes &#39;sizeof(int)&#39; bytes at front of record.
//      assert(9999 == *static_cast&lt;int*&gt;(record1));
//      assert(0 == std::strcmp(static_cast&lt;char*&gt;(record1) + sizeof(int),
//                              &quot;four nines&quot;));
//
//      void *record2 = makeRecord(EmptyMarker(), &quot;Empty&quot;);
//      // Value takes no space at front of record.
//      assert(0 == std::strcmp(static_cast&lt;char*&gt;(record2), &quot;Empty&quot;));
//
//      ::operator delete(record1);
//      ::operator delete(record2);
//
//      return 0;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISCLASS
#include &lt;bslmf_isclass.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECV
#include &lt;bslmf_removecv.h&gt;
#endif

namespace bsl {

                        // ===========================
                        // class template Is_Empty_Imp
                        // ===========================

template &lt;class TYPE, bool IS_CLASS = bsl::is_class&lt;TYPE&gt;::value&gt;
struct Is_Empty_Imp {
    // Private class: do not use outside of &#39;bslmf_isempty&#39; component.
    // Implementation of &#39;bsl::is_empty&#39;.

    // VALUE is false for non-class types.
    static const bool VALUE = false;
};

template &lt;class TYPE&gt;
struct Is_Empty_Imp&lt;TYPE, true&gt; {
    // Private class: do not use outside of &#39;bslmf_isempty&#39; component.
    // Implementation of &#39;bsl::is_empty&#39;.

    struct Derived : TYPE
    {
        Derived();                // Declared but not defined
        Derived(const Derived&amp;);  // Declared but not defined
        ~Derived();               // Declared but not defined

        int d_data; // &#39;Derived&#39; is not empty
    };

    // &#39;VALUE&#39; will be true if EBO has optimized away storage for &#39;TYPE&#39;.
    static const bool VALUE = (sizeof(Derived) == sizeof(int));
};

                        // =======================
                        // class template is_empty
                        // =======================

template &lt;class TYPE&gt;
struct is_empty :
        integral_constant&lt;bool,
                          Is_Empty_Imp&lt;typename remove_cv&lt;TYPE&gt;::type&gt;::VALUE&gt;
{
    // Metafunction to determine whether &#39;TYPE&#39; is an empty class type.
    // Inherits from &#39;true_type&#39; if &#39;TYPE&#39; is a &#39;class&#39; or &#39;struct&#39; with no
    // non-static data members other than bit-fields of length 0, no virtual
    // member functions, no virtual base classes, and no base class &#39;B&#39; for
    // which &#39;is_empty&lt;B&gt;::value&#39; is false.
};

}  // close bsl namespace

#endif // ! defined(INCLUDED_BSLMF_ISEMPTY)

// ----------------------------------------------------------------------------
// Copyright (C) 2013 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
