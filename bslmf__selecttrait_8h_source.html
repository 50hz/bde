<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslmf_selecttrait.h                  -*-C++-*-
#ifndef INCLUDED_BSLMF_SELECTTRAIT
#define INCLUDED_BSLMF_SELECTTRAIT

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a meta-function for overload dispatch per trait.
//
//@CLASSES:
//   bslmf::SelectTrait: meta-function
//
//@SEE_ALSO:
//
//@DESCRIPTION:
//
///Usage
///-----
// This section illustrates the intended usage of this component.
//
///Example 1: Dispatch on traits
/// - - - - - - - - - - - - - - 
// We would like to create a function template,
// &#39;ScalarPrimitives::copyConstruct&#39;, that takes an original object and an
// allocator constructs a copy of &#39;original&#39; using the most efficient valid
// mechanism.  The function should take into account that the original type
// might be bitwise copyable, or have an allocator that can be different in
// the copy than in the original object, or that the original might be a pair
// type, where the correct method of copying &#39;first&#39; and &#39;second&#39; is
// (recursively) goverened by the same concerns.
//
// The old (legacy) &#39;bsls::HasTrait&#39; mechanism has a clumsy mechanism for
// dispatching on multple traits at once.  For example, the
// &#39;bslalg::scalarprimitives::copyConstruct&#39;, function uses four different
// implementations, depending on the traits of the object being copied.  The
// existing code looks like this:
//..
//  template &lt;typename TARGET_TYPE&gt;
//  inline
//  void
//  ScalarPrimitives::copyConstruct(TARGET_TYPE        *address,
//                                  const TARGET_TYPE&amp;  original,
//                                  bslma::Allocator   *allocator)
//  {
//      BSLS_assert_SAFE(address);
//
//      enum {
//          VALUE = HasTrait&lt;TARGET_TYPE,
//                                  TypeTraitUsesBslmaAllocator
//                                 &gt;::VALUE ? Imp::USES_BSLMA_ALLOCATOR_TRAITS
//                : HasTrait&lt;TARGET_TYPE,
//                                  TypeTraitBitwiseCopyable
//                                 &gt;::VALUE ? Imp::BITWISE_COPYABLE_TRAITS
//                : HasTrait&lt;TARGET_TYPE,
//                                  TypeTraitPair
//                                 &gt;::VALUE ? Imp::PAIR_TRAITS
//                : Imp::NIL_TRAITS
//      };
//      Imp::copyConstruct(address, original, allocator,
//                         (bslmf::MetaInt&lt;VALUE&gt;*)0);
//  }
//..
// We would like to replace the cumbersome chain of &#39;?:&#39; operations with a
// clean mechanism for producing one of four different types based on the
// first matching trait.
//
// First, we create three traits metafunctions to replace the three legacy
// traits used above:
//..
//  template &lt;class TYPE&gt; struct UsesBslmaAllocator : bsl::false_type { };
//  template &lt;class TYPE&gt; struct IsBitwiseCopyable : bsl::false_type { };
//  template &lt;class TYPE&gt; struct IsPair : bsl::false_type { };
//..
// Note that these definitions are simplified to avoid excess dependencies; A
// proper traits definition would inherit from &#39;bslmf::DetectNestedTrait&#39;
// instead of from &#39;bsl::false_type&#39;.
//
// Next, we forward-declare &#39;bslma::Allocator&#39; and
// &#39;bslalg::scalarprimitives::copyConstruct&#39;:
//..
//  namespace bslma { class Allocator; }
//
//  namespace bslalg {
//  struct ScalarPrimitives {
//      template &lt;typename TARGET_TYPE&gt;
//      static void copyConstruct(TARGET_TYPE        *address,
//                                const TARGET_TYPE&amp;  original,
//                                bslma::Allocator   *allocator);
//  };
//..
// Next, we implement four overloads of &#39;Imp::copyConstruct&#39;, each taking a
// different &#39;bsl::integral_constant&#39; specialization.  For testing purposes, in
// addition to copying the data member, each overload also increments a
// separate counter.  These implemenations are slightly simplified for
// readability:
//..
//  struct Imp {
//
//      enum {
//          // These constants are used in the overloads below, when the last
//          // argument is of type &#39;bslmf::MetaInt&lt;N&gt; *&#39;, indicating that
//          // &#39;TARGET_TYPE&#39; has the traits for which the enumerator equal to
//          // &#39;N&#39; is named.
//
//          USES_BSLMA_ALLOCATOR_TRAITS     = 5,
//          PAIR_TRAITS                     = 4,
//          BITWISE_COPYABLE_TRAITS         = 2,
//          NIL_TRAITS                      = 0
//      };
//
//      static int d_counters[USES_BSLMA_ALLOCATOR_TRAITS + 1];
//
//      static void clearCounters()
//          { std::memset(d_counters, 0, sizeof(d_counters)); }
//
//      template &lt;typename TARGET_TYPE&gt;
//      static void
//      copyConstruct(TARGET_TYPE                                 *address,
//                    const TARGET_TYPE&amp;                           original,
//                    bslma::Allocator                            *allocator,
//                    bsl::integral_constant&lt;int, USES_BSLMA_ALLOCATOR_TRAITS&gt;)
//      {
//          new (address) TARGET_TYPE(original, allocator);
//          ++d_counters[USES_BSLMA_ALLOCATOR_TRAITS];
//      }
//
//      template &lt;typename TARGET_TYPE&gt;
//      static void
//      copyConstruct(TARGET_TYPE                 *address,
//                    const TARGET_TYPE&amp;           original,
//                    bslma::Allocator            *allocator,
//                    bsl::integral_constant&lt;int, PAIR_TRAITS&gt;)
//      {
//          ScalarPrimitives::copyConstruct(&amp;address-&gt;first, original.first,
//                                          allocator);
//          ScalarPrimitives::copyConstruct(&amp;address-&gt;second, original.second,
//                                          allocator);
//          ++d_counters[PAIR_TRAITS];
//      }
//
//      template &lt;typename TARGET_TYPE&gt;
//      static void
//      copyConstruct(TARGET_TYPE                             *address,
//                    const TARGET_TYPE&amp;                       original,
//                    bslma::Allocator                        *,
//                    bsl::integral_constant&lt;int, BITWISE_COPYABLE_TRAITS&gt;)
//      {
//          std::memcpy(address, &amp;original, sizeof(original));
//          ++d_counters[BITWISE_COPYABLE_TRAITS];
//      }
//
//      template &lt;typename TARGET_TYPE&gt;
//      static void
//      copyConstruct(TARGET_TYPE                *address,
//                    const TARGET_TYPE&amp;          original,
//                    bslma::Allocator           *,
//                    bsl::integral_constant&lt;int, NIL_TRAITS&gt;)
//      {
//          new (address) TARGET_TYPE(original);
//          ++d_counters[NIL_TRAITS];
//      }
//  };
//
//  int bslalg::Imp::d_counters[USES_BSLMA_ALLOCATOR_TRAITS + 1] = { 0 };
//..
// Then, we implement &#39;ScalarPrimitives::copyConstruct&#39;:
//..
//  template &lt;typename TARGET_TYPE&gt;
//  inline void
//  ScalarPrimitives::copyConstruct(TARGET_TYPE        *address,
//                                  const TARGET_TYPE&amp;  original,
//                                  bslma::Allocator   *allocator)
//  {
//..
// We use &#39;bslmf::SelectTrait&#39; to declare &#39;Selection&#39; as an instantiation of
// &#39;bsl::integral_constant&#39; corresponding to the first match of the specified
// traits:
//..
//      typedef bslmf::SelectTrait&lt;TARGET_TYPE,
//          UsesBslmaAllocator,        Imp::USES_BSLMA_ALLOCATOR_TRAITS,
//          IsBitwiseCopyable,         Imp::BITWISE_COPYABLE_TRAITS,
//          IsPair,                    Imp::PAIR_TRAITS,
//          bslmf::SelectTraitDefault, Imp::NIL_TRAITS&gt; Selection;
//..
// Now, we use &#39;Selection&#39; to choose (at compiler time), one of the
// &#39;Imp::copyConstruct&#39; overloads defined above:
//..
//      Imp::copyConstruct(address, original, allocator, Selection());
//  }
//  } // Close namespace bslalg
//..
// Finally, we define three classes, associated with each of the three traits
// of interest, a fourth class associated with more than one trait (to show
// that the selection mechanism respects preference) and a fifth class that is
// not associated with any trait.
//
// The first class is associated with the &#39;UsesBslmaAllocator&#39; trait:
//..
//  class TypeWithAllocator {
//      int               d_value;
//      bslma::Allocator *d_alloc;
//  public:
//      TypeWithAllocator(int v = 0, bslma::Allocator *a = 0)
//          : d_value(v), d_alloc(a) { }
//      TypeWithAllocator(const TypeWithAllocator&amp; other,
//                        bslma::Allocator *a = 0)
//          : d_value(other.d_value), d_alloc(a) {  }
//
//      int value() const { return d_value; }
//      bslma::Allocator *allocator() const { return d_alloc; }
//  };
//
//  template &lt;&gt; struct UsesBslmaAllocator&lt;TypeWithAllocator&gt;
//      : bsl::true_type { };
//..
// The second class is associated with the &#39;IsBitwiseCopyiable&#39; trait:
//..
//  class BitwiseCopyableType {
//      int d_value;
//  public:
//      BitwiseCopyableType(int v = 0) : d_value(v) { }
//      int value() const { return d_value; }
//  };
//
//  template &lt;&gt; struct IsBitwiseCopyable&lt;BitwiseCopyableType&gt;
//      : bsl::true_type { };
//..
// The third class is associated with the &#39;IsPair&#39; trait:
//..
//  struct PairType {
//      TypeWithAllocator   first;
//      BitwiseCopyableType second;
//
//      PairType(int a, int b) : first(a), second(b) { }
//  };
//
//  template &lt;&gt; struct IsPair&lt;PairType&gt; : bsl::true_type { };
//..
// The fourth class is associated with both the the &#39;IsPair&#39; and
// &#39;IsBitwiseCopyiable&#39; traits:
//..
//  struct BitwiseCopyablePairType {
//      BitwiseCopyableType first;
//      BitwiseCopyableType second;
//
//      BitwiseCopyablePairType(int a, int b) : first(a), second(b) { }
//  };
//
//  template &lt;&gt; struct IsPair&lt;BitwiseCopyablePairType&gt; : bsl::true_type { };
//  template &lt;&gt; struct IsBitwiseCopyable&lt;BitwiseCopyablePairType&gt;
//      : bsl::true_type { };
//..
// The fifth class is not associated with any explicit traits:
//..
//  class TypeWithNoTraits {
//      int d_value;
//  public:
//      TypeWithNoTraits(int v = 0) : d_value(v) { }
//      int value() const { return d_value; }
//  };
//
//..
// We use these classes to instantiate &#39;ScalarPrimitives::copyConstruct&#39; and
// verify that the most efficient copy operation that is valid for each type
// is applied:
//..
//  int main()
//  {
//      using bslalg::Imp;
//
//      // This buffer is properly aligned and big enough to hold any of the
//      // test types.
//      void *buffer[4];
//      char dummy[2];  // Dummy addresses
//
//      bslma::Allocator *a1 = (bslma::Allocator*) &amp;dummy[0];
//      bslma::Allocator *a2 = (bslma::Allocator*) &amp;dummy[1];
//..
// When we call &#39;ScalarPrimitives::copyConstruct&#39; for an object of
// &#39;TypeWithAllocator&#39;, we expect that the copy will have the same value but a
// different allocator than the original and that the
// &#39;USES_BSLMA_ALLOCATOR_TRAITS&#39; copy implementation will be called once:
//..
//      Imp::clearCounters();
//      TypeWithAllocator  twa(1, a1);
//      TypeWithAllocator *twaptr = (TypeWithAllocator*) buffer;
//      bslalg::ScalarPrimitives::copyConstruct(twaptr, twa, a2);
//      assert(1 == Imp::d_counters[Imp::USES_BSLMA_ALLOCATOR_TRAITS]);
//      assert(1 == twaptr-&gt;value());
//      assert(a2 == twaptr-&gt;allocator());
//      twaptr-&gt;~TypeWithAllocator();
//..
// When we call &#39;ScalarPrimitives::copyConstruct&#39; for an object of
// &#39;BitwiseCopyableType&#39;, we expect that the &#39;BITWISE_COPYABLE_TRAITS&#39; copy
// implementation will be called once:
//..
//      Imp::clearCounters();
//      BitwiseCopyableType  bct(2);
//      BitwiseCopyableType *bctptr = (BitwiseCopyableType*) buffer;
//      bslalg::ScalarPrimitives::copyConstruct(bctptr, bct, a2);
//      assert(1 == Imp::d_counters[Imp::BITWISE_COPYABLE_TRAITS]);
//      assert(2 == bctptr-&gt;value());
//      bctptr-&gt;~BitwiseCopyableType();
//..
// When we call &#39;ScalarPrimitives::copyConstruct&#39; for an object of
// &#39;PairType&#39;, we expect that the &#39;PAIR_TRAITS&#39; copy implementation will be
// called once for the pair as whole and that the
// &#39;USES_BSLMA_ALLOCATOR_TRAITS&#39; and &#39;BITWISE_COPYABLE_TRAITS&#39; implementations
// will be called for the &#39;first&#39; and &#39;second&#39; members, respectively:
//..
//      Imp::clearCounters();
//      PairType  pt(3, 4);
//      PairType *ptptr = (PairType*) buffer;
//      bslalg::ScalarPrimitives::copyConstruct(ptptr, pt, a2);
//      assert(1 == Imp::d_counters[Imp::PAIR_TRAITS]);
//      assert(1 == Imp::d_counters[Imp::USES_BSLMA_ALLOCATOR_TRAITS]);
//      assert(1 == Imp::d_counters[Imp::BITWISE_COPYABLE_TRAITS]);
//      assert(3 == ptptr-&gt;first.value());
//      assert(a2 == ptptr-&gt;first.allocator());
//      assert(4 == ptptr-&gt;second.value());
//      ptptr-&gt;~PairType();
//..
// When we call &#39;ScalarPrimitives::copyConstruct&#39; for an object of
// &#39;BitwiseCopyablePairType&#39;, the &#39;IsBitwiseCopyable&#39; trait takes precedence
// over the &#39;IsPair&#39; trait (because it appears first in the list of traits
// used to instantiate &#39;SelectTrait&#39;).  Therefore, we expect to see the
// &#39;BITWISE_COPYABLE_TRAITS&#39; copy implementation called once for the whole
// pair and the &#39;PAIR_TRAITS&#39; copy implementation not called at all:
//..
//      Imp::clearCounters();
//      BitwiseCopyablePairType  bcpt(5, 6);
//      BitwiseCopyablePairType *bcptbcptr = (BitwiseCopyablePairType*) buffer;
//      bslalg::ScalarPrimitives::copyConstruct(bcptbcptr, bcpt, a2);
//      // Prefer IsBitwiseCopyable over IsPair trait
//      assert(1 == Imp::d_counters[Imp::BITWISE_COPYABLE_TRAITS]);
//      assert(0 == Imp::d_counters[Imp::PAIR_TRAITS]);
//      assert(5 == bcptbcptr-&gt;first.value());
//      assert(6 == bcptbcptr-&gt;second.value());
//      bcptbcptr-&gt;~BitwiseCopyablePairType();
//..
// When we call &#39;ScalarPrimitives::copyConstruct&#39; for an object of
// &#39;TypeWithNoTraits&#39;, we expect none of the specialized copy implementations
// to be called, thus defaulting to the &#39;NIL_TRAITS&#39; copy implementation:
//..
//      Imp::clearCounters();
//      TypeWithNoTraits  twnt(7);
//      TypeWithNoTraits *twntptr = (TypeWithNoTraits*) buffer;
//      bslalg::ScalarPrimitives::copyConstruct(twntptr, twnt, a2);
//      assert(1 == Imp::d_counters[Imp::NIL_TRAITS]);
//      assert(7 == twntptr-&gt;value());
//      twntptr-&gt;~TypeWithNoTraits();
//
//      return 0;
//  }
//..
// Note that using &#39;SelectTraits&#39; for dispatching using overloading imposes
// little or no overhead, since the compiler typically generates no code for
// the constructor or copy constructor of the &#39;bsl::integral_constant&#39; argument
// to the overloaded functions.  When inlining is in effect, the result is very
// efficient.

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_SWITCH
#include &lt;bslmf_switch.h&gt;
#endif

namespace BloombergLP {

namespace bslmf {

                        // ========================
                        // struct SelectTrait_False
                        // ========================

template &lt;class TYPE&gt;
struct SelectTrait_False : bsl::false_type
{
    // Metafunction that always returns false.
};

                        // ======================
                        // struct SelectTrait_Imp
                        // ======================

template &lt;class TRAIT_EVAL1, class TRAIT_EVAL2, class TRAIT_EVAL3,
          class TRAIT_EVAL4, class TRAIT_EVAL5, class TRAIT_EVAL6,
          class TRAIT_EVAL7, class TRAIT_EVAL8, class TRAIT_EVAL9&gt;
struct SelectTrait_Imp
{
    enum { ORDINAL = (TRAIT_EVAL1::value ? 1 :
                      TRAIT_EVAL2::value ? 2 :
                      TRAIT_EVAL3::value ? 3 :
                      TRAIT_EVAL4::value ? 4 :
                      TRAIT_EVAL5::value ? 5 :
                      TRAIT_EVAL6::value ? 6 :
                      TRAIT_EVAL7::value ? 7 :
                      TRAIT_EVAL8::value ? 8 :
                      TRAIT_EVAL9::value ? 9 : 0) };

    typedef typename Switch&lt;ORDINAL, bsl::false_type,
                            TRAIT_EVAL1, TRAIT_EVAL2, TRAIT_EVAL3, TRAIT_EVAL4,
                            TRAIT_EVAL5, TRAIT_EVAL6, TRAIT_EVAL7, TRAIT_EVAL8,
                            TRAIT_EVAL9&gt;::Type Type;

};

                        // ==================
                        // struct SelectTrait
                        // ==================

template &lt;class TYPE, 
          template &lt;class T&gt; class TRAIT1,
          template &lt;class T&gt; class TRAIT2 = SelectTrait_False,
          template &lt;class T&gt; class TRAIT3 = SelectTrait_False,
          template &lt;class T&gt; class TRAIT4 = SelectTrait_False,
          template &lt;class T&gt; class TRAIT5 = SelectTrait_False,
          template &lt;class T&gt; class TRAIT6 = SelectTrait_False,
          template &lt;class T&gt; class TRAIT7 = SelectTrait_False,
          template &lt;class T&gt; class TRAIT8 = SelectTrait_False,
          template &lt;class T&gt; class TRAIT9 = SelectTrait_False&gt;
struct SelectTrait : SelectTrait_Imp&lt;TRAIT1&lt;TYPE&gt;, TRAIT2&lt;TYPE&gt;, TRAIT3&lt;TYPE&gt;,
                                     TRAIT4&lt;TYPE&gt;, TRAIT5&lt;TYPE&gt;, TRAIT6&lt;TYPE&gt;,
                                     TRAIT7&lt;TYPE&gt;, TRAIT8&lt;TYPE&gt;, TRAIT9&lt;TYPE&gt;
                                    &gt;::Type
{
private:
    typedef SelectTrait_Imp&lt;TRAIT1&lt;TYPE&gt;, TRAIT2&lt;TYPE&gt;, TRAIT3&lt;TYPE&gt;,
                            TRAIT4&lt;TYPE&gt;, TRAIT5&lt;TYPE&gt;, TRAIT6&lt;TYPE&gt;,
                            TRAIT7&lt;TYPE&gt;, TRAIT8&lt;TYPE&gt;, TRAIT9&lt;TYPE&gt; &gt; Imp;

public:
    typedef typename Imp::Type Type;

    static const int ORDINAL = Imp::ORDINAL;

    // Class description
    typedef bsl::integral_constant&lt;int, ORDINAL&gt; OrdinalType;
};

}  // close package namespace

}  // close enterprise namespace

#endif // ! defined(INCLUDED_BSLMF_SELECTTRAIT)

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
