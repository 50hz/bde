<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bsls_alignedbuffer.h                                               -*-C++-*-
#ifndef INCLUDED_BSLS_ALIGNEDBUFFER
#define INCLUDED_BSLS_ALIGNEDBUFFER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide raw buffers with user-specified size and alignment.
//
//@CLASSES:
//  bsls::AlignedBuffer: Uninitialized buffer of specified size and alignment
//
//@SEE_ALSO: bsls_objectbuffer, bsls_alignmenttotype
//
//@DESCRIPTION: This component provides a templated buffer type with a
// user-specified compile-time size and user-specified alignment.  The user
// instantiates &#39;bsls::AlignedBuffer&#39; with specific size and alignment
// requirements, and then uses that memory as needed.  If an alignment is not
// specified at template instantiation, then the buffer object is maximally
// aligned.
//
// Typically, &#39;bsls::AlignedBuffer&#39; is used in situations where it is desirable
// to allocate a block of properly-aligned raw memory from somewhere other than
// the heap, e.g., on the stack or within an aggregate object, including within
// a union.  It is a convenient way to create a small heap from which one or
// more objects are allocated at run-time.
//
///Single-object buffers
///---------------------
// Although, for a given type &#39;T&#39;,
// &#39;bsls::AlignedBuffer&lt;sizeof(T), bsls::AlignmentFromType&lt;T&gt;::VALUE&gt;&#39; will
// produce a buffer properly sized and aligned to hold a &#39;T&#39; object, it is
// simpler and clearer to use &#39;bsls::ObjectBuffer&lt;T&gt;&#39; for this purpose.  See
// the &#39;bsls_objectbuffer&#39; component for more information.
//
///Stack Alignment
///---------------
// On platforms with 32-bit words, there is usually no efficiency gain by using
// more than 4-byte alignment.  Yet some compilers use 8-byte alignment for
// &#39;long long&#39; or &#39;double&#39;, presumably so that the code will run faster on a
// future 64-bit CPU.  The program loader, however, has no reason to presume
// more than 4-byte alignment when allocating the program stack.  This can
// result in stack objects appearing to be misaligned relative to the
// alignments computed by this component.  This is not a bug in either this
// component nor in the compiler, but it is somewhat surprising.  We have seen
// this behavior on the MS VC++ 7 platform.  See also the &quot;Surprises and
// Anomalies&quot; section in &#39;bsls_alignmentfromtype.h&#39;.
//
///Usage
///-----
// The &#39;allocateFromBuffer&#39; function below uses an aligned buffer as a small
// heap from which objects can be allocated.  We choose &#39;int&#39; alignment (4-byte
// alignment) for our buffer because the objects we are allocating are composed
// of &#39;char&#39;, &#39;short&#39;, and &#39;int&#39; values only.  If no alignment were specified,
// the buffer would be maximally aligned, which could be wasteful on some
// platforms.
//..
//  const int MY_ALIGNMENT = bsls::AlignmentFromType&lt;int&gt;::VALUE;
//  bsls::AlignedBuffer&lt;1000, MY_ALIGNMENT&gt; my_AllocBuffer;
//  const char* my_AllocEnd = my_AllocBuffer.buffer() + 1000;
//  char *my_AllocPtr = my_AllocBuffer.buffer();
//      // Invariant: my_AllocPtr is always aligned on a multiple of 4 bytes
//
//  static void *allocateFromBuffer(int size)
//  {
//      if (size &gt; my_AllocEnd - my_AllocPtr)
//          return 0;       // Out of buffer space
//
//      void *result = my_AllocPtr;
//      my_AllocPtr += size;
//      if (size % MY_ALIGNMENT) {
//          // re-establish invariant by re-aligning my_AllocPtr
//          my_AllocPtr += MY_ALIGNMENT - size % MY_ALIGNMENT;
//      }
//
//      assert(0 == size_t(my_AllocPtr) % MY_ALIGNMENT);     // Test invariant
//
//      return result;
//  }
//..
// Below, we use our allocation function to allocate arrays of &#39;char&#39;, &#39;short&#39;,
// and user-defined &#39;Object&#39; types from the static buffer.  Note that our
// &#39;Object&#39; structure is composed of members that have alignment requirements
// less than or equal to &#39;int&#39;s alignment requirements.
//..
//  struct Object {
//      char  d_c;
//      short d_s;
//      int   d_i;
//  };
//
//  int main()
//  {
//      // Allocate three &#39;char&#39;s from the buffer.
//      char *charPtr   = (char *)   allocateFromBuffer(3 * sizeof(char));
//      assert(0 == size_t(charPtr) % MY_ALIGNMENT);
//
//      // Allocate three &#39;short&#39;s from the buffer.
//      short *shortPtr = (short *)  allocateFromBuffer(3 * sizeof(short));
//      assert(0 == size_t(shortPtr) % MY_ALIGNMENT);
//
//      // Allocate three &#39;Object&#39;s from the buffer
//      Object *objPtr = (Object *)  allocateFromBuffer(3 * sizeof(Object));
//      assert(0 == size_t(objPtr) % MY_ALIGNMENT);
//
//      if (!charPtr || !shortPtr || !objPtr) {
//          fprintf(stderr, &quot;Global buffer is not large enough.\n&quot;);
//          return -1;
//      }
//
//      // ...
//
//      return 0;
//  }
//..

#ifndef INCLUDED_BSLS_ALIGNMENTTOTYPE
#include &lt;bsls_alignmenttotype.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTUTIL
#include &lt;bsls_alignmentutil.h&gt;
#endif

namespace BloombergLP {

namespace bsls {

                        // ===================
                        // union AlignedBuffer
                        // ===================

template &lt;int SIZE, int ALIGNMENT = AlignmentUtil::BSLS_MAX_ALIGNMENT&gt;
union AlignedBuffer {
    // An instance of this union is a block of raw memory of specified &#39;SIZE&#39;
    // and &#39;ALIGNMENT&#39;.  A &#39;AlignedBuffer&#39; object does not manage the
    // construction or destruction of any other objects.  &#39;SIZE&#39; is rounded up
    // to the nearest multiple of &#39;ALIGNMENT&#39;.  An instantiation of this union
    // template will not compile unless &#39;ALIGNMENT&#39; is a power of two not
    // larger than &#39;AlignmentUtil::BSLS_MAX_ALIGNMENT&#39;.

  public:
    typedef typename AlignmentToType&lt;ALIGNMENT&gt;::Type AlignmentType;
        // Define an alias for alignment type to work around a Sun CC 5.5 bug
        // that gives a warning if the type is directly accessed in the union.
        // Note that to allow the union to access this typedef it must be
        // declared with public access.

  private:
    // Buffer of &#39;SIZE&#39; bytes, correctly aligned at &#39;ALIGNMENT&#39; The size of
    // this union will always be an even multiple of &#39;ALIGNMENT&#39;.
    char          d_buffer[SIZE];
    AlignmentType d_align;

  public:
    // CREATORS Note that We deliberately omit defining constructors and
    // destructors in order to keep this union &quot;POD-like&quot;.  In particular, a
    // &#39;AlignedBuffer&#39; may be used as a member in another &#39;union&#39;.  Copying a
    // &#39;AlignedBuffer&#39; assignment or copy construction will result in a
    // bit-wise copy and will not invoke any user-defined assignment operators
    // or copy constructors.

    // MANIPULATORS
    char *buffer();
        // Return a the address of the first byte of this object, cast to a
        // &#39;char*&#39; pointer.

    // ACCESSORS
    const char *buffer() const;
        // Return a the address of the first byte of this object, cast to a
        // &#39;const char*&#39; pointer.
};

// ===========================================================================
//                      INLINE FUNCTION DEFINITIONS
// ===========================================================================

// MANIPULATORS
template &lt;int SIZE, int ALIGNMENT&gt;
inline
char *AlignedBuffer&lt;SIZE, ALIGNMENT&gt;::buffer()
{
    return d_buffer;
}

// ACCESSORS
template &lt;int SIZE, int ALIGNMENT&gt;
inline
const char *AlignedBuffer&lt;SIZE, ALIGNMENT&gt;::buffer() const
{
    return d_buffer;
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
