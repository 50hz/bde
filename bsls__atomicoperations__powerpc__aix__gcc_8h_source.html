<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.22.1.2 OSS</title>
<html>
<pre>
// bsls_atomicoperations_powerpc_aix_gcc.h                            -*-C++-*-
#ifndef INCLUDED_BSLS_ATOMICOPERATIONS_POWERPC_AIX_GCC
#define INCLUDED_BSLS_ATOMICOPERATIONS_POWERPC_AIX_GCC

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide implementations of atomic operations for PowerPC/AIX/GCC.
//
//@CLASSES:
//  bsls::AtomicOperations_POWERPC_AIX_GCC: atomics for PPC/AIX/GCC.
//
//@DESCRIPTION: This component provides classes necessary to implement atomics
// on the AIX PowerPC platform in 32bit/64bit mode with the GCC compiler.  The
// classes are for private use only.  See &#39;bsls_atomicoperations&#39; and
// &#39;bsls_atomic&#39; for the public interface to atomics.
//
// NOTE: this implementation is incorrect and only minimally complete.  It is
// provided for the sole purpose of passing cscheckin validation tests
// performed on AIX with the GCC compiler.

#ifndef INCLUDED_BSLS_ATOMICOPERATIONS_DEFAULT
#include &lt;bsls_atomicoperations_default.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#if defined(BSLS_PLATFORM_CPU_POWERPC) &amp;&amp; defined(BSLS_PLATFORM_CMP_GNU)

namespace BloombergLP {

namespace bsls {

struct AtomicOperations_POWERPC_AIX_GCC;
typedef AtomicOperations_POWERPC_AIX_GCC  AtomicOperations_Imp;

         // ==========================================================
         // struct Atomic_TypeTraits&lt;AtomicOperations_POWERPC_AIX_GCC&gt;
         // ==========================================================

template &lt;&gt;
struct Atomic_TypeTraits&lt;AtomicOperations_POWERPC_AIX_GCC&gt;
{
    struct Int
    {
        volatile int d_value __attribute__((__aligned__(sizeof(int))));
    };

    struct Int64
    {
        volatile Types::Int64 d_value
                       __attribute__((__aligned__(sizeof(Types::Int64))));
    };

    struct Pointer
    {
        void * volatile d_value __attribute__((__aligned__(sizeof(void *))));
    };
};

                   // =======================================
                   // struct AtomicOperations_POWERPC_AIX_GCC
                   // =======================================

struct AtomicOperations_POWERPC_AIX_GCC
    : AtomicOperations_Default64&lt;AtomicOperations_POWERPC_AIX_GCC&gt;
{
    typedef Atomic_TypeTraits&lt;AtomicOperations_POWERPC_AIX_GCC&gt; AtomicTypes;

        // *** atomic functions for int ***

    static int getInt(const AtomicTypes::Int *atomicInt)
    {
        return atomicInt-&gt;d_value;
    }

    static void setInt(AtomicTypes::Int *atomicInt, int value)
    {
        atomicInt-&gt;d_value = value;
    }

    static int swapInt(AtomicTypes::Int *atomicInt, int swapValue)
    {
        int prev = atomicInt-&gt;d_value;
        atomicInt-&gt;d_value = swapValue;
        return prev;
    }

    static int testAndSwapInt(AtomicTypes::Int *atomicInt,
                              int compareValue,
                              int swapValue)
    {
        int prev = atomicInt-&gt;d_value;
        if (atomicInt-&gt;d_value == compareValue) {
            atomicInt-&gt;d_value = swapValue;
        }

        return prev;
    }

    static int addIntNv(AtomicTypes::Int *atomicInt, int value)
    {
        return atomicInt-&gt;d_value += value;
    }

        // *** atomic functions for Int64 ***

    static Types::Int64 getInt64(const AtomicTypes::Int64 *atomicInt)
    {
        return atomicInt-&gt;d_value;
    }

    static void setInt64(AtomicTypes::Int64 *atomicInt, Types::Int64 value)
    {
        atomicInt-&gt;d_value = value;
    }

    static Types::Int64 swapInt64(AtomicTypes::Int64  *atomicInt,
                                  Types::Int64 swapValue)
    {
        Types::Int64 prev = atomicInt-&gt;d_value;
        atomicInt-&gt;d_value = swapValue;
        return prev;
    }

    static Types::Int64 testAndSwapInt64(AtomicTypes::Int64 *atomicInt,
                                         Types::Int64 compareValue,
                                         Types::Int64 swapValue)
    {
        Types::Int64 prev = atomicInt-&gt;d_value;
        if (atomicInt-&gt;d_value == compareValue) {
            atomicInt-&gt;d_value = swapValue;
        }

        return prev;
    }

    static Types::Int64 addInt64Nv(AtomicTypes::Int64 *atomicInt,
                                   Types::Int64 value)
    {
        return atomicInt-&gt;d_value += value;
    }
};

}  // close package namespace

}  // close enterprise namespace

#endif  // BSLS_PLATFORM_CPU_POWERPC &amp;&amp; BSLS_PLATFORM_CMP_GNU

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
