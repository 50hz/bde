<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bsls_blockgrowth.h                                                 -*-C++-*-
#ifndef INCLUDED_BSLS_BLOCKGROWTH
#define INCLUDED_BSLS_BLOCKGROWTH

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a namespace for memory block growth strategies.
//
//@CLASSES:
//  bsls::BlockGrowth: namespace for enumerated growth strategy values
//
//@SEE_ALSO: bsls_alignment
//
//@DESCRIPTION: This component provides a namespace for enumerating memory
// block growth strategies, and provides a function that converts each of these
// enumerators to its corresponding string representation.
//
///Block Growth Strategy
///---------------------
// This component supports two memory block growth strategies:
//
//: GEOMETRIC GROWTH: A container, pool or allocator that employs this
//:   strategy, as indicated by the enumerator &#39;BSLS_GEOMETRIC&#39;, grows its
//:   buffer geometrically.
//:
//: CONSTANT GROWTH: A container, pool or allocator that employs this strategy,
//:   as indicated by the enumerator &#39;BSLS_CONSTANT&#39;, locks the buffer growth.
//:   The new buffer is always the same size as the current buffer.
//
///Usage
///-----
// Memory block growth strategies are often used in memory managers and
// containers to control memory usage.  First of all, suppose we have a
// &#39;my_BlockList&#39; class that manages a link list of memory blocks:
//..
//  class my_BlockList {
//      // ...
//  };
//..
// We can then create a memory manager class &#39;my_SequentialPool&#39; that manages a
// pool of memory:
//..
//  class my_SequentialPool {
//      // This class implements a memory pool that dispenses (heterogeneous)
//      // blocks of memory (of varying, user-specified-sizes) from a sequence
//      // of dynamically allocated buffers.
//
//      // DATA
//      char         *d_currentBuffer_p;    // pointer to current buffer
//
//      int           d_currentBufferSize;  // size of current buffer
//
//      bsls::BlockGrowth::Strategy
//                    d_growthStrategy;     // growth strategy
//
//      my_BlockList  d_blockList;          // manager for all allocated memory
//                                          // blocks
//
//      // NOT IMPLEMENTED
//      my_SequentialPool(const my_SequentialPool&amp;);
//      my_SequentialPool&amp; operator=(const my_SequentialPool&amp;);
//
//    private:
//      // PRIVATE MANIPULATORS
//      int calculateNextSize(int size);
//          // Return the next buffer size sufficient to satisfy a memory
//          // allocation request of the specified &#39;size&#39; (in bytes).
//
//    public:
//      // CREATORS
//      my_SequentialPool(bsls::BlockGrowth::Strategy  strategy);
//          // Create a pool with the specified memory block growth &#39;strategy&#39;.
//
//      // ...
//
//      // MANIPULATORS
//      void *allocate(int size);
//          // Return the address of a contiguous block of memory of the
//          // specified &#39;size&#39; (in bytes).  If the pool cannot return the
//          // requested number of bytes, &#39;std::bad_alloc&#39; will be thrown in an
//          // exception-enabled build, or the program will be aborted.  The
//          // behavior is undefined unless &#39;size &gt; 0&#39;.
//  };
//..
// The implementation for the rest of the class is elided as the function
// &#39;calculateNextSize&#39; alone is sufficient to illustrate the use of this
// component:
//..
//  // PRIVATE MANIPULATORS
//  int my_SequentialPool::calculateNextSize(int size)
//  {
//      if (bsls::BlockGrowth::BSLS_CONSTANT == d_growthStrategy) {
//          return d_currentBufferSize;
//      }
//..
// Note that, if the growth strategy in effect is constant growth
// (&#39;BSLS_CONSTANT&#39;), the size of the internal buffers will always be the same.
// If &#39;size&#39; is greater than the buffer size, the implementation of &#39;allocate&#39;
// will return a block having the exact &#39;size&#39; from the internal block list:
//..
//  int nextSize = d_currentBufferSize;
//
//  do {
//      nextSize *= 2;  // growth factor of 2
//  } while (nextSize &lt; size);
//..
// Note that, if the growth strategy in effect is geometric growth
// (&#39;BSLS_GEOMETRIC&#39;), the size of the internal buffer grows geometrically by a
// factor of 2:
//..
//      return nextSize;
//  }
//..

namespace BloombergLP {

namespace bsls {

                        // ==================
                        // struct BlockGrowth
                        // ==================

struct BlockGrowth {
    // This struct provides a namespace for memory block growth strategies for
    // pools, allocators, containers, etc.

    // TYPES
    enum Strategy {
        BSLS_GEOMETRIC,  // Default.  Indicates that memory block sizes grow
                         // geometrically.

        BSLS_CONSTANT    // Indicates that memory block size is locked.
    };

    // CLASS METHODS
    static const char *toAscii(BlockGrowth::Strategy value);
        // Return the string representation of the specified enumerator
        // &#39;value&#39;.  The string representation of &#39;value&#39; matches its
        // corresponding enumerator name with the &#39;BSLS_&#39; prefix elided.
};

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
