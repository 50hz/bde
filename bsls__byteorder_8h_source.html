<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BSL 2.20 OSS</title>
<html>
<pre>
// bsls_byteorder.h                                                   -*-C++-*-
#ifndef INCLUDED_BSLS_BYTEORDER
#define INCLUDED_BSLS_BYTEORDER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide byte-order manipulation macros.
//
//@CLASSES:
//
//@MACROS:
//  BSLS_BYTEORDER_HTONS(x):  Convert 16-bit value from host to network order
//  BSLS_BYTEORDER_HTONL(x):  Convert 32-bit value from host to network order
//  BSLS_BYTEORDER_HTONLL(x): Convert 64-bit value from host to network order
//  BSLS_BYTEORDER_NTOHS(x):  Convert 16-bit value from network to host order
//  BSLS_BYTEORDER_NTOHL(x):  Convert 32-bit value from network to host order
//  BSLS_BYTEORDER_NTOHLL(x): Convert 64-bit value from network to host order
//
//  BSLS_BYTEORDER_HTONS_CONSTANT(x):  static 16-bit network to host order
//  BSLS_BYTEORDER_HTONL_CONSTANT(x):  static 32-bit network to host order
//  BSLS_BYTEORDER_HTONLL_CONSTANT(x): static 64-bit network to host order
//  BSLS_BYTEORDER_NTOHS_CONSTANT(x):  static 16-bit network to host order
//  BSLS_BYTEORDER_NTOHL_CONSTANT(x):  static 32-bit network to host order
//  BSLS_BYTEORDER_NTOHLL_CONSTANT(x): static 64-bit network to host order
//
//  BSLS_BYTEORDER_LE_U16_TO_HOST(x): 16-bit little-endian to host-endian
//  BSLS_BYTEORDER_LE_U32_TO_HOST(x): 32-bit little-endian to host-endian
//  BSLS_BYTEORDER_LE_U64_TO_HOST(x): 64-bit little-endian to host-endian
//  BSLS_BYTEORDER_BE_U16_TO_HOST(x): 16-bit    big-endian to host-endian
//  BSLS_BYTEORDER_BE_U32_TO_HOST(x): 32-bit    big-endian to host-endian
//  BSLS_BYTEORDER_BE_U64_TO_HOST(x): 64-bit    big-endian to host-endian
//
//  BSLS_BYTEORDER_HOST_U16_TO_LE(x): 16-bit host-endian to little-endian
//  BSLS_BYTEORDER_HOST_U32_TO_LE(x): 32-bit host-endian to little-endian
//  BSLS_BYTEORDER_HOST_U64_TO_LE(x): 64-bit host-endian to little-endian
//  BSLS_BYTEORDER_HOST_U16_TO_BE(x): 16-bit host-endian to    big-endian
//  BSLS_BYTEORDER_HOST_U32_TO_BE(x): 32-bit host-endian to    big-endian
//  BSLS_BYTEORDER_HOST_U64_TO_BE(x): 64-bit host-endian to    big-endian
//
//@DESCRIPTION: This component provides a set of byte-order manipulation macros
// that replace the standard &#39;htonl&#39;, &#39;htons&#39;, &#39;ntohl&#39;, and &#39;ntohs&#39; functions,
// and which do not require including any system header files:
//..
//  BSLS_BYTEORDER_HTONS(x)
//  BSLS_BYTEORDER_HTONL(x)
//  BSLS_BYTEORDER_HTONLL(x)
//  BSLS_BYTEORDER_NTOHS(x)
//  BSLS_BYTEORDER_NTOHL(x)
//  BSLS_BYTEORDER_NTOHLL(x)
//..
// The &quot;S&quot;, &quot;L&quot;, and &quot;LL&quot; suffices in the names of the above macros indicate
// their applicability to 16-bit (&#39;short&#39;), 32-bit (&#39;int&#39;, *not* &#39;long&#39;), and
// 64-bit (&#39;long long&#39;) values, respectively.
//
// This set of host-to-network and network-to-host conversion macros are very
// efficient, but sacrifices the ability to perform compile-time
// initialization.  To compensate, another set of functionally equivalent
// &quot;CONSTANT&quot; macros are provided.  These macros can be used for compile-time
// initialization, but are less efficient than non-&quot;CONSTANT&quot; versions:
//..
//  BSLS_BYTEORDER_HTONS_CONSTANT(x)
//  BSLS_BYTEORDER_HTONL_CONSTANT(x)
//  BSLS_BYTEORDER_HTONLL_CONSTANT(x)
//  BSLS_BYTEORDER_NTOHS_CONSTANT(x)
//  BSLS_BYTEORDER_NTOHL_CONSTANT(x)
//  BSLS_BYTEORDER_NTOHLL_CONSTANT(x)
//..
// Another set of macros provides conversion from big-endian or little-endian
// byte order to host-endian order.  The macros take 16-, 32- or 64-bit values
// and perform the indicated byte-order conversion on those values:
//..
//  BSLS_BYTEORDER_LE_U16_TO_HOST(x)
//  BSLS_BYTEORDER_LE_U32_TO_HOST(x)
//  BSLS_BYTEORDER_LE_U64_TO_HOST(x)
//  BSLS_BYTEORDER_BE_U16_TO_HOST(x)
//  BSLS_BYTEORDER_BE_U32_TO_HOST(x)
//  BSLS_BYTEORDER_BE_U64_TO_HOST(x)
//..
// The &quot;LE&quot; and &quot;BE&quot; embedded in the above macro names indicate Little-Endian
// and Big-Endian, respectively.
//
// Finally, a complementary set of macros provides conversion from host-endian
// byte order to big-endian or little-endian order:
//..
//  BSLS_BYTEORDER_HOST_U16_TO_LE(x)
//  BSLS_BYTEORDER_HOST_U32_TO_LE(x)
//  BSLS_BYTEORDER_HOST_U64_TO_LE(x)
//  BSLS_BYTEORDER_HOST_U16_TO_BE(x)
//  BSLS_BYTEORDER_HOST_U32_TO_BE(x)
//  BSLS_BYTEORDER_HOST_U64_TO_BE(x)
//..
///Usage
///-----
// To use these macros, simply pass a 16-, 32-, or 64-bit value to the macros.
// To demonstrate the change in byte order effected by the macros, we first
// write a function to print, in hex, a character buffer of a specified size:
//..
//  void printHex(const char *c, int size)
//      // Print the specified character array &#39;c&#39;, having the specified &#39;size&#39;
//      // (in bytes), to &#39;stdout&#39; in hex.
//  {
//      const char *hex = &quot;0123456789abcdef&quot;;
//      for (int i = 0; i &lt; size; ++i) {
//          std::cout &lt;&lt; hex[(c[i] &gt;&gt; 4) &amp; 0xf]
//                    &lt;&lt; hex[ c[i]       &amp; 0xf];
//      }
//  }
//
//  template &lt;class T&gt;
//  void printHex(T x)
//      // Print the specified object &#39;x&#39; of parameterized type &#39;T&#39; in hex.
//  {
//      printHex((const char*)&amp;x, sizeof x);
//  }
//..
// For example, to use the little-endian/big-endian to host-endian macros:
//..
//  short              x = static_cast&lt;short&gt;(0xabcd);
//  int                y = 0xabcdef12;
//  bsls::Types::Int64 z = 0xabcdef1234567890LL;
//
//  // Note the use of macros within the calls to &#39;printHex&#39;.
//
//  printf(&quot;\nLE to Host(x): &quot;);
//  printHex(BSLS_BYTEORDER_LE_U16_TO_HOST(x));
//
//  printf(&quot;\nLE to Host(y): &quot;);
//  printHex(BSLS_BYTEORDER_LE_U32_TO_HOST(y));
//
//  printf(&quot;\nLE to Host(z): &quot;);
//  printHex(BSLS_BYTEORDER_LE_U64_TO_HOST(z));
//
//  printf(&quot;\nBE to Host(x): &quot;);
//  printHex(BSLS_BYTEORDER_BE_U16_TO_HOST(x));
//
//  printf(&quot;\nBE to Host(y): &quot;);
//  printHex(BSLS_BYTEORDER_BE_U32_TO_HOST(y));
//
//  printf(&quot;\nBE to Host(z): &quot;);
//  printHex(BSLS_BYTEORDER_BE_U64_TO_HOST(z));
//..
// On little-endian machines (e.g., x86, IA64), this will print the following
// to &#39;stdout&#39;:
//..
//  LE to Host(x): abcd
//  LE to Host(y): abcdef12
//  LE to Host(z): abcdef1234567890
//  BE to Host(x): cdab
//  BE to Host(y): 12efcdab
//  BE to Host(z): 9078563412efcdab
//..
// On big-endian machines (e.g., sparc, powerpc), the following will be printed
// instead:
//..
//  LE to Host(x): cdab
//  LE to Host(y): 12efcdab
//  LE to Host(z): 9078563412efcdab
//  BE to Host(x): abcd
//  BE to Host(y): abcdef12
//  BE to Host(z): abcdef1234567890
//..
// The other macros can be used in a similar manner.

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifdef BSLS_PLATFORM_CMP_HP

#ifndef INCLUDED_MACHINE_SYS_BUILTINS
#include &lt;machine/sys/builtins.h&gt;  // &#39;_Asm_xchg&#39;
#define INCLUDED_MACHINE_SYS_BUILTINS
#endif

#ifndef INCLUDED_MACHINE_SYS_INLINE
#include &lt;machine/sys/inline.h&gt;    // &#39;_SZ_H&#39;, &#39;_SZ_W&#39;, &#39;_SZ_D&#39;
#define INCLUDED_MACHINE_SYS_INLINE
#endif

#endif

#ifdef BSLS_PLATFORM_CMP_MSVC

#ifndef INCLUDED_STDLIB
#include &lt;stdlib.h&gt;        // &#39;_byteswap_*&#39;
#define INCLUDED_STDLIB
#endif

#endif

namespace BloombergLP {

namespace bsls {

                     // ======================
                     // struct ByteOrder_Util
                     // ======================

struct ByteOrder_Util {
    // This &#39;struct&#39; provides a namespace for a suite of platform-dependent
    // byte-swapping operations.  Do *not* use this directly; it is meant for
    // *internal* use only.  Use the macros provided for endian conversion
    // instead.

    // CLASS METHODS
    static unsigned short generic_swap_16(unsigned short x);
        // Return the byte-swapped value of the specified 16-bit value &#39;x&#39;.

    static unsigned int generic_swap_32(unsigned int x);
        // Return the byte-swapped value of the specified 32-bit value &#39;x&#39;.

    static Types::Uint64 generic_swap_64(Types::Uint64 x);
        // Return the byte-swapped value of the specified 64-bit value &#39;x&#39;.
};

}  // close package namespace

// ======
// MACROS
// ======

// STANDARD NETWORK AND HOST CONVERSIONS

#if defined(BSLS_PLATFORM_IS_BIG_ENDIAN)

#define BSLS_BYTEORDER_NTOHS(x)  (x)
#define BSLS_BYTEORDER_NTOHL(x)  (x)
#define BSLS_BYTEORDER_NTOHLL(x) (x)

#define BSLS_BYTEORDER_HTONS(x)  (x)
#define BSLS_BYTEORDER_HTONL(x)  (x)
#define BSLS_BYTEORDER_HTONLL(x) (x)

#define BSLS_BYTEORDER_NTOHS_CONSTANT(x)  (x)
#define BSLS_BYTEORDER_NTOHL_CONSTANT(x)  (x)
#define BSLS_BYTEORDER_NTOHLL_CONSTANT(x) (x)

#define BSLS_BYTEORDER_HTONS_CONSTANT(x)  (x)
#define BSLS_BYTEORDER_HTONL_CONSTANT(x)  (x)
#define BSLS_BYTEORDER_HTONLL_CONSTANT(x) (x)

#else  // BSLS_PLATFORM_IS_LITTLE_ENDIAN

#define BSLS_BYTEORDER_NTOHS(x)                                               \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_16(x)

#define BSLS_BYTEORDER_NTOHL(x)                                               \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_32(x)

#define BSLS_BYTEORDER_NTOHLL(x)                                              \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_64(x)

#define BSLS_BYTEORDER_HTONS(x)  BSLS_BYTEORDER_NTOHS(x)

#define BSLS_BYTEORDER_HTONL(x)  BSLS_BYTEORDER_NTOHL(x)

#define BSLS_BYTEORDER_HTONLL(x) BSLS_BYTEORDER_NTOHLL(x)

#define BSLS_BYTEORDER_NTOHS_CONSTANT(x)                                      \
                                    ((((x) &gt;&gt; 8) &amp; 0xFF) | (((x) &amp; 0xFF) &lt;&lt; 8))

#define BSLS_BYTEORDER_NTOHL_CONSTANT(x)                                      \
                    ((((x) &gt;&gt; 24) &amp; 0x000000FF) | (((x) &amp; 0x00FF0000) &gt;&gt;  8)  \
                   | (((x) &amp; 0x0000FF00) &lt;&lt;  8) | (((x) &amp; 0x000000FF) &lt;&lt; 24))

#define BSLS_BYTEORDER_NTOHLL_CONSTANT(x)                                     \
                                        ((((x) &amp; 0x00000000000000FFLL) &lt;&lt; 56) \
                                       | (((x) &amp; 0x000000000000FF00LL) &lt;&lt; 40) \
                                       | (((x) &amp; 0x0000000000FF0000LL) &lt;&lt; 24) \
                                       | (((x) &amp; 0x00000000FF000000LL) &lt;&lt;  8) \
                                       | (((x) &amp; 0x000000FF00000000LL) &gt;&gt;  8) \
                                       | (((x) &amp; 0x0000FF0000000000LL) &gt;&gt; 24) \
                                       | (((x) &amp; 0x00FF000000000000LL) &gt;&gt; 40) \
                                       | (((x) &gt;&gt; 56) &amp; 0x00000000000000FFLL))

#define BSLS_BYTEORDER_HTONS_CONSTANT(x)  BSLS_BYTEORDER_NTOHS_CONSTANT(x)

#define BSLS_BYTEORDER_HTONL_CONSTANT(x)  BSLS_BYTEORDER_NTOHL_CONSTANT(x)

#define BSLS_BYTEORDER_HTONLL_CONSTANT(x) BSLS_BYTEORDER_NTOHLL_CONSTANT(x)

#endif  // BSLS_PLATFORM_IS_BIG_ENDIAN

// ---------------------------------------------------------------------------

// ENDIAN CONVERSION MACROS

#if defined(BSLS_PLATFORM_IS_LITTLE_ENDIAN)

#define BSLS_BYTEORDER_LE_U16_TO_HOST(x) (x)
#define BSLS_BYTEORDER_LE_U32_TO_HOST(x) (x)
#define BSLS_BYTEORDER_LE_U64_TO_HOST(x) (x)

#define BSLS_BYTEORDER_HOST_U16_TO_LE(x) (x)
#define BSLS_BYTEORDER_HOST_U32_TO_LE(x) (x)
#define BSLS_BYTEORDER_HOST_U64_TO_LE(x) (x)

#define BSLS_BYTEORDER_BE_U16_TO_HOST(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_16(x)
#define BSLS_BYTEORDER_BE_U32_TO_HOST(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_32(x)
#define BSLS_BYTEORDER_BE_U64_TO_HOST(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_64(x)

#define BSLS_BYTEORDER_HOST_U16_TO_BE(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_16(x)
#define BSLS_BYTEORDER_HOST_U32_TO_BE(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_32(x)
#define BSLS_BYTEORDER_HOST_U64_TO_BE(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_64(x)

#else  // BSLS_PLATFORM_IS_BIG_ENDIAN

#define BSLS_BYTEORDER_LE_U16_TO_HOST(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_16(x)
#define BSLS_BYTEORDER_LE_U32_TO_HOST(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_32(x)
#define BSLS_BYTEORDER_LE_U64_TO_HOST(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_64(x)

#define BSLS_BYTEORDER_HOST_U16_TO_LE(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_16(x)
#define BSLS_BYTEORDER_HOST_U32_TO_LE(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_32(x)
#define BSLS_BYTEORDER_HOST_U64_TO_LE(x)                                      \
                         BloombergLP::bsls::ByteOrder_Util::generic_swap_64(x)

#define BSLS_BYTEORDER_BE_U16_TO_HOST(x) (x)
#define BSLS_BYTEORDER_BE_U32_TO_HOST(x) (x)
#define BSLS_BYTEORDER_BE_U64_TO_HOST(x) (x)

#define BSLS_BYTEORDER_HOST_U16_TO_BE(x) (x)
#define BSLS_BYTEORDER_HOST_U32_TO_BE(x) (x)
#define BSLS_BYTEORDER_HOST_U64_TO_BE(x) (x)

#endif  // BSLS_PLATFORM_IS_LITTLE_ENDIAN

// ===========================================================================
//                        INLINE FUNCTION DEFINITIONS
// ===========================================================================

// ---- Anything below this line is implementation specific.  Do not use.  ----

// ----------------------------------------------------------------------------
// LINUX
#if (defined(BSLS_PLATFORM_CPU_X86) || defined(BSLS_PLATFORM_CPU_X86_64))   \
  &amp;&amp; defined(BSLS_PLATFORM_CMP_GNU)

namespace bsls {

inline
unsigned short
ByteOrder_Util_x86_swap_16(const unsigned short x)
{
    register unsigned short y;
    __asm__ (&quot;xchg %b0, %h0&quot; : &quot;=Q&quot; (y) : &quot;0&quot; (x));
    return y;
}

inline
unsigned int
ByteOrder_Util_x86_swap_32(const unsigned int x)
{
    register unsigned int y;
    __asm__ (&quot;bswap %0&quot; : &quot;=r&quot; (y) : &quot;0&quot; (x));
    return y;
}

}  // close package namespace

#if BSLS_PLATFORM_CPU_32_BIT

namespace bsls {

inline
Types::Uint64
ByteOrder_Util_x86_swap_64(const Types::Uint64 x)
{
    register unsigned int res, tmp;
    __asm__ (&quot;bswap %0\n\t&quot;
             &quot;bswap %1\n\t&quot;
           : &quot;=r&quot; (res), &quot;=r&quot; (tmp)
           : &quot;0&quot; ((unsigned) x), &quot;1&quot; ((unsigned) (x &gt;&gt; 32)));

    return ((Types::Uint64)res &lt;&lt; 32ULL)
          | (Types::Uint64)tmp;
}

}  // close package namespace

#else  // BSLS_PLATFORM_CPU_64_BIT

namespace bsls {

inline
Types::Uint64
ByteOrder_Util_x86_swap_64(const Types::Uint64 x)
{
    register Types::Uint64 y;
    __asm__ (&quot;bswap %0&quot; : &quot;=r&quot; (y) : &quot;0&quot; (x));
    return y;
}

}  // close package namespace

#endif  // BSLS_PLATFORM_CPU_32_BIT
#endif  // BSLS_PLATFORM_CMP_GNU &amp;&amp; X86

// ----------------------------------------------------------------------------
// HP
#if defined(BSLS_PLATFORM_CPU_IA64) &amp;&amp; defined(BSLS_PLATFORM_CMP_HP)

namespace bsls {

inline
unsigned short
ByteOrder_Util_ia64_swap_16(const unsigned short x)
{
    register Types::Uint64 y;
    y = _Asm_shl(x, 48);
    return _Asm_mux1(_MBTYPE_REV, y);
}

inline
unsigned int
ByteOrder_Util_ia64_swap_32(const unsigned int x)
{
    register Types::Uint64 y;
    y = _Asm_shl(x, 32);
    return _Asm_mux1(_MBTYPE_REV, y);
}

inline
Types::Uint64
ByteOrder_Util_ia64_swap_64(const Types::Uint64 x)
{
    return _Asm_mux1(_MBTYPE_REV, x);
}

}  // close package namespace

#endif  // BSLS_PLATFORM_CMP_HP &amp;&amp; IA64

// ----------------------------------------------------------------------------
// SUN

#if defined(BSLS_PLATFORM_CPU_SPARC)

// Note that inline assembly fails with &#39;-O&#39; (default &#39;-O3&#39;) with Studio12, so
// disabling on Sun for now.
//..
//#if ((defined(BSLS_PLATFORM_CMP_SUN)
//   &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x590
//   &amp;&amp; defined(BDE_BUILD_TARGET_OPT))
// || defined(BSLS_PLATFORM_CMP_GNU))
//..

#if defined(BSLS_PLATFORM_CMP_GNU)

namespace bsls {

inline
unsigned short
ByteOrder_Util_sparc_swap_16(const unsigned short *x)
{
    register unsigned int y;
    asm(&quot;lduha [%1] %2, %0&quot;
      : &quot;=r&quot; (y)
      : &quot;r&quot; (x), &quot;i&quot;(0x88), &quot;m&quot; (*x));
            // We have to use &quot;r&quot;(x) instead of &quot;m&quot;(*x) because certain
            // instructions do not support the &#39;m&#39; constraint.  The &#39;m&#39;
            // constraint is the only way to tell the compiler we are reading
            // the value of &#39;*x&#39; and not just &#39;x&#39;.

    return static_cast&lt;unsigned short&gt;(y);
}

inline
unsigned int
ByteOrder_Util_sparc_swap_32(const unsigned int *x)
{
    register unsigned int y;
    asm(&quot;lduwa [%1] %2, %0&quot;
      : &quot;=r&quot; (y)
      : &quot;r&quot; (x), &quot;i&quot;(0x88), &quot;m&quot; (*x));

    return y;
}

}  // close package namespace

#if defined(BSLS_PLATFORM_CPU_64_BIT)

inline
bsls::Types::Uint64
bsls_ByteOrder_Util_sparc_swap_64(const bsls::Types::Uint64 *x)
{
    register bsls::Types::Uint64 y;
    asm(&quot;ldxa [%1] %2, %0&quot;
      : &quot;=r&quot; (y)
      : &quot;r&quot; (x), &quot;i&quot;(0x88), &quot;m&quot; (*x));

    return y;
}

#else

inline
bsls::Types::Uint64
bsls_ByteOrder_Util_sparc_swap_64(const bsls::Types::Uint64 *x)
{
    register bsls::Types::Uint64 y;
    asm(&quot;ldxa [%1] %2, %0\n\t&quot;  // After the load, the full data is in &#39;%0&#39;.
                                // But we have to split it into two registers
                                // since we are running in 32-bit mode.

        &quot;srl   %0, 0, %R0\n\t&quot;  // The &#39;%R0&#39; specifies the lower-order bits of
                                // a pair register, while &#39;%0&#39; specifies the
                                // higher-order bits.  Move the lower-order
                                // bits of the result to &#39;%R0&#39;.

        &quot;srlx  %0, 32, %0&quot;      // Shift the higher-order bits of the result.
      : &quot;=r&quot; (y)
      : &quot;r&quot; (x), &quot;i&quot;(0x88), &quot;m&quot; (*x));

    return y;
}

#endif  // BSLS_PLATFORM_CPU_64_BIT

#else  // BSLS_PLATFORM_CMP_GNU

namespace bsls {

// Commented out assembly implementation since the generic implementation is
// probably faster than the function call for 16 and 32 bits.  Define the swap
// functions here to simplify the macro definitions at the &#39;generic_swap&#39;
// level.

inline
unsigned short ByteOrder_Util_sparc_swap_16(const unsigned short *x)
{
    register const unsigned short y = *x;
    return (y &gt;&gt; 8) | (y &lt;&lt; 8);
}

inline
unsigned int ByteOrder_Util_sparc_swap_32(const unsigned int *x)
{
    register const unsigned int y = *x;
    return ((y &amp; 0x000000FF) &lt;&lt; 24)
         | ((y &amp; 0x0000FF00) &lt;&lt;  8)
         | ((y &amp; 0x00FF0000) &gt;&gt;  8)
         |  (y &gt;&gt; 24);
}

}  // close package namespace

extern &quot;C&quot; {
// unsigned short bsls_ByteOrder_Util_sparc_swap_16(const unsigned short *x);
// unsigned int bsls_ByteOrder_Util_sparc_swap_32(const unsigned int *x);
unsigned long long bsls_ByteOrder_Util_sparc_swap_64(
                                                  const unsigned long long *x);
}

#endif  // BSLS_PLATFORM_CMP_GNU

#endif  // BSLS_PLATFORM_CPU_SPARC

// ----------------------------------------------------------------------------
// AIX
#if defined(BSLS_PLATFORM_CPU_POWERPC) &amp;&amp; defined(BSLS_PLATFORM_CMP_IBM)    \
    &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0800

unsigned short bsls_ByteOrder_Util_powerpc_swap_16(const unsigned short *x);
// The following is equivalent to:
//..
//  lhbrx r3,0,r3
//..
// The following is necessary to work around the bug reported in DRQS 16073004
// using inline assembly with xlC10:
#pragma mc_func bsls_ByteOrder_Util_powerpc_swap_16 { &quot;7c601e2c&quot; }
#pragma reg_killed_by bsls_ByteOrder_Util_powerpc_swap_16 gr3

unsigned int bsls_ByteOrder_Util_powerpc_swap_32(const unsigned int *x);
// The following is equivalent to:
//..
//  lwbrx r3,0,r3
//..
// This follows the AIX ABI: the first argument is received in &#39;r3&#39; and the
// return value is stored in &#39;r3&#39;.  The hex value specified for &#39;mc_func&#39; is
// the opcode of the above code.

#pragma mc_func bsls_ByteOrder_Util_powerpc_swap_32 { &quot;7c601c2c&quot; }
#pragma reg_killed_by bsls_ByteOrder_Util_powerpc_swap_32 gr3

unsigned long long bsls_ByteOrder_Util_powerpc_swap_64(
                                                  const unsigned long long *x);
#ifdef BSLS_PLATFORM_CPU_32_BIT
// The following is equivalent to:
//..
//  lwbrx r4,0,r3      // reverse the 4 higher-order bytes
//  addi r3,r3,4       // change r3 to point to the 4 lower-order bytes
//  lwbrx r3,0,r3      // reverse the 4 lower-order bytes
//..
#pragma mc_func bsls_ByteOrder_Util_powerpc_swap_64                   \
                                            { &quot;7c801c2c&quot; &quot;38630004&quot; &quot;7c601c2c&quot;}
#pragma reg_killed_by bsls_ByteOrder_Util_powerpc_swap_64 gr3,gr4

#else  // BSLS_PLATFORM_CPU_64_BIT
// The following is equivalent to:
//..
//  addi r4,r3,4       // move address of the 4 lower-order bytes to &#39;r4&#39;
//  lwbrx r3,0,r3      // reverse the 4 higher-order bytes
//  lwbrx r4,0,r4      // reverse the 4 lower-order bytes
//  rldimi r3,r4,32,0  // rotate &#39;r4&#39; left and insert to &#39;r3&#39; with a mask
//..
#pragma mc_func bsls_ByteOrder_Util_powerpc_swap_64                   \
                                { &quot;38830004&quot; &quot;7c601c2c&quot; &quot;7c80242c&quot; &quot;7883000e&quot; }
#pragma reg_killed_by bsls_ByteOrder_Util_powerpc_swap_64 gr3,gr4,cr0

#endif  // BSLS_PLATFORM_CPU_32_BIT
#endif  // BSLS_PLATFORM_CPU_POWERPC

namespace bsls {

// ----------------------------------------------------------------------------

                         // ----------------------
                         // struct ByteOrder_Util
                         // ----------------------

// CLASS METHODS
inline
unsigned short
ByteOrder_Util::generic_swap_16(unsigned short x)
{
// Use built-in if possible; provided by Windows intrinsics.
#if defined(BSLS_PLATFORM_CMP_MSVC)
    return _byteswap_ushort(x);

#elif (defined(BSLS_PLATFORM_CPU_X86) || defined(BSLS_PLATFORM_CPU_X86_64)) \
    &amp;&amp; defined(BSLS_PLATFORM_CMP_GNU)
    return ByteOrder_Util_x86_swap_16(x);

#elif defined(BSLS_PLATFORM_CPU_SPARC)
    return ByteOrder_Util_sparc_swap_16(&amp;x);

#elif defined(BSLS_PLATFORM_CPU_POWERPC) &amp;&amp; defined(BSLS_PLATFORM_CMP_IBM)  \
   &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0800
    return bsls_ByteOrder_Util_powerpc_swap_16(&amp;x);

#elif defined(BSLS_PLATFORM_CPU_IA64) &amp;&amp; defined(BSLS_PLATFORM_CMP_HP)
    return ByteOrder_Util_ia64_swap_16(x);

#else
    return (x &gt;&gt; 8) | (x &lt;&lt; 8);

#endif
}

inline
unsigned int
ByteOrder_Util::generic_swap_32(unsigned int x)
{
// Use built-in if possible; provided in gcc 4.3+.
#if defined(BSLS_PLATFORM_CMP_GNU) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 40300
    return __builtin_bswap32((int)x);

// Use built-in if possible; provided by Windows intrinsics.
#elif defined(BSLS_PLATFORM_CMP_MSVC)
    return _byteswap_ulong(x);

#elif (defined(BSLS_PLATFORM_CPU_X86) || defined(BSLS_PLATFORM_CPU_X86_64)) \
   &amp;&amp; defined(BSLS_PLATFORM_CMP_GNU)
    return ByteOrder_Util_x86_swap_32(x);

#elif defined(BSLS_PLATFORM_CPU_SPARC)
    return ByteOrder_Util_sparc_swap_32(&amp;x);

#elif defined(BSLS_PLATFORM_CPU_POWERPC) &amp;&amp; defined(BSLS_PLATFORM_CMP_IBM)  \
   &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0800
    return bsls_ByteOrder_Util_powerpc_swap_32(&amp;x);

#elif defined(BSLS_PLATFORM_CPU_IA64) &amp;&amp; defined(BSLS_PLATFORM_CMP_HP)
    return ByteOrder_Util_ia64_swap_32(x);

#else
    return ((x &amp; 0x000000FF) &lt;&lt; 24)
         | ((x &amp; 0x0000FF00) &lt;&lt;  8)
         | ((x &amp; 0x00FF0000) &gt;&gt;  8)
         |  (x &gt;&gt; 24);
#endif
}

inline
Types::Uint64
ByteOrder_Util::generic_swap_64(Types::Uint64 x)
{
// Use built-in if possible; provided in gcc 4.3+.
#if defined(BSLS_PLATFORM_CMP_GNU) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 40300
    return __builtin_bswap64((Types::Int64)x);

// Use built-in if possible; provided by Windows intrinsics.
#elif defined(BSLS_PLATFORM_CMP_MSVC)
    return _byteswap_uint64(x);

#elif (defined(BSLS_PLATFORM_CPU_X86) || defined(BSLS_PLATFORM_CPU_X86_64)) \
    &amp;&amp; defined(BSLS_PLATFORM_CMP_GNU)
    return ByteOrder_Util_x86_swap_64(x);

#elif defined(BSLS_PLATFORM_CPU_SPARC)
    return bsls_ByteOrder_Util_sparc_swap_64(&amp;x);

#elif defined(BSLS_PLATFORM_CPU_POWERPC) &amp;&amp; defined(BSLS_PLATFORM_CMP_IBM)  \
   &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0800
    return bsls_ByteOrder_Util_powerpc_swap_64(&amp;x);

#elif defined(BSLS_PLATFORM_CPU_IA64) &amp;&amp; defined(BSLS_PLATFORM_CMP_HP)
    return ByteOrder_Util_ia64_swap_64(x);

#else
    return ((x &amp; 0x00000000000000FFLL) &lt;&lt; 56)
         | ((x &amp; 0x000000000000FF00LL) &lt;&lt; 40)
         | ((x &amp; 0x0000000000FF0000LL) &lt;&lt; 24)
         | ((x &amp; 0x00000000FF000000LL) &lt;&lt;  8)
         | ((x &amp; 0x000000FF00000000LL) &gt;&gt;  8)
         | ((x &amp; 0x0000FF0000000000LL) &gt;&gt; 24)
         | ((x &amp; 0x00FF000000000000LL) &gt;&gt; 40)
         |  (x &gt;&gt; 56);
#endif
}

}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2013 Bloomberg Finance L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
