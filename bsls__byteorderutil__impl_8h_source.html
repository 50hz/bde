<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.22.1.2 OSS</title>
<html>
<pre>
// bsls_byteorderutil_impl.h                                          -*-C++-*-
#ifndef INCLUDED_BSLS_BYTEORDERUTIL_IMPL
#define INCLUDED_BSLS_BYTEORDERUTIL_IMPL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide implementation of byte-order manipulation functions.
//
//@CLASSES:
//   bsls::ByteOrderUtil_Impl: namespace for swapping functions
//
//@MACROS:
//   BSLS_BYTEORDERUTIL_IMPL_CUSTOM_16:  &#39;customeSwap16&#39;  function is defined
//   BSLS_BYTEORDERUTIL_IMPL_CUSTOM_32:  &#39;customeSwap32&#39;  function is defined
//   BSLS_BYTEORDERUTIL_IMPL_CUSTOM_64:  &#39;customeSwap64&#39;  function is defined
//   BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P16: &#39;customeSwapP16&#39; function is defined
//   BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P32: &#39;customeSwapP32&#39; function is defined
//   BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P64: &#39;customeSwapP64&#39; function is defined
//
//@SEE ALSO: bsls_byteorderutil, bsls_byteorder
//
//@DESCRIPTION: This component provides a namespace &#39;struct&#39;,
// &#39;bsls::ByteOrderUtil_Impl&#39;, for a number of high performance
// platform-specific static function implementations for functions and macros
// in the &#39;bsls_byteorder&#39; and &#39;bsls_byteorderutil&#39; components.
//
// This component is only intended to be used by &#39;bsls_byteorderutil&#39;.  No
// other component should call anything in it directly.
//
// The functions come in 3 groups:
//: o &#39;customSwapNN&#39; -- take an &#39;NN&#39; bit value by value and return it with its
//:   byte order swapped.
//: o &#39;customSwapPNN&#39; -- take a pointer to a constant &#39;NN&#39; bit value and return
//:   the dereferenced value with its byte order swapped.
//: o &#39;genericSwapNN&#39; -- take an &#39;NN&#39; bit value by value and return it with its
//:   byte order swapped.
// the &#39;customSwap*&#39; functions are not always defined on all platforms.  When
// they are defined the corresponding macro is defined to signal
// &#39;bsls_byteorderutil&#39; that it may use that function.  If neither the
// &#39;customeSwapNN&#39; nor the &#39;customSwapPNN&#39; macros are defined,
// &#39;bsls_byteorderutil&#39; is to use the &#39;genericSwapNN&#39; function, which is always
// defined.

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifdef BSLS_PLATFORM_CMP_HP

#ifndef INCLUDED_MACHINE_SYS_BUILTINS
#include &lt;machine/sys/builtins.h&gt;  // &#39;_Asm_xchg&#39;
#define INCLUDED_MACHINE_SYS_BUILTINS
#endif

#ifndef INCLUDED_MACHINE_SYS_INLINE
#include &lt;machine/sys/inline.h&gt;    // &#39;_SZ_H&#39;, &#39;_SZ_W&#39;, &#39;_SZ_D&#39;
#define INCLUDED_MACHINE_SYS_INLINE
#endif

#endif

#ifdef BSLS_PLATFORM_CMP_MSVC

#ifndef INCLUDED_STDLIB
#include &lt;stdlib.h&gt;        // &#39;_byteswap_*&#39;
#define INCLUDED_STDLIB
#endif

#endif

namespace BloombergLP {

namespace bsls {

                          // =========================
                          // struct ByteOrderUtil_Impl
                          // =========================

struct ByteOrderUtil_Impl {
    // This &#39;struct&#39; is a namespace for the byte order swapping functions to
    // support &#39;bsls_byteorderutil&#39; and &#39;bsls_byteorder&#39;.

    // CLASS METHODS

    // custom, platform-specific inline implementations, not defined on all
    // platforms

    static
    unsigned short customSwap16(       unsigned short   x);
        // Return the specified &#39;x&#39; with byte order swapped.

    static
    unsigned int   customSwap32(       unsigned int     x);
        // Return the specified &#39;x&#39; with byte order swapped.

    static
    Types::Uint64  customSwap64(       Types::Uint64    x);
        // Return the specified &#39;x&#39; with byte order swapped.

    static
    unsigned short customSwapP16( const unsigned short *x);
        // Return the specified &#39;*x&#39; with byte order swapped.

    static
    unsigned int   customSwapP32( const unsigned int   *x);
        // Return the specified &#39;*x&#39; with byte order swapped.

    static
    Types::Uint64  customSwapP64( const Types::Uint64  *x);
        // Return the specified &#39;*x&#39; with byte order swapped.

    // generic, non-platform-specific implementations, always defined on all
    // platforms

    static
    unsigned short genericSwap16(      unsigned short   x);
        // Return the specified &#39;*x&#39; with byte order swapped.

    static
    unsigned int   genericSwap32(      unsigned int     x);
        // Return the specified &#39;*x&#39; with byte order swapped.

    static
    Types::Uint64  genericSwap64(      Types::Uint64    x);
        // Return the specified &#39;*x&#39; with byte order swapped.
};

                         // -------------------------
                         // struct ByteOrderUtil_Impl
                         // -------------------------

#if defined(BSLS_PLATFORM_CMP_GNU) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 40300

// ----------------------------------------------------------------------------
// Advanced GNU

// Let the 16-bit gnu implementation default to &#39;genericSwap16&#39; or other
// platform-specific gnu implementations.

#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_32 1
#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_64 1

// LEVEL 0 METHODS

inline
unsigned int
ByteOrderUtil_Impl::customSwap32(unsigned int x)
{
    // generic GNU impl

    return __builtin_bswap32((int)x);
}

inline
Types::Uint64
ByteOrderUtil_Impl::customSwap64(Types::Uint64 x)
{
    // generic GNU impl

    return __builtin_bswap64((bsls::Types::Int64)x);
}

#elif defined(BSLS_PLATFORM_CMP_MSVC)

// ----------------------------------------------------------------------------
// MSVC

#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_16 1
#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_32 1
#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_64 1

inline
unsigned short
ByteOrderUtil_Impl::customSwap16(unsigned short x)
{
    // msvc impl

    return _byteswap_ushort(x);
}

inline
unsigned int
ByteOrderUtil_Impl::customSwap32(unsigned int x)
{
    // msvc impl

    // Note that &#39;ulong&#39; (unsigned long) is only 32 bit on MSVC, compiled
    // 32 or 64 bit.

    return _byteswap_ulong(x);
}

inline
Types::Uint64
ByteOrderUtil_Impl::customSwap64(Types::Uint64 x)
{
    // msvc impl

    return _byteswap_uint64(x);
}

#elif defined(BSLS_PLATFORM_CPU_IA64) &amp;&amp; defined(BSLS_PLATFORM_CMP_HP)

// ----------------------------------------------------------------------------
// HPUX

#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_16 1
#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_32 1
#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_64 1

inline
unsigned short
ByteOrderUtil_Impl::customSwap16(unsigned short x)
{
    // hpux impl

    register Types::Uint64 y;
    y = _Asm_shl(x, 48);
    return _Asm_mux1(_MBTYPE_REV, y);
}

inline
unsigned int
ByteOrderUtil_Impl::customSwap32(unsigned int x)
{
    // hpux impl

    register Types::Uint64 y;
    y = _Asm_shl(x, 32);
    return _Asm_mux1(_MBTYPE_REV, y);
}

inline
Types::Uint64
ByteOrderUtil_Impl::customSwap64(Types::Uint64 x)
{
    // hpux impl

    return _Asm_mux1(_MBTYPE_REV, x);
}

#elif defined(BSLS_PLATFORM_CPU_POWERPC) &amp;&amp; defined(BSLS_PLATFORM_CMP_IBM)    \
    &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0800

// ----------------------------------------------------------------------------
// POWERPC-AIX

#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P16 1
#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P32 1
#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P64 1

unsigned short
bsls_byteOrderUtil_Impl_powerpc_swap_p16(const unsigned short *x);
    // Return the specified &#39;*x&#39; with byte order swapped.

// The following is equivalent to:
//..
//  lhbrx r3,0,r3
//..
// The following is necessary to work around the bug reported in DRQS 16073004
// using inline assembly with xlC10:
#pragma mc_func bsls_byteOrderUtil_Impl_powerpc_swap_p16 { &quot;7c601e2c&quot; }
#pragma reg_killed_by bsls_byteOrderUtil_Impl_powerpc_swap_p16 gr3

unsigned int bsls_byteOrderUtil_Impl_powerpc_swap_p32(const unsigned int *x);
    // Return the specified &#39;*x&#39; with byte order swapped.

// The following is equivalent to:
//..
//  lwbrx r3,0,r3
//..
// This follows the AIX ABI: the first argument is received in &#39;r3&#39; and the
// return value is stored in &#39;r3&#39;.  The hex value specified for &#39;mc_func&#39; is
// the opcode of the above code.

#pragma mc_func bsls_byteOrderUtil_Impl_powerpc_swap_p32 { &quot;7c601c2c&quot; }
#pragma reg_killed_by bsls_byteOrderUtil_Impl_powerpc_swap_p32 gr3

unsigned long long bsls_byteOrderUtil_Impl_powerpc_swap_p64(
                                                  const unsigned long long *x);
    // Return the specified &#39;*x&#39; with byte order swapped.

#ifdef BSLS_PLATFORM_CPU_32_BIT
// The following is equivalent to:
//..
//  lwbrx r4,0,r3      // reverse the 4 higher-order bytes
//  addi r3,r3,4       // change r3 to point to the 4 lower-order bytes
//  lwbrx r3,0,r3      // reverse the 4 lower-order bytes
//..
#pragma mc_func bsls_byteOrderUtil_Impl_powerpc_swap_p64                   \
                                            { &quot;7c801c2c&quot; &quot;38630004&quot; &quot;7c601c2c&quot;}
#pragma reg_killed_by bsls_byteOrderUtil_Impl_powerpc_swap_p64 gr3,gr4

#else  // BSLS_PLATFORM_CPU_64_BIT
// The following is equivalent to:
//..
//  addi r4,r3,4       // move address of the 4 lower-order bytes to &#39;r4&#39;
//  lwbrx r3,0,r3      // reverse the 4 higher-order bytes
//  lwbrx r4,0,r4      // reverse the 4 lower-order bytes
//  rldimi r3,r4,32,0  // rotate &#39;r4&#39; left and insert to &#39;r3&#39; with a mask
//..
#pragma mc_func bsls_byteOrderUtil_Impl_powerpc_swap_p64                   \
                                { &quot;38830004&quot; &quot;7c601c2c&quot; &quot;7c80242c&quot; &quot;7883000e&quot; }
#pragma reg_killed_by bsls_byteOrderUtil_Impl_powerpc_swap_p64 gr3,gr4,cr0

#endif  // BSLS_PLATFORM_CPU_32_BIT else

inline
unsigned short ByteOrderUtil_Impl::customSwapP16(const unsigned short *x)
{
    // powerpc impl

    return bsls_byteOrderUtil_Impl_powerpc_swap_p16(x);
}

inline
unsigned int ByteOrderUtil_Impl::customSwapP32(const unsigned int *x)
{
    // powerpc impl

    return bsls_byteOrderUtil_Impl_powerpc_swap_p32(x);
}

inline
Types::Uint64 ByteOrderUtil_Impl::customSwapP64(const Types::Uint64 *x)
{
    // powerpc impl

    return bsls_byteOrderUtil_Impl_powerpc_swap_p64(x);
}

#endif  // BSLS_PLATFORM_CPU_POWERPC

#if defined(BSLS_PLATFORM_CPU_SPARC)

// ----------------------------------------------------------------------------
// Sparc

#if defined(BSLS_PLATFORM_CMP_GNU)

#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P16 1

// LEVEL 1 METHODS

inline
unsigned short
ByteOrderUtil_Impl::customSwapP16(const unsigned short *x)
{
    // sparc gnu impl

    // We have to use &quot;r&quot;(x) instead of &quot;m&quot;(*x) because certain instructions do
    // not support the &#39;m&#39; constraint.  The &#39;m&#39; constraint is the only way to
    // tell the compiler we are reading the value of &#39;*x&#39; and not just &#39;x&#39;.

    register unsigned int y;
    asm(&quot;lduha [%1] %2, %0&quot;
      : &quot;=r&quot; (y)
      : &quot;r&quot; (x), &quot;i&quot;(0x88), &quot;m&quot; (*x));

    return static_cast&lt;unsigned short&gt;(y);
}

#if   !defined(BSLS_BYTEORDERUTIL_IMPL_CUSTOM_32)                             \
   &amp;&amp; !defined(BSLS_BYTEORDERUTIL_IMPL_CUSTOM_64)                             \
   &amp;&amp; !defined(BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P32)                            \
   &amp;&amp; !defined(BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P64)

#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P32 1
#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P64 1

inline
unsigned int
ByteOrderUtil_Impl::customSwapP32(const unsigned int *x)
{
    // sparc gnu pre-4.03 impl

    register unsigned int y;
    asm(&quot;lduwa [%1] %2, %0&quot;
      : &quot;=r&quot; (y)
      : &quot;r&quot; (x), &quot;i&quot;(0x88), &quot;m&quot; (*x));

    return y;
}

#if defined(BSLS_PLATFORM_CPU_64_BIT)

inline
Types::Uint64
ByteOrderUtil_Impl::customSwapP64(const Types::Uint64 *x)
{
    // sparc gnu pre-4.03 impl

    register Types::Uint64 y;
    asm(&quot;ldxa [%1] %2, %0&quot;
      : &quot;=r&quot; (y)
      : &quot;r&quot; (x), &quot;i&quot;(0x88), &quot;m&quot; (*x));

    return y;
}

#else

inline
Types::Uint64
ByteOrderUtil_Impl::customSwapP64(const Types::Uint64 *x)
{
    // sparc gnu pre-4.03 impl

    register Types::Uint64 y;
    asm(&quot;ldxa [%1] %2, %0\n\t&quot;  // After the load, the full data is in &#39;%0&#39;.
                                // But we have to split it into two registers
                                // since we are running in 32-bit mode.

        &quot;srl   %0, 0, %R0\n\t&quot;  // The &#39;%R0&#39; specifies the lower-order bits of
                                // a pair register, while &#39;%0&#39; specifies the
                                // higher-order bits.  Move the lower-order
                                // bits of the result to &#39;%R0&#39;.

        &quot;srlx  %0, 32, %0&quot;      // Shift the higher-order bits of the result.
      : &quot;=r&quot; (y)
      : &quot;r&quot; (x), &quot;i&quot;(0x88), &quot;m&quot; (*x));

    return y;
}

#endif  // BSLS_PLATFORM_CPU_64_BIT else

#endif  // 32 &amp; 64 bit not defined

#else  // BSLS_PLATFORM_CMP_GNU else

// Commented out assembly implementation since &#39;genericSwap{16,32} is
// probably faster than the function call for 16 and 32 bits.

#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P64 1

extern &quot;C&quot; {
unsigned long long bsls_byteOrderUtil_Impl_sparc_CC_swap_p64(
                                                  const unsigned long long *x);
    // Return the specified &#39;*x&#39; with byte order swapped.  Sparc CC impl in
    // .cpp file.
}

inline
Types::Uint64 ByteOrderUtil_Impl::customSwapP64(const Types::Uint64 *x)
{
    // sparc CC impl

    return bsls_byteOrderUtil_Impl_sparc_CC_swap_p64(x);
}

#endif  // BSLS_PLATFORM_CMP_GNU else

#elif (defined(BSLS_PLATFORM_CPU_X86) || defined(BSLS_PLATFORM_CPU_X86_64))   \
    &amp;&amp; defined(BSLS_PLATFORM_CMP_GNU)

// Note that 32 and 64 bit may have already been defined by the advanced GNU
// case.

#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_16 1

// LEVEL 1 METHODS

inline
unsigned short
ByteOrderUtil_Impl::customSwap16(unsigned short x)
{
    // x86 gnu impl

    register unsigned short y;
    __asm__ (&quot;xchg %b0, %h0&quot; : &quot;=Q&quot; (y) : &quot;0&quot; (x));
    return y;
}

#if   !defined(BSLS_BYTEORDERUTIL_IMPL_CUSTOM_32)                             \
   &amp;&amp; !defined(BSLS_BYTEORDERUTIL_IMPL_CUSTOM_64)                             \
   &amp;&amp; !defined(BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P32)                            \
   &amp;&amp; !defined(BSLS_BYTEORDERUTIL_IMPL_CUSTOM_P64)

#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_32 1
#define BSLS_BYTEORDERUTIL_IMPL_CUSTOM_64 1

inline
unsigned int
ByteOrderUtil_Impl::customSwap32(unsigned int x)
{
    // x86 gnu pre-4.03 impl

    register unsigned int y;
    __asm__ (&quot;bswap %0&quot; : &quot;=r&quot; (y) : &quot;0&quot; (x));
    return y;
}

#if BSLS_PLATFORM_CPU_32_BIT

inline
Types::Uint64
ByteOrderUtil_Impl::customSwap64(Types::Uint64 x)
{
    // x86 gnu pre-4.03 impl

    register unsigned int res, tmp;
    __asm__ (&quot;bswap %0\n\t&quot;
             &quot;bswap %1\n\t&quot;
           : &quot;=r&quot; (res), &quot;=r&quot; (tmp)
           : &quot;0&quot; ((unsigned) x), &quot;1&quot; ((unsigned) (x &gt;&gt; 32)));

    return ((Types::Uint64)res &lt;&lt; 32ULL)
          | (Types::Uint64)tmp;
}

#else  // BSLS_PLATFORM_CPU_64_BIT

inline
Types::Uint64
ByteOrderUtil_Impl::customSwap64(Types::Uint64 x)
{
    // x86 gnu pre-4.03 impl

    register Types::Uint64 y;
    __asm__ (&quot;bswap %0&quot; : &quot;=r&quot; (y) : &quot;0&quot; (x));
    return y;
}

#endif  // 32 &amp; 64 not previously defined
#endif  // BSLS_PLATFORM_CPU_32_BIT else
#endif  // BSLS_PLATFORM_CMP_GNU &amp;&amp; X86

inline
unsigned short
ByteOrderUtil_Impl::genericSwap16(unsigned short x)
{
    return static_cast&lt;unsigned short&gt;((x &gt;&gt; 8) | (x &lt;&lt; 8));
}

inline
unsigned int
ByteOrderUtil_Impl::genericSwap32(unsigned int x)
{
    return ( x               &lt;&lt; 24)
         | ((x &amp; 0x0000ff00) &lt;&lt;  8)
         | ((x &amp; 0x00ff0000) &gt;&gt;  8)
         | ( x               &gt;&gt; 24);
}

inline
Types::Uint64
ByteOrderUtil_Impl::genericSwap64(Types::Uint64 x)
{
    return ( x                         &lt;&lt; 56)
         | ((x &amp; 0x000000000000ff00LL) &lt;&lt; 40)
         | ((x &amp; 0x0000000000ff0000LL) &lt;&lt; 24)
         | ((x &amp; 0x00000000ff000000LL) &lt;&lt;  8)
         | ((x &amp; 0x000000ff00000000LL) &gt;&gt;  8)
         | ((x &amp; 0x0000ff0000000000LL) &gt;&gt; 24)
         | ((x &amp; 0x00ff000000000000LL) &gt;&gt; 40)
         | ( x                         &gt;&gt; 56);
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
