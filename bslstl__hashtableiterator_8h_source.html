<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslstl_hashtableiterator.h                                         -*-C++-*-
#ifndef INCLUDED_BSLSTL_HASHTABLEITERATOR
#define INCLUDED_BSLSTL_HASHTABLEITERATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an STL compliant iterator for hash tables.
//
//@CLASSES:
//  bslstl::HashTableIterator: an STL compliant forward iterator
//
//@SEE_ALSO: bslalg_bidirectionallink, bslstl_unorderedmap, bslstl_unorderedset
//
//@DESCRIPTION: This component provides an STL-compliant forward iterator over
// the elements of a hash table.  The requirements of a STL forward iterator
// are outlined in the C++11 standard in section [24.2.5] under the tag
// [forward.iterators].  A &#39;HashTableIterator&#39; object is parameterized on
// &#39;VALUE_TYPE&#39;, &#39;&#39;, and &#39;DIFFERENCE_TYPE&#39;.  The parameterized
// &#39;VALUE_TYPE&#39; indicates the type of the value to which this iterator provides
// as references, and may be const-qualified for constant iterators.  The
// parameterized &#39;&#39; shall provide a static &#39;extractValue&#39; member
// function returning a reference values stored through
// &#39;bslstl::BidirectionalLink *&#39; pointers to nodes in the hash table data
// structure.  Note that &#39;VALUE_TYPE&#39; may have additional const-qualification
// over the type of reference returned by the &#39;&#39;, in order to
// support constant iterators.  Finally, the parameterized &#39;DIFFERENCE_TYPE&#39;
// determines the (standard mandated) &#39;difference_type&#39; for the iterator.
//
///Usage
///-----

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;&lt;bslstl_hashtableiterator.h&gt; header can&#39;t be included directly in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ITERATOR
#include &lt;bslstl_iterator.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINK
#include &lt;bslalg_bidirectionallink.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALNODE
#include &lt;bslalg_bidirectionalnode.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECVQ
#include &lt;bslmf_removecvq.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

namespace BloombergLP
{
namespace bslstl
{

                          // =======================
                          // class HashTableIterator
                          // =======================

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
class HashTableIterator
#ifdef BSLS_PLATFORM__OS_SOLARIS
: public native_std::iterator&lt;native_std::forward_iterator_tag, VALUE_TYPE&gt;
// On Solaris just to keep studio12-v4 happy, since algorithms takes only
// iterators inheriting from &#39;std::iterator&#39;.
#endif
{
    // This class provides an in-core value semantic type that is an
    // STL-conforming forward iterator over a list of
    // &#39;bslalg::BidirectionalLink&#39; objects (see section 24.2.5
    // [forward.iterators] of the C++11 standard).  A &#39;HashTableIterator&#39;
    // provides access to values of the parameterized &#39;VALUE_TYPE&#39;,
    // stored in a hash table composed of &#39;bslalg::BidirectionalLink&#39; nodes
    // additional storing objects of the parameterized &#39;VALUE_TYPE&#39; which are
    // made accessible through the &#39;extractValue&#39; static member function of the
    // parameterized &#39;&#39; class.  The parameterized
    // &#39;DIFFERENCE_TYPE&#39; determines the standard mandated &#39;difference_type&#39; of
    // the iterator, without requiring access to the allocator-traits for the
    // node.  The parameterized &#39;&#39; must provide a static method,
    // &#39;extractValue&#39; that takes a single &#39;bslalg::BidirectionalLink *&#39;
    // argument, and that returns a reference providing modifiable access to a
    // type that is convertible to the parameterized &#39;VALUE_TYPE&#39;.

    // PRIVATE TYPES
    typedef typename bslmf::RemoveCvq&lt;VALUE_TYPE&gt;::Type NcType;
    typedef HashTableIterator&lt;NcType, DIFFERENCE_TYPE&gt; NcIter;

  public:
    // PUBLIC TYPES
    typedef NcType                      value_type;
    typedef DIFFERENCE_TYPE             difference_type;
    typedef VALUE_TYPE                 *pointer;
    typedef VALUE_TYPE&amp;                 reference;
    typedef bsl::forward_iterator_tag   iterator_category;
        // Standard iterator defined types [24.4.2].

  private:
    // DATA
    bslalg::BidirectionalLink *d_node_p;

  private:
    void advance();
        // Advance to the next element.

  public:
    // CREATORS
    HashTableIterator();
        // Create an iterator object with the default value for this type.  All
        // default-constructed &#39;HashTableIterator&#39; objects represent
        // non-dereferenceable iterators into the same empty range.  They do
        // not have a singular value.

    explicit HashTableIterator(bslalg::BidirectionalLink *node);
        // create an iterator referring to the specified &#39;node&#39;.  the behavior
        // is undefined unless &#39;node&#39; is of the parameterized &#39;NODE&#39;, which
        // is derived from &#39;bslalg::BidirectionalLink&#39;.  Note that this
        // constructor is an implementation detail and is not part of the C++
        // standard.

    HashTableIterator(const NcIter&amp; original);
        // Create an iterator having the same value as the specified
        // &#39;original&#39;.  Note that this operation is either defined by the
        // constructor taking &#39;NcIter&#39; (if &#39;NcType&#39; is the same as
        // &#39;VALUE_TYPE&#39;), or generated automatically by the compiler.  Also
        // note that this constructor cannot be defined explicitly (without
        // using &#39;bsls::enableif&#39;) to avoid a duplicate declaration when
        // &#39;NcType&#39; is the same as &#39;VALUE_TYPE&#39;.

    //! ~HashTableIterator();
        // Destroy this object.

    // MANIPULATORS
    //! HashTableIterator&amp; operator=(const HashTableIterator&amp; rhs);
        // Copy the value of the specified &#39;rhs&#39; to this iterator.  Return a
        // reference to this modifiable object.  Note that this method&#39;s
        // definition is compiler generated.

    HashTableIterator&amp; operator++();
        // Move this iterator to the next element in the hash table and return
        // a reference providing modifiable access to this iterator.  The
        // behavior is undefined unless the iterator refers to a valid (not yet
        // erased) node a hash table.

    HashTableIterator operator++(int);
        // Move this iterator to the next element in the hash table and return
        // value of this iterator prior to this call.  The behavior is
        // undefined unless the iterator refers to a valid (not yet erased)
        // node a hash table.

    // ACCESSORS
    reference operator*() const;
        // Return a reference providing modifiable access to the value (of the
        // parameterized &#39;VALUE_TYPE&#39;) of the element at which this iterator
        // is positioned.  The behavior is undefined unless the iterator refers
        // to a valid (not yet erased) node a hash table.

    pointer operator-&gt;() const;
        // Return the address of the value (of the parameterized &#39;VALUE_TYPE&#39;)
        // of the element at which this iterator is positioned.  The behavior
        // is undefined unless the iterator refers to a valid (not yet erased)
        // node a hash table.

    bslalg::BidirectionalLink *node() const;
        // Return the address of the list-node at which this iterator is
        // positioned, or 0 if this iterator is positioned after the end of a
        // list.  Note that this method is an implementation detail and is not
        // part of the C++ standard.
};

// FREE FUNCTIONS AND OPERATORS
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator==(const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
                const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator==(
              const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp;       lhs,
              const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator==(
              const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
              const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp;       rhs);
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator==(
              const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
              const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and the specified &#39;rhs&#39; iterators
    // have the same value and &#39;false&#39; otherwise.  Two iterators have
    // the same value if they refer to the same node in the same hash table, or
    // if both iterators are positioned after the end of a hash table.

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator!=(const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
                const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator!=(
              const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp;       lhs,
              const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator!=(
        const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
        const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp;       rhs);
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator!=(
              const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
              const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and the specified &#39;rhs&#39; iterators
    // do not have the same value and &#39;false&#39; otherwise.  Two iterators do not
    // have the same value if they refer to the different nodes in the same
    // hash table, or if either (but not both) of the iterators are positioned
    // after the end of a hash table.

// ===========================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ===========================================================================

                     // -----------------------
                     // class HashTableIterator
                     // -----------------------

// CREATORS
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
HashTableIterator()
: d_node_p()
{
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
HashTableIterator(bslalg::BidirectionalLink *node)
: d_node_p(node)
{
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
HashTableIterator(const NcIter&amp; original)
: d_node_p(original.node())
{
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
void HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::advance()
{
    BSLS_ASSERT_SAFE(d_node_p);

    this-&gt;d_node_p = this-&gt;d_node_p-&gt;nextLink();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp;
HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::operator++()
{
    BSLS_ASSERT_SAFE(this-&gt;d_node_p);

    this-&gt;advance();
    return *this;
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;
HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::operator++(int)
{
    BSLS_ASSERT_SAFE(this-&gt;d_node_p);

    HashTableIterator result(*this);
    this-&gt;advance();
    return result;
}

// ACCESSORS
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
typename HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::reference
HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::operator*() const
{
    BSLS_ASSERT_SAFE(this-&gt;d_node_p);

    return static_cast&lt;bslalg::BidirectionalNode&lt;VALUE_TYPE&gt; *&gt;(
                                                            d_node_p)-&gt;value();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
typename HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::pointer
HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::operator-&gt;() const
{
    BSLS_ASSERT_SAFE(this-&gt;d_node_p);

    return bsls::Util::addressOf(
            static_cast&lt;bslalg::BidirectionalNode&lt;VALUE_TYPE&gt; *&gt;(
                                                           d_node_p)-&gt;value());
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bslalg::BidirectionalLink *
HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::node() const
{
    return d_node_p;
}

}  // close namespace BloombergLP::bslstl

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool bslstl::operator==(
                     const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
                     const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs)
{
    return lhs.node() == rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool bslstl::operator==(
               const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp;       lhs,
               const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs)
{
    return lhs.node() == rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool bslstl::operator==(
               const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
               const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp;       rhs)
{
    return lhs.node() == rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool bslstl::operator==(
               const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
               const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs)
{
    return lhs.node() == rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool bslstl::operator!=(
                     const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
                     const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs)
{
    return lhs.node() != rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool bslstl::operator!=(
               const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp;       lhs,
               const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs)
{
    return lhs.node() != rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool bslstl::operator!=(
               const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
               const HashTableIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp;       rhs)
{
    return lhs.node() != rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool bslstl::operator!=(
               const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
               const HashTableIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs)
{
    return lhs.node() != rhs.node();
}


}  // close namespace BloombergLP

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
