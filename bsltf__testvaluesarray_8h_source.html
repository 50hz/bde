<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bsltf_testvaluesarray.h                                            -*-C++-*-
#ifndef INCLUDED_BSLTF_TESTVALUESARRAY
#define INCLUDED_BSLTF_TESTVALUESARRAY

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a container for values used for testing.
//
//@CLASSES:
//           bsltf::TestValuesArray: container for values used for testing.
//   bsltf::TestValuesArrayIterator: iterators for the container
//
//@SEE_ALSO: bsltf_testfacility
//
//@DESCRIPTION: This component defines a class &#39;TestValuesArray&#39; providing a
// a uniform interface for creating and accessing an array of test values of
// type that may or may not have a default constructor.
//
// This component also defines an iterator class &#39;TestValuesArrayIterator&#39;
// providing access to elements in a &#39;TestValuesArray&#39; object.
// &#39;TestValuesArrayIterator&#39; is designed to satisfies the minimal requirement
// of an input iterator as defined by the C++11 standard [24.2.3].  It uses the
// &#39;BSLS_ASSERT&#39; macro to detect undefined behavior.
//
///Iterator
///--------
// The requirements of the input iterators as defined by the C++11 standard may
// not be as tight as the users of the input iterators expected.  Incorrect
// assumptions about the properties of the input iterator may result in
// undefined behavior.  &#39;TestValuesArrayIterator&#39; is designed to detect
// possible incorrect usages.  Specifically, &#39;TestValuesArrayIterator&#39; put
// restriction on when it can be dereferenced or compared.  A
// &#39;TestValuesArrayIterator&#39; is considered to be *dereferenceable* if it
// satisfies all of the following:
//
//: 1 The iterator refers to a valid element (not &#39;end&#39;).
//:
//: 2 The iterator has not been dereferenced.  (*)
//:
//: 3 The iterator is not a copy of another iterator of which &#39;operator++&#39;
//:   have been invoked.  (see [table 107] of the C++11 standard)
//
// *note: An input iterator may not be dereferenced more than once is a common
// requirement of a container method that takes input iterators as arguments.
// Other standard algorithms may allow the iterator to be dereferenced more
// than once, in which case, &#39;TestValuesArrayIterator&#39; is not suitable to be
// used to with those algorithms.
//
// &#39;TestValuesArrayIterator&#39; is comparable if the iterator is not a copy of
// another iterator of which &#39;operator++&#39; have been invoked.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Testing a Simple Template Function
///- - - - - - - - - - - - - - - - - - - - - - -
// Suppose that we have a function that we would like to test.  This function
// take in a range defined by two input iterators and returns the largest value
// in that range.
//
// First, we define the function we would like to test:
//..
//  template &lt;class VALUE, class INPUT_ITERATOR&gt;
//  VALUE myMaxValue(INPUT_ITERATOR first, INPUT_ITERATOR last)
//      // Return the largest value referred to by the iterators in the range
//      // beginning at the specified &#39;first&#39; and up to, but not including, the
//      // specified &#39;last&#39;.  The behavior is undefined unless [first, last)
//      // specifies a valid range and &#39;first != last&#39;.
//  {
//      assert(first != last);
//
//      VALUE largestValue(*first);
//      ++first;
//      for(;first != last; ++first) {
//          // Store in temporary variable to avoid dereferencing twice.
//
//          const VALUE&amp; temp = *first;
//          if (largestValue &lt; temp) {
//              largestValue = temp;
//          }
//      }
//      return largestValue;
//  }
//..
// Next, we implement a test function &#39;runTest&#39; that allows the function to be
// tested with different types:
//..
//  template &lt;class VALUE&gt;
//  void runTest()
//  {
//..
//  Then, we define a set of test values and expected results:
//..
//      struct {
//          const char *d_spec;
//          const char  d_result;
//      } DATA[] = {
//          { &quot;A&quot;,     &#39;A&#39; },
//          { &quot;ABC&quot;,   &#39;C&#39; },
//          { &quot;ADCB&quot;,  &#39;D&#39; },
//          { &quot;EDCBA&quot;, &#39;E&#39; }
//      };
//      const int NUM_DATA = sizeof DATA / sizeof *DATA;
//..
//  Now, for each set of test values, verify that the function return the
//  expected result.
//..
//      for (int i = 0; i &lt; NUM_DATA; ++i) {
//          const char *const SPEC = DATA[i].d_spec;
//          const VALUE       EXP  =
//                bsltf::TemplateTestFacility::create&lt;VALUE&gt;(DATA[i].d_result);
//
//          bsltf::TestValuesArray&lt;VALUE&gt; values(SPEC);
//          assert(EXP == myMaxValue&lt;VALUE&gt;(values.begin(), values.end()));
//      }
//  }
//..
// Finally, we invoke the test function to verify our function is implemented
// correctly.  The test function to run without triggering the &#39;assert&#39;
// statement:
//..
//  runTest&lt;char&gt;();
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLTF_TEMPLATETESTFACILITY
#include &lt;bsltf_templatetestfacility.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_ITERATOR
#include &lt;iterator&gt;
#define INCLUDED_ITERATOR
#endif

#ifndef INCLUDED_CSTRING
#include &lt;cstring&gt;
#define INCLUDED_CSTRING
#endif

namespace BloombergLP {
namespace bsltf {

                       // =============================
                       // class TestValuesArrayIterator
                       // =============================

template &lt;class VALUE&gt;
class TestValuesArrayIterator {
    // This class provide a STL-conforming input iterator over values used for
    // testing (see section [24.2.3 input.iterators] of the C++11 standard.  A
    // &#39;TestValuesArrayIterator&#39; provide access to elements of parameterized
    // type &#39;VALUE&#39;.  An iterator is considered dereferenceable all of the
    // following are satified:
    //: 1 The iterator refers to a valid element (not &#39;end&#39;).
    //:
    //: 2 The iterator has not been dereferenced.
    //:
    //: 3 The iterator is not a copy of another iterator of which &#39;operator++&#39;
    //:   have been invoked.
    // An iterator is comparable if the iterator is not a copy of another
    // iterator of which &#39;operator++&#39; have been invoked.
    //

    // DATA
    const VALUE *d_data_p;              // pointer to array of values (held,
                                        // not owned)

    const VALUE *d_end_p;               // end pointer (held, not owned)

    bool        *d_dereferenceable_p;   // indicate if dereferenceable (held,
                                        // not owned)

    bool        *d_comparable_p;        // indicate if comparable (held, not
                                        // owned)

  private:
    // FRIENDS
    template &lt;class OTHER_VALUE&gt;
    friend bool operator==(const TestValuesArrayIterator&lt;OTHER_VALUE&gt;&amp;,
                           const TestValuesArrayIterator&lt;OTHER_VALUE&gt;&amp;);

    template &lt;class OTHER_VALUE&gt;
    friend bool operator!=(const TestValuesArrayIterator&lt;OTHER_VALUE&gt;&amp;,
                           const TestValuesArrayIterator&lt;OTHER_VALUE&gt;&amp;);

  public:
    // TYPES
    typedef std::forward_iterator_tag iterator_category;
    typedef VALUE                     value_type;
    typedef std::ptrdiff_t            difference_type;
    typedef VALUE*                    pointer;
    typedef VALUE&amp;                    reference;
        // Standard iterator defined types [24.4.2].

  public:
    // CREATORS
    TestValuesArrayIterator(const VALUE *object,
                            const VALUE *end,
                            bool        *dereferenceable,
                            bool        *comparable);
        // Create an iterator referring to the specified &#39;object&#39; for a
        // container with the specified &#39;end&#39;, with two arrays of boolean
        // referred to by the specified &#39;dereferenceable&#39; and &#39;comparable
        // to indicate whether this iterator and its subsequent values
        // until &#39;end&#39; is allowed to be dereferenced or compared
        // respectively.

    // MANIPULATORS
    const VALUE&amp; operator *();
        // Return the value referred to by this object.  This object is no
        // longer dereferenceable after a call to this function.  The
        // behavior is undefined unless this iterator is dereferenceable.

    const VALUE *operator-&gt;();
        // Return the address of the value (of the parameterized &#39;VALUE_TYPE&#39;)
        // of the element at which this iterator is positioned.  The behavior
        // is undefined unless this iterator dereferenceable.

    TestValuesArrayIterator&amp; operator++();
        // Move this iterator to the next element in the container.  Any copies
        // of this iterator are no longer dereferenceable or comparable.  The
        // behavior is undefined unless this iterator refers to a valid value
        // in the container.

};

template &lt;class VALUE&gt;
bool operator==(const TestValuesArrayIterator&lt;VALUE&gt;&amp; lhs,
                const TestValuesArrayIterator&lt;VALUE&gt;&amp; rhs);
    // Return &#39;true&#39; if this object and &#39;rhs&#39; refers to the same element, and
    // &#39;false&#39; otherwise.  The behavior is undefined unless &#39;lhs&#39; and &#39;rhs&#39; are
    // comparable.

template &lt;class VALUE&gt;
bool operator!=(const TestValuesArrayIterator&lt;VALUE&gt;&amp; lhs,
                const TestValuesArrayIterator&lt;VALUE&gt;&amp; rhs);
    // Return &#39;true&#39; if this object and &#39;rhs&#39; does *not* refers to the same
    // element, and &#39;false&#39; otherwise.  The behavior is undefined unless &#39;lhs&#39;
    // and &#39;rhs&#39; are comparable.

                       // ========================
                       // class TestTypesConverter
                       // ========================

template &lt;class VALUE&gt;
class TestTypesConverter {
  public:
    VALUE operator()(char value)
    {
        return bsltf::TemplateTestFacility::create&lt;VALUE&gt;(value);
    }
};

                       // ====================
                       // class TestValueArray
                       // ====================

template &lt;class VALUE, class CONVERTER = TestTypesConverter&lt;VALUE&gt; &gt;
class TestValuesArray {
    // This class provide a container to store values of the parameterized
    // &#39;VALUE&#39;, and also provide the iterators to access the values.  The
    // iterators are designed to conform to a standard input iterator, and will
    // report any misuse of the iterator.

    // DATA
    bslma::Allocator *d_allocator_p;      // allocator (held, not owned)

    VALUE            *d_data;             // pointer to memory storing the
                                          // values (owned)

    size_t            d_size;             // number of elements in this object

    bool             *d_dereferenceable;  // pointer to an array to indicate
                                          // which iterator is dereferenceable
                                          // (owned)

    bool             *d_comparable;       // pointer to an array to indicate
                                          // which iterator is comparable
                                          // (owned)

  private:
    // NOT IMPLEMENTED
    TestValuesArray(const TestValuesArray&amp;);

  private:
    // PRIVATE MANIPULATOR
    void initialize(const char *spec, bslma::Allocator *basicAllocator);
        // Initialize this object with the specified &#39;spec&#39; using the specified
        // &#39;basicAllocator&#39; to supply memory.

  public:
    typedef TestValuesArrayIterator&lt;VALUE&gt; iterator;
        // Iterator for this container.

  public:
    // CREATORS
    explicit TestValuesArray(bslma::Allocator *basicAllocator = 0);
    explicit TestValuesArray(const char      *spec,
                             bslma::Allocator *basicAllocator = 0);
        // Create an object containing 52 distinct values of type &#39;VALUE&#39;.
        // Optionally, specified &#39;spec&#39; to indicate the values this object
        // should contain, where the values are created by invoking the
        // &#39;bsltf::TemplateTestFacility::create&#39; method on each character of
        // &#39;spec&#39;.  Optionally, specify &#39;basicAllocator&#39; to used to supply
        // memory.

    ~TestValuesArray();
        // Destroy this object.

    // MANIPULATORS
    VALUE *data();
        // Return the address of the first element in this object.

    iterator begin();
        // Return an iterator to the first element.

    iterator index(size_t value);
        // Return an iterator to the element at the specified &#39;index&#39;.

    iterator end();
        // Return an iterator to the past-the-end element.

    void resetIterators();
        // Make all iterators dereferenceable and comparable again.

    // ACCESSORS
    const VALUE *data() const;
        // Return the address of the first element in this object.

    const VALUE&amp; operator[](size_t index) const;
        // Return a reference providing non-modifiable access to the element at
        // the specified &#39;index&#39;.

    size_t size() const;
        // Return number of elements in this object.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                       // -----------------------------
                       // class TestValuesArrayIterator
                       // -----------------------------

// CREATORS
template &lt;class VALUE&gt;
TestValuesArrayIterator&lt;VALUE&gt;::TestValuesArrayIterator(
                                                  const VALUE *object,
                                                  const VALUE *end,
                                                  bool        *dereferenceable,
                                                  bool        *comparable)
: d_data_p(object)
, d_end_p(end)
, d_dereferenceable_p(dereferenceable)
, d_comparable_p(comparable)
{
}

// MANIPULATORS
template &lt;class VALUE&gt;
const VALUE&amp; TestValuesArrayIterator&lt;VALUE&gt;::operator *()
{
    BSLS_ASSERT_OPT(*d_dereferenceable_p);

    *d_dereferenceable_p = false;
    return *d_data_p;
}

template &lt;class VALUE&gt;
const VALUE *TestValuesArrayIterator&lt;VALUE&gt;::operator-&gt;()
{
    BSLS_ASSERT_OPT(*d_dereferenceable_p);

    *d_dereferenceable_p = false;
    return d_data_p;
}

template &lt;class VALUE&gt;
TestValuesArrayIterator&lt;VALUE&gt;&amp;
TestValuesArrayIterator&lt;VALUE&gt;::operator++()
{
    BSLS_ASSERT_OPT(d_data_p != d_end_p);

    *d_dereferenceable_p = false;
    *d_comparable_p = false;

    ++d_data_p;
    ++d_dereferenceable_p;
    ++d_comparable_p;
    return *this;
}

}  // close package namespace

// FREE OPERATORS
template &lt;class VALUE&gt;
inline
bool bsltf::operator==(const bsltf::TestValuesArrayIterator&lt;VALUE&gt;&amp; lhs,
                       const bsltf::TestValuesArrayIterator&lt;VALUE&gt;&amp; rhs)
{
    BSLS_ASSERT_OPT(*lhs.d_comparable_p);
    BSLS_ASSERT_OPT(*rhs.d_comparable_p);

    return lhs.d_data_p == rhs.d_data_p;
}

template &lt;class VALUE&gt;
inline
bool bsltf::operator!=(const bsltf::TestValuesArrayIterator&lt;VALUE&gt;&amp; lhs,
                       const bsltf::TestValuesArrayIterator&lt;VALUE&gt;&amp; rhs)
{
    return !(lhs == rhs);
}

namespace bsltf {

                       // --------------------
                       // class TestValueArray
                       // --------------------

// PRIVATE MANIPULATORS
template &lt;class VALUE, class CONVERTER&gt;
void TestValuesArray&lt;VALUE, CONVERTER&gt;::initialize(
                                              const char       *spec,
                                              bslma::Allocator *basicAllocator)
{
    d_size = std::strlen(spec);

    d_allocator_p = bslma::Default::allocator(basicAllocator);

    // Allocate all memory in one go.

    d_data = reinterpret_cast&lt;VALUE *&gt;(d_allocator_p-&gt;allocate(
                    d_size * sizeof(VALUE) + 2 * (d_size + 1) * sizeof(bool)));

    d_dereferenceable = reinterpret_cast&lt;bool *&gt;(d_data + d_size);
    d_comparable = d_dereferenceable + d_size + 1;

    for (int i = 0; &#39;\0&#39; != spec[i]; ++i) {
        bslalg::ScalarPrimitives::copyConstruct(
                    data() + i,
                    CONVERTER()(spec[i]),
                    d_allocator_p);
    }

    std::memset(d_dereferenceable, true, d_size * sizeof(bool));
    d_dereferenceable[d_size] = false;  // &#39;end&#39; is not dereferenceable
    std::memset(d_comparable, true, (d_size + 1) * sizeof(bool));
}

// CREATORS
template &lt;class VALUE, class CONVERTER&gt;
TestValuesArray&lt;VALUE, CONVERTER&gt;::TestValuesArray(
                                              bslma::Allocator *basicAllocator)
{
    static const char DEFAULT_SPEC[] =
                        &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;

    initialize(DEFAULT_SPEC, basicAllocator);
}

template &lt;class VALUE, class CONVERTER&gt;
TestValuesArray&lt;VALUE, CONVERTER&gt;::TestValuesArray(
                                              const char       *spec,
                                              bslma::Allocator *basicAllocator)
{
    initialize(spec, basicAllocator);
}

template &lt;class VALUE, class CONVERTER&gt;
TestValuesArray&lt;VALUE, CONVERTER&gt;::~TestValuesArray()
{
    for (size_t i = 0; i &lt; d_size; ++i) {
        data()[i].~VALUE();
    }
    d_allocator_p-&gt;deallocate(d_data);
}

// MANIPULATORS
template &lt;class VALUE, class CONVERTER&gt;
VALUE *TestValuesArray&lt;VALUE, CONVERTER&gt;::data()
{
    return d_data;
}

template &lt;class VALUE, class CONVERTER&gt;
typename TestValuesArray&lt;VALUE, CONVERTER&gt;::iterator
TestValuesArray&lt;VALUE, CONVERTER&gt;::begin()
{
    return iterator(data(), data() + d_size, d_dereferenceable, d_comparable);
}

template &lt;class VALUE, class CONVERTER&gt;
typename TestValuesArray&lt;VALUE, CONVERTER&gt;::iterator
TestValuesArray&lt;VALUE, CONVERTER&gt;::index(size_t value)
{
    BSLS_ASSERT_OPT(value &lt;= size());

    return iterator(data() + value,
                    data() + d_size,
                    d_dereferenceable + value,
                    d_comparable + value);
}

template &lt;class VALUE, class CONVERTER&gt;
typename TestValuesArray&lt;VALUE, CONVERTER&gt;::iterator
TestValuesArray&lt;VALUE, CONVERTER&gt;::end()
{
    return iterator(data() + d_size,
                    data() + d_size,
                    d_dereferenceable + d_size,
                    d_comparable + d_size);
}

template &lt;class VALUE, class CONVERTER&gt;
void TestValuesArray&lt;VALUE, CONVERTER&gt;::resetIterators()
{
    memset(d_dereferenceable, 1, d_size * sizeof(bool));
    d_dereferenceable[d_size] = false;
    memset(d_comparable, 1, (d_size + 1) * sizeof(bool));
}

// ACCESSORS
template &lt;class VALUE, class CONVERTER&gt;
const VALUE *TestValuesArray&lt;VALUE, CONVERTER&gt;::data() const
{
    return d_data;
}

template &lt;class VALUE, class CONVERTER&gt;
const VALUE&amp; TestValuesArray&lt;VALUE, CONVERTER&gt;::operator[](size_t index) const
{
    return data()[index];
}

template &lt;class VALUE, class CONVERTER&gt;
size_t TestValuesArray&lt;VALUE, CONVERTER&gt;::size() const
{
    return d_size;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
