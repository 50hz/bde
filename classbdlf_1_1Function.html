<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlf::Function</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlf.html">bdlf</a>      </li>
      <li><a class="el" href="classbdlf_1_1Function.html">bdlf::Function&lt; PROTOTYPE &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlf::Function&lt; PROTOTYPE &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlf::Function" -->
<p><code>#include &lt;<a class="el" href="bdlf__function_8h_source.html">bdlf_function.h</a>&gt;</code></p>

<p><a href="classbdlf_1_1Function-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classbdlf_1_1Function.html#ad20dae7c4c9b97826b7edb6d133d3227a495378ae3b0321f2fd00adf9898e3987">MAX_INPLACE_OBJECT_SIZE</a> =  FunctionUtil::MAX_INPLACE_OBJECT_SIZE
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbdlf_1_1Function__TypeList.html#ac79f4c3590f9f58ed74a32724b18ddf0">Args::ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#abb9290023ec852b2181b083adc7e5bc7">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdlf_1_1Function.html">Function</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a9f8da9c0761166896ef3d5acd67e5c00">Function</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC_OR_ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#aa92481dcce39f72e3fa22f95cd54f64c">Function</a> (const FUNC_OR_ALLOC &amp;funcOrAlloc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#acb2d79fa3a9dcb6bbc9cc58ac8dc38eb">Function</a> (const FUNC &amp;func, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a9c4e5ecc00aed7af4423372ad7e52611">Function</a> (const <a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; &amp;original, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a69dada108cf5642052a6f01c86c15477">operator=</a> (const <a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a9624607c3ba5ca0782b8d78534830185">operator=</a> (const FUNC &amp;func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a3c224b63c48e96364f81d34f6e636cb4">clear</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a13f991eab0383721b38e617fab7117e2">load</a> (const FUNC &amp;func, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a98e77101897e631430fc04fffce15b7b">swap</a> (<a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#afebfd8bfd1fec777dd80bdb481107cf2">transferTo</a> (<a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; *target)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a1f03c20ea6f7dbb2164633b88731ecee">operator()</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a5ff294be1b3d0fd09d9348d434a2e626">operator()</a> (A1 a1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a491bdcb9f0dfd7ad82b3b24dadce0a69">operator()</a> (A1 a1, A2 a2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a542bddd3cefd67ae17dee469833b92bc">operator()</a> (A1 a1, A2 a2, A3 a3) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a9f1f711ed7deb66e1bfd06a62b37207c">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#ada170b97e041dd88c4f07c16524e8a6b">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a6e081a632cb16652498c004d77dd37e3">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#afe1f1a946681b2cd9a1c6e49591596e6">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a16c7194cb17624bcb5ac73c0fa2e90da">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a719d8abd2b53b216672979ed18d8914f">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a958b287b53a9d6da7c214c206b10213e">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#ada2510c7e476a91f34761ec79898f529">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#aa355436f4ffdfe1fcb7918df7eefe7ba">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a3a6a4936eacdba0416dd9724ff4afb5c">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a731a14111a6b4a511abfcb1ecb50f003">operator()</a> (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a8f3dfe70bd293fe257c9bd2281e59541">operator Function_UnspecifiedBool</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a3544400618dd2a89985c2fb7ff798fbe">getAllocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function.html#a25103043dc059796440bbbeecd69d194">isInplace</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class PROTOTYPE&gt;<br/>
 class bdlf::Function&lt; PROTOTYPE &gt;</h3>

<p>This class provides a function object (functor) that has the same signature as the parameterized <code>PROTOTYPE</code>: return a result type and accept a number of up to fourteen arguments of types all specified by <code>PROTOTYPE</code>. A "functor" is synonymous to a C/C++ function pointer, but more generally than function pointers, functors can be used to invoke any object ("invocable") that can be syntactically invoked as a function. Invocables include function pointers, but also user-defined types that have an <code>operator()</code>. Functors are generally used as callback functions in place of virtual functions.</p>
<p><a class="el" href="classbdlf_1_1Function.html">Function</a> objects do not have value-semantics, because they are primarily mechanisms used through invocation and do not have a notion of value (as defined by <code>operator==</code>). </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a0b5e151b028688606009ee1f0790c9ae"></a><!-- doxytag: member="bdlf::Function::ResultType" ref="a0b5e151b028688606009ee1f0790c9ae" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbdlf_1_1Function__TypeList.html#ac79f4c3590f9f58ed74a32724b18ddf0">Args::ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad20dae7c4c9b97826b7edb6d133d3227"></a><!-- doxytag: member="bdlf::Function::@202" ref="ad20dae7c4c9b97826b7edb6d133d3227" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad20dae7c4c9b97826b7edb6d133d3227a495378ae3b0321f2fd00adf9898e3987"></a><!-- doxytag: member="MAX_INPLACE_OBJECT_SIZE" ref="ad20dae7c4c9b97826b7edb6d133d3227a495378ae3b0321f2fd00adf9898e3987" args="" -->MAX_INPLACE_OBJECT_SIZE</em>&nbsp;</td><td>
<p>Maximum size of functor (including additional parameters) that is guaranteed not to trigger a call to the allocator (typically one function or member function pointer plus four integers). Equal to <code><a class="el" href="structbdlf_1_1FunctionUtil.html#ae48e1e3dc2e9e79560291d4917a91796a3c6a30f3d87bdd9b1f74bacbedbd49bf">FunctionUtil::MAX_INPLACE_OBJECT_SIZE</a></code>. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9f8da9c0761166896ef3d5acd67e5c00"></a><!-- doxytag: member="bdlf::Function::Function" ref="a9f8da9c0761166896ef3d5acd67e5c00" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1Function.html">Function</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty function object using the currently installed default allocator to supply memory. </p>

</div>
</div>
<a class="anchor" id="aa92481dcce39f72e3fa22f95cd54f64c"></a><!-- doxytag: member="bdlf::Function::Function" ref="aa92481dcce39f72e3fa22f95cd54f64c" args="(const FUNC_OR_ALLOC &amp;funcOrAlloc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class FUNC_OR_ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1Function.html">Function</a> </td>
          <td>(</td>
          <td class="paramtype">const FUNC_OR_ALLOC &amp;&nbsp;</td>
          <td class="paramname"> <em>funcOrAlloc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create either a function object having the value of the specified <code>funcOrAlloc</code> function object, or an uninitialized function object having <code>funcOrAlloc</code> as an allocator if <code>FUNC_OR_ALLOC</code> is convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*</code>. For example, if <code>myAllocator</code> belongs to a class that is derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, the <code><a class="el" href="classbdlf_1_1Function.html">Function</a>(&amp;myAllocator)</code> will construct an uninitialized function object using the specified <code>myAllocator</code>. The behavior is undefined if <code>funcOrAlloc</code> is a null function pointer.</p>
<p>Note that this creator takes the place of the two constructors below: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">         <a class="code" href="classbdlf_1_1Function.html#a9f8da9c0761166896ef3d5acd67e5c00">Function</a>(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator);
         <span class="keyword">template</span> &lt;<span class="keyword">class</span> FUNC&gt; <a class="code" href="classbdlf_1_1Function.html#a9f8da9c0761166896ef3d5acd67e5c00">Function</a>(<span class="keyword">const</span> FUNC&amp; func);
</pre></div><p><br/>
<br/>
 Unfortunately, if we had instead provided the above two constructors, then invocation of <code><a class="el" href="classbdlf_1_1Function.html">Function</a>(&amp;myAllocator)</code> would improperly match the second constructor because the template argument is always a better match than a derived-to-base conversion. </p>

</div>
</div>
<a class="anchor" id="acb2d79fa3a9dcb6bbc9cc58ac8dc38eb"></a><!-- doxytag: member="bdlf::Function::Function" ref="acb2d79fa3a9dcb6bbc9cc58ac8dc38eb" args="(const FUNC &amp;func, bslma::Allocator *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1Function.html">Function</a> </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a function object having the value of the specified <code>func</code> object using the specified <code>allocator</code> to supply memory. </p>

</div>
</div>
<a class="anchor" id="a9c4e5ecc00aed7af4423372ad7e52611"></a><!-- doxytag: member="bdlf::Function::Function" ref="a9c4e5ecc00aed7af4423372ad7e52611" args="(const Function&lt; PROTOTYPE &gt; &amp;original, bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1Function.html">Function</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a function object storing a copy of the same invocable as the specified <code>original</code> object, using the optionally specified <code>allocator</code> to supply memory. If <code>allocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abb9290023ec852b2181b083adc7e5bc7"></a><!-- doxytag: member="bdlf::Function::BSLALG_DECLARE_NESTED_TRAITS" ref="abb9290023ec852b2181b083adc7e5bc7" args="(Function, bslalg::TypeTraitUsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a69dada108cf5642052a6f01c86c15477"></a><!-- doxytag: member="bdlf::Function::operator=" ref="a69dada108cf5642052a6f01c86c15477" args="(const Function&lt; PROTOTYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html">Function</a>&lt;PROTOTYPE&gt;&amp; <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the invocable of the specified <code>rhs</code> and return a reference to this modifiable function object. </p>

</div>
</div>
<a class="anchor" id="a9624607c3ba5ca0782b8d78534830185"></a><!-- doxytag: member="bdlf::Function::operator=" ref="a9624607c3ba5ca0782b8d78534830185" args="(const FUNC &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html">Function</a>&lt;PROTOTYPE&gt;&amp; <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this function object the specified <code>func</code> invocable object of the parameterized <code>FUNC</code> type, and return a reference to this modifiable function object. </p>

</div>
</div>
<a class="anchor" id="a3c224b63c48e96364f81d34f6e636cb4"></a><!-- doxytag: member="bdlf::Function::clear" ref="a3c224b63c48e96364f81d34f6e636cb4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this function object to an empty state. </p>

</div>
</div>
<a class="anchor" id="a13f991eab0383721b38e617fab7117e2"></a><!-- doxytag: member="bdlf::Function::load" ref="a13f991eab0383721b38e617fab7117e2" args="(const FUNC &amp;func, bslma::Allocator *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html">Function</a>&lt;PROTOTYPE&gt;&amp; <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this function object the specified <code>func</code> object of the parameterized <code>FUNC</code> type, using the specified <code>allocator</code> to supply memory. If <code>allocator</code> is 0, continue to use the same allocator as before this call. Return a reference to this modifiable function object. The behavior is undefined if <code>func</code> is a null function pointer. Note the deviation from the standard <code>bdema</code> allocator usage when <code>allocator</code> is 0.</p>
<p>DEPRECATED: Create with <code>allocator</code> and simply assign <code>func</code> instead. </p>

</div>
</div>
<a class="anchor" id="a98e77101897e631430fc04fffce15b7b"></a><!-- doxytag: member="bdlf::Function::swap" ref="a98e77101897e631430fc04fffce15b7b" args="(Function&lt; PROTOTYPE &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the invocable stored by this function object with that stored by the specified <code>other</code> function object. </p>

</div>
</div>
<a class="anchor" id="afebfd8bfd1fec777dd80bdb481107cf2"></a><!-- doxytag: member="bdlf::Function::transferTo" ref="afebfd8bfd1fec777dd80bdb481107cf2" args="(Function&lt; PROTOTYPE &gt; *target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::transferTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlf_1_1Function.html">Function</a>&lt; PROTOTYPE &gt; *&nbsp;</td>
          <td class="paramname"> <em>target</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfer the invocable stored by this function object to the specified <code>target</code> function object. The behavior is undefined if <code>target</code> points to this function object. Note that once transferred, this function object will be empty. </p>

</div>
</div>
<a class="anchor" id="a1f03c20ea6f7dbb2164633b88731ecee"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a1f03c20ea6f7dbb2164633b88731ecee" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with zero arguments and return the result or <code>void</code> if this function object does not return a result. If the <code>PROTOTYPE</code> of this function does not accept zero arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a5ff294be1b3d0fd09d9348d434a2e626"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a5ff294be1b3d0fd09d9348d434a2e626" args="(A1 a1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the single specified argument <code>a1</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept a single argument, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a491bdcb9f0dfd7ad82b3b24dadce0a69"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a491bdcb9f0dfd7ad82b3b24dadce0a69" args="(A1 a1, A2 a2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the two specified arguments <code>a1</code> and <code>a2</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept two arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a542bddd3cefd67ae17dee469833b92bc"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a542bddd3cefd67ae17dee469833b92bc" args="(A1 a1, A2 a2, A3 a3) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the three specified arguments <code>a1</code> up to <code>a3</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept three arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a9f1f711ed7deb66e1bfd06a62b37207c"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a9f1f711ed7deb66e1bfd06a62b37207c" args="(A1 a1, A2 a2, A3 a3, A4 a4) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the four specified arguments <code>a1</code> up to <code>a4</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept four arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="ada170b97e041dd88c4f07c16524e8a6b"></a><!-- doxytag: member="bdlf::Function::operator()" ref="ada170b97e041dd88c4f07c16524e8a6b" args="(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the five specified arguments <code>a1</code> up to <code>a5</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept five arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a6e081a632cb16652498c004d77dd37e3"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a6e081a632cb16652498c004d77dd37e3" args="(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the six specified arguments <code>a1</code> up to <code>a6</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept six arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="afe1f1a946681b2cd9a1c6e49591596e6"></a><!-- doxytag: member="bdlf::Function::operator()" ref="afe1f1a946681b2cd9a1c6e49591596e6" args="(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the seven specified arguments <code>a1</code> up to <code>a7</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept seven arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a16c7194cb17624bcb5ac73c0fa2e90da"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a16c7194cb17624bcb5ac73c0fa2e90da" args="(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the eight specified arguments <code>a1</code> up to <code>a8</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept eight arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a719d8abd2b53b216672979ed18d8914f"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a719d8abd2b53b216672979ed18d8914f" args="(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the nine specified arguments <code>a1</code> up to <code>a9</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept nine arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a958b287b53a9d6da7c214c206b10213e"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a958b287b53a9d6da7c214c206b10213e" args="(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the ten specified arguments <code>a1</code> up to <code>a10</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept ten arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="ada2510c7e476a91f34761ec79898f529"></a><!-- doxytag: member="bdlf::Function::operator()" ref="ada2510c7e476a91f34761ec79898f529" args="(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the eleven specified arguments <code>a1</code> up to <code>a11</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept eleven arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="aa355436f4ffdfe1fcb7918df7eefe7ba"></a><!-- doxytag: member="bdlf::Function::operator()" ref="aa355436f4ffdfe1fcb7918df7eefe7ba" args="(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A12&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the twelve specified arguments <code>a1</code> up to <code>a12</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept twelve arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a3a6a4936eacdba0416dd9724ff4afb5c"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a3a6a4936eacdba0416dd9724ff4afb5c" args="(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A12&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A13&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the thirteen specified arguments <code>a1</code> up to <code>a13</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept thirteen arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a731a14111a6b4a511abfcb1ecb50f003"></a><!-- doxytag: member="bdlf::Function::operator()" ref="a731a14111a6b4a511abfcb1ecb50f003" args="(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html#a0b5e151b028688606009ee1f0790c9ae">ResultType</a> <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A12&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A13&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A14&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke this function object with the fourteen specified arguments <code>a1</code> up to <code>a14</code> as defined by <code>PROTOTYPE</code> and return the result or <code>void</code> if this function object does not return a result. If <code>PROTOTYPE</code> does not accept fourteen arguments, then compiler diagnostic will be emitted. Note that the behavior is undefined if this function object is empty. </p>

</div>
</div>
<a class="anchor" id="a8f3dfe70bd293fe257c9bd2281e59541"></a><!-- doxytag: member="bdlf::Function::operator Function_UnspecifiedBool" ref="a8f3dfe70bd293fe257c9bd2281e59541" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::operator <a class="el" href="namespacebdlf.html#adae3dc01dbc0138ff393d219f8dda848">Function_UnspecifiedBool</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a value of the "unspecified bool" that evaluates to <code>false</code> if this function object is empty, and <code>true</code> otherwise. Note that this conversion operator allows a function object to be used within a conditional context (e.g., within an <code>if</code> or <code>while</code> statement), but does <em>not</em> allow function objects to be compared (e.g., via <code>&lt;</code> or <code>&gt;</code>). </p>

</div>
</div>
<a class="anchor" id="a3544400618dd2a89985c2fb7ff798fbe"></a><!-- doxytag: member="bdlf::Function::getAllocator" ref="a3544400618dd2a89985c2fb7ff798fbe" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>* <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::getAllocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> instance used to supply memory by this function object. </p>

</div>
</div>
<a class="anchor" id="a25103043dc059796440bbbeecd69d194"></a><!-- doxytag: member="bdlf::Function::isInplace" ref="a25103043dc059796440bbbeecd69d194" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a>&lt; PROTOTYPE &gt;::isInplace </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether this instance uses an inplace representation or not. See the section <code><a class="el" href="classbdlf_1_1Function.html">Function</a> objects and allocation</code> in the component-level documentation. Note that this function returns <code>true</code> for an empty function object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlf__function_8h_source.html">bdlf_function.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:44 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
