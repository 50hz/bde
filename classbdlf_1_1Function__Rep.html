<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlf::Function_Rep</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlf.html">bdlf</a>      </li>
      <li><a class="el" href="classbdlf_1_1Function__Rep.html">bdlf::Function_Rep</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bdlf::Function_Rep Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlf::Function_Rep" -->
<p><code>#include &lt;<a class="el" href="bdlf__function_8h_source.html">bdlf_function.h</a>&gt;</code></p>

<p><a href="classbdlf_1_1Function__Rep-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlf_1_1Function__Rep_1_1ArenaType.html">ArenaType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#afb20d901efffa7a80463edfcd86fe916">ManagerOpCode</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classbdlf_1_1Function__Rep.html#afb20d901efffa7a80463edfcd86fe916a81fd782a73112995403917de0fcb6da5">e_MOVE_CONSTRUCT</a> =  0, 
<a class="el" href="classbdlf_1_1Function__Rep.html#afb20d901efffa7a80463edfcd86fe916a7aea5be62a0e95122670366f2ae84b70">e_COPY_CONSTRUCT</a> =  1, 
<a class="el" href="classbdlf_1_1Function__Rep.html#afb20d901efffa7a80463edfcd86fe916a4f32369e63bb525e3c80d42d43c33199">e_CONSTRUCT</a> =  2, 
<a class="el" href="classbdlf_1_1Function__Rep.html#afb20d901efffa7a80463edfcd86fe916a72768b3ffc4d9dba616307a4e5979c9b">e_DESTROY</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbdlf_1_1Function__Rep.html#afb20d901efffa7a80463edfcd86fe916aa7c92e7b3f01adaa2ed204d4693d1a99">e_IN_PLACE_DETECTION</a> =  4
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7a92d1e4e811ee463233606df456496962">IS_NOT_ALLOCATOR</a> =  0, 
<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7a630a3988a198ed0bcee20c8c6336d4f0">IS_ALLOCATOR</a> =  1, 
<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7a1e5555546b0cdcb8d6ce81df17269bf3">IS_FUNCTION_POINTER</a> =  2, 
<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7add41b1bee900057e54cc594b8a79d2a8">IS_IN_PLACE_BITWISE_COPYABLE</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7aa960cfe94a63773dc5aca3d870600024">IS_OUT_OF_PLACE_BITWISE_COPYABLE</a> =  4, 
<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7ad22f38e1ba70bcae13db1f130b04386d">IS_IN_PLACE_BITWISE_MOVEABLE</a> =  5, 
<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7aa37891ef0ea5be284471fb7c8ed2d6ef">IS_IN_PLACE</a> =  6, 
<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7a6ed2c8b75ab44aa6394306bf39b172ba">IS_OUT_OF_PLACE</a> =  7, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7aae7070d90d0504b62705a26ddebe8897">IS_IN_PLACE_WITH_POINTER_SEMANTICS</a> =  8, 
<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7ae40dea28c9feb0911fef68e26c59ff83">IS_OUT_OF_PLACE_WITH_POINTER_SEMANTICS</a> =  9, 
<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7a4e042dc5b196c4b0ffb5da81e2c81344">IS_IN_PLACE_WITHOUT_POINTER_SEMANTICS</a> =  10, 
<a class="el" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7a0419076f59fa54b5609c1e4f2f49b5cc">IS_OUT_OF_PLACE_WITHOUT_POINTER_SEMANTICS</a> =  11
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bool(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#aa08addfb39d8c50c3f7384a779225f60">Manager</a> )(<a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> *rep, const void *source, <a class="el" href="classbdlf_1_1Function__Rep.html#afb20d901efffa7a80463edfcd86fe916">ManagerOpCode</a> opCode)</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a80e1ae09d18674bff9f80f1703e7df0a">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#ad6ba40deee1259b91e9b4e5fed82c984">Function_Rep</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#abbe26943a2d2b93ef6d8c0e974520e66">Function_Rep</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator, <a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_ALLOCATOR &gt; *, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#aa2bb1a2945c0a8f924516cda344ceffd">Function_Rep</a> (const FUNC &amp;func, <a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_FUNCTION_POINTER &gt; *, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a1e57068e7bba5b40b57f337406adf901">Function_Rep</a> (const FUNC &amp;func, <a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_IN_PLACE_BITWISE_COPYABLE &gt; *, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#ac012eedf821fdbbbbe7e01a2ac601293">Function_Rep</a> (const FUNC &amp;func, <a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_OUT_OF_PLACE_BITWISE_COPYABLE &gt; *, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#aead60cc8be88eab998980a7ea5d5620c">Function_Rep</a> (const FUNC &amp;func, <a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_IN_PLACE_BITWISE_MOVEABLE &gt; *, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#aa6661b435a4276ea0b97b24263e5a383">Function_Rep</a> (const FUNC &amp;func, <a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_IN_PLACE &gt; *, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a97a4d48aa546e3363bd906b1a8cba3f2">Function_Rep</a> (const FUNC &amp;func, <a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_OUT_OF_PLACE &gt; *, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a50f844777977fdeecbdd1b77f287ff4f">Function_Rep</a> (const <a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> &amp;original, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#afddaecb1706c43635f9c1a715a14ad3b">~Function_Rep</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a935521007d3e321593e8d6ac2c67dccc">operator=</a> (const <a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a661c8bfa940bfcf47a33e7c763c1deff">operator=</a> (const FUNC &amp;func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#aa1631a61edecac919ab3a024d571c64b">clear</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a2d9225a7c88d39c3c575cca7cf13fd69">load</a> (const FUNC &amp;func, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a87dba0c37c0c701f3a48199ca5203513">swap</a> (<a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a07b737ae1621f2f978c0af0706a8a295">transferTo</a> (<a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> *target)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">FUNC&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a4cf50b3cadfd008fedf31afabc509267">invocable</a> (<a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_FUNCTION_POINTER &gt; *) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">FUNC &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a345ee605eced867f0b08fe29f938a687">invocable</a> (<a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_IN_PLACE_WITH_POINTER_SEMANTICS &gt; *) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">FUNC &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a088a9a549a2a65e0db882b3305bb1e47">invocable</a> (<a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_OUT_OF_PLACE_WITH_POINTER_SEMANTICS &gt; *) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">FUNC *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a8d37f5839dae80d04cdd73597161714e">invocable</a> (<a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_IN_PLACE_WITHOUT_POINTER_SEMANTICS &gt; *) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">FUNC *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a13c93a32e6b5eb96beea67f98de81313">invocable</a> (<a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_OUT_OF_PLACE_WITHOUT_POINTER_SEMANTICS &gt; *) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a1a85d09029758efb3eb6162e2a78e9cd">getAllocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#ac835611b64f97813a1bc0051ccc82a37">isInplace</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a738379e180875b51137b741a60e81ff5">FunctionUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1Function__Rep.html#a9f22e3de2148c0ed380954d53874431a">Function_RepUtil</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This is a component-private class. Do not use. This class provides a representation for a <code><a class="el" href="classbdlf_1_1Function.html">Function</a></code> instance. For detailed design explanations, see the IMPLEMENTATION NOTES within the implementation file. For technical reasons, this class must be defined before <code><a class="el" href="classbdlf_1_1Function.html">Function</a></code> (although a mere forward declaration would be all right with most compilers, the Gnu compiler emits an error when trying to do syntactic checking on template code even though it does not instantiate template). </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aa08addfb39d8c50c3f7384a779225f60"></a><!-- doxytag: member="bdlf::Function_Rep::Manager" ref="aa08addfb39d8c50c3f7384a779225f60" args=")(Function_Rep *rep, const void *source, ManagerOpCode opCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="classbdlf_1_1Function__Rep.html#aa08addfb39d8c50c3f7384a779225f60">bdlf::Function_Rep::Manager</a>)(<a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> *rep, const void *source, <a class="el" href="classbdlf_1_1Function__Rep.html#afb20d901efffa7a80463edfcd86fe916">ManagerOpCode</a> opCode)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>Manager</code> is an alias for a pointer to a function that takes three arguments: the address of a <code><a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a></code> instance <code>rep</code>, the address of a <code>source</code> (for cloning, swapping, and transferring, interpreted differently according to the <code>opCode</code>), and a value <code>opCode</code> of the <code>ManagerOpcode</code> enumerated type, </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="afb20d901efffa7a80463edfcd86fe916"></a><!-- doxytag: member="bdlf::Function_Rep::ManagerOpCode" ref="afb20d901efffa7a80463edfcd86fe916" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbdlf_1_1Function__Rep.html#afb20d901efffa7a80463edfcd86fe916">bdlf::Function_Rep::ManagerOpCode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This enumeration provide values to identify operations to be performed by the manager. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afb20d901efffa7a80463edfcd86fe916a81fd782a73112995403917de0fcb6da5"></a><!-- doxytag: member="e_MOVE_CONSTRUCT" ref="afb20d901efffa7a80463edfcd86fe916a81fd782a73112995403917de0fcb6da5" args="" -->e_MOVE_CONSTRUCT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afb20d901efffa7a80463edfcd86fe916a7aea5be62a0e95122670366f2ae84b70"></a><!-- doxytag: member="e_COPY_CONSTRUCT" ref="afb20d901efffa7a80463edfcd86fe916a7aea5be62a0e95122670366f2ae84b70" args="" -->e_COPY_CONSTRUCT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afb20d901efffa7a80463edfcd86fe916a4f32369e63bb525e3c80d42d43c33199"></a><!-- doxytag: member="e_CONSTRUCT" ref="afb20d901efffa7a80463edfcd86fe916a4f32369e63bb525e3c80d42d43c33199" args="" -->e_CONSTRUCT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afb20d901efffa7a80463edfcd86fe916a72768b3ffc4d9dba616307a4e5979c9b"></a><!-- doxytag: member="e_DESTROY" ref="afb20d901efffa7a80463edfcd86fe916a72768b3ffc4d9dba616307a4e5979c9b" args="" -->e_DESTROY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afb20d901efffa7a80463edfcd86fe916aa7c92e7b3f01adaa2ed204d4693d1a99"></a><!-- doxytag: member="e_IN_PLACE_DETECTION" ref="afb20d901efffa7a80463edfcd86fe916aa7c92e7b3f01adaa2ed204d4693d1a99" args="" -->e_IN_PLACE_DETECTION</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7"></a><!-- doxytag: member="bdlf::Function_Rep::@197" ref="aad1a0c01e9f033efa1e00d5c880069d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Values used as tags for dispatching, enumerated for readability. Note that, although not all tags overlap, we give them all distinct values. Also note that the tag values are arbitrary. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7a92d1e4e811ee463233606df456496962"></a><!-- doxytag: member="IS_NOT_ALLOCATOR" ref="aad1a0c01e9f033efa1e00d5c880069d7a92d1e4e811ee463233606df456496962" args="" -->IS_NOT_ALLOCATOR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7a630a3988a198ed0bcee20c8c6336d4f0"></a><!-- doxytag: member="IS_ALLOCATOR" ref="aad1a0c01e9f033efa1e00d5c880069d7a630a3988a198ed0bcee20c8c6336d4f0" args="" -->IS_ALLOCATOR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7a1e5555546b0cdcb8d6ce81df17269bf3"></a><!-- doxytag: member="IS_FUNCTION_POINTER" ref="aad1a0c01e9f033efa1e00d5c880069d7a1e5555546b0cdcb8d6ce81df17269bf3" args="" -->IS_FUNCTION_POINTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7add41b1bee900057e54cc594b8a79d2a8"></a><!-- doxytag: member="IS_IN_PLACE_BITWISE_COPYABLE" ref="aad1a0c01e9f033efa1e00d5c880069d7add41b1bee900057e54cc594b8a79d2a8" args="" -->IS_IN_PLACE_BITWISE_COPYABLE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7aa960cfe94a63773dc5aca3d870600024"></a><!-- doxytag: member="IS_OUT_OF_PLACE_BITWISE_COPYABLE" ref="aad1a0c01e9f033efa1e00d5c880069d7aa960cfe94a63773dc5aca3d870600024" args="" -->IS_OUT_OF_PLACE_BITWISE_COPYABLE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7ad22f38e1ba70bcae13db1f130b04386d"></a><!-- doxytag: member="IS_IN_PLACE_BITWISE_MOVEABLE" ref="aad1a0c01e9f033efa1e00d5c880069d7ad22f38e1ba70bcae13db1f130b04386d" args="" -->IS_IN_PLACE_BITWISE_MOVEABLE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7aa37891ef0ea5be284471fb7c8ed2d6ef"></a><!-- doxytag: member="IS_IN_PLACE" ref="aad1a0c01e9f033efa1e00d5c880069d7aa37891ef0ea5be284471fb7c8ed2d6ef" args="" -->IS_IN_PLACE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7a6ed2c8b75ab44aa6394306bf39b172ba"></a><!-- doxytag: member="IS_OUT_OF_PLACE" ref="aad1a0c01e9f033efa1e00d5c880069d7a6ed2c8b75ab44aa6394306bf39b172ba" args="" -->IS_OUT_OF_PLACE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7aae7070d90d0504b62705a26ddebe8897"></a><!-- doxytag: member="IS_IN_PLACE_WITH_POINTER_SEMANTICS" ref="aad1a0c01e9f033efa1e00d5c880069d7aae7070d90d0504b62705a26ddebe8897" args="" -->IS_IN_PLACE_WITH_POINTER_SEMANTICS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7ae40dea28c9feb0911fef68e26c59ff83"></a><!-- doxytag: member="IS_OUT_OF_PLACE_WITH_POINTER_SEMANTICS" ref="aad1a0c01e9f033efa1e00d5c880069d7ae40dea28c9feb0911fef68e26c59ff83" args="" -->IS_OUT_OF_PLACE_WITH_POINTER_SEMANTICS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7a4e042dc5b196c4b0ffb5da81e2c81344"></a><!-- doxytag: member="IS_IN_PLACE_WITHOUT_POINTER_SEMANTICS" ref="aad1a0c01e9f033efa1e00d5c880069d7a4e042dc5b196c4b0ffb5da81e2c81344" args="" -->IS_IN_PLACE_WITHOUT_POINTER_SEMANTICS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad1a0c01e9f033efa1e00d5c880069d7a0419076f59fa54b5609c1e4f2f49b5cc"></a><!-- doxytag: member="IS_OUT_OF_PLACE_WITHOUT_POINTER_SEMANTICS" ref="aad1a0c01e9f033efa1e00d5c880069d7a0419076f59fa54b5609c1e4f2f49b5cc" args="" -->IS_OUT_OF_PLACE_WITHOUT_POINTER_SEMANTICS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad6ba40deee1259b91e9b4e5fed82c984"></a><!-- doxytag: member="bdlf::Function_Rep::Function_Rep" ref="ad6ba40deee1259b91e9b4e5fed82c984" args="(bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::Function_Rep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an unset functor using the optionally specified <code>allocator</code> to supply memory. If <code>allocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="abbe26943a2d2b93ef6d8c0e974520e66"></a><!-- doxytag: member="bdlf::Function_Rep::Function_Rep" ref="abbe26943a2d2b93ef6d8c0e974520e66" args="(bslma::Allocator *allocator, bslmf::Tag&lt; IS_ALLOCATOR &gt; *, bslma::Allocator *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::Function_Rep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_ALLOCATOR &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an unset functor representation using the specified <code>allocator</code> to supply memory. If <code>allocator</code> is 0, use the currently installed default allocator. The second and third are for overload resolution and are unused. </p>

</div>
</div>
<a class="anchor" id="aa2bb1a2945c0a8f924516cda344ceffd"></a><!-- doxytag: member="bdlf::Function_Rep::Function_Rep" ref="aa2bb1a2945c0a8f924516cda344ceffd" args="(const FUNC &amp;func, bslmf::Tag&lt; IS_FUNCTION_POINTER &gt; *, bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::Function_Rep </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_FUNCTION_POINTER &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e57068e7bba5b40b57f337406adf901"></a><!-- doxytag: member="bdlf::Function_Rep::Function_Rep" ref="a1e57068e7bba5b40b57f337406adf901" args="(const FUNC &amp;func, bslmf::Tag&lt; IS_IN_PLACE_BITWISE_COPYABLE &gt; *, bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::Function_Rep </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_IN_PLACE_BITWISE_COPYABLE &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac012eedf821fdbbbbe7e01a2ac601293"></a><!-- doxytag: member="bdlf::Function_Rep::Function_Rep" ref="ac012eedf821fdbbbbe7e01a2ac601293" args="(const FUNC &amp;func, bslmf::Tag&lt; IS_OUT_OF_PLACE_BITWISE_COPYABLE &gt; *, bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::Function_Rep </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_OUT_OF_PLACE_BITWISE_COPYABLE &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aead60cc8be88eab998980a7ea5d5620c"></a><!-- doxytag: member="bdlf::Function_Rep::Function_Rep" ref="aead60cc8be88eab998980a7ea5d5620c" args="(const FUNC &amp;func, bslmf::Tag&lt; IS_IN_PLACE_BITWISE_MOVEABLE &gt; *, bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::Function_Rep </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_IN_PLACE_BITWISE_MOVEABLE &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa6661b435a4276ea0b97b24263e5a383"></a><!-- doxytag: member="bdlf::Function_Rep::Function_Rep" ref="aa6661b435a4276ea0b97b24263e5a383" args="(const FUNC &amp;func, bslmf::Tag&lt; IS_IN_PLACE &gt; *, bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::Function_Rep </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_IN_PLACE &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a97a4d48aa546e3363bd906b1a8cba3f2"></a><!-- doxytag: member="bdlf::Function_Rep::Function_Rep" ref="a97a4d48aa546e3363bd906b1a8cba3f2" args="(const FUNC &amp;func, bslmf::Tag&lt; IS_OUT_OF_PLACE &gt; *, bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::Function_Rep </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_OUT_OF_PLACE &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a functor representation storing the specified <code>func</code> object of the parameterized <code>FUNC</code> type. Optionally specify <code>allocator</code> to supply memory. If <code>allocator</code> is 0, the currently installed default allocator is used. The second argument is for overload resolution and is not used. </p>

</div>
</div>
<a class="anchor" id="a50f844777977fdeecbdd1b77f287ff4f"></a><!-- doxytag: member="bdlf::Function_Rep::Function_Rep" ref="a50f844777977fdeecbdd1b77f287ff4f" args="(const Function_Rep &amp;original, bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::Function_Rep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a functor representation storing the same invocable as the specified <code>original</code> function representation. Optionally specify a <code>allocator</code> to supply memory. If <code>allocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="afddaecb1706c43635f9c1a715a14ad3b"></a><!-- doxytag: member="bdlf::Function_Rep::~Function_Rep" ref="afddaecb1706c43635f9c1a715a14ad3b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::~Function_Rep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this function object representation. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a80e1ae09d18674bff9f80f1703e7df0a"></a><!-- doxytag: member="bdlf::Function_Rep::BSLALG_DECLARE_NESTED_TRAITS" ref="a80e1ae09d18674bff9f80f1703e7df0a" args="(Function_Rep, bslalg::TypeTraitUsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlf::Function_Rep::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a935521007d3e321593e8d6ac2c67dccc"></a><!-- doxytag: member="bdlf::Function_Rep::operator=" ref="a935521007d3e321593e8d6ac2c67dccc" args="(const Function_Rep &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a>&amp; bdlf::Function_Rep::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this representation the functor representation stored in the specified <code>rhs</code> representation. </p>

</div>
</div>
<a class="anchor" id="a661c8bfa940bfcf47a33e7c763c1deff"></a><!-- doxytag: member="bdlf::Function_Rep::operator=" ref="a661c8bfa940bfcf47a33e7c763c1deff" args="(const FUNC &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a>&amp; bdlf::Function_Rep::operator= </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this representation the specified <code>func</code> invocable of the parameterized <code>FUNC</code> type. </p>

</div>
</div>
<a class="anchor" id="aa1631a61edecac919ab3a024d571c64b"></a><!-- doxytag: member="bdlf::Function_Rep::clear" ref="aa1631a61edecac919ab3a024d571c64b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlf::Function_Rep::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the invocable stored by this representation and reset this representation to an unset (i.e., null function pointer) state. </p>

</div>
</div>
<a class="anchor" id="a2d9225a7c88d39c3c575cca7cf13fd69"></a><!-- doxytag: member="bdlf::Function_Rep::load" ref="a2d9225a7c88d39c3c575cca7cf13fd69" args="(const FUNC &amp;func, bslma::Allocator *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a>&amp; bdlf::Function_Rep::load </td>
          <td>(</td>
          <td class="paramtype">const FUNC &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this representation the specified <code>func</code> invocable of the parameterized <code>FUNC</code> type, using the specified <code>allocator</code> to supply memory.</p>
<p>DEPRECATED: Use method <code><a class="el" href="classbdlf_1_1Function.html#a13f991eab0383721b38e617fab7117e2">Function::load</a></code> instead. </p>

</div>
</div>
<a class="anchor" id="a87dba0c37c0c701f3a48199ca5203513"></a><!-- doxytag: member="bdlf::Function_Rep::swap" ref="a87dba0c37c0c701f3a48199ca5203513" args="(Function_Rep &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlf::Function_Rep::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the invocable stored by this function object with that of the specified <code>other</code> modifiable function object representation. </p>

</div>
</div>
<a class="anchor" id="a07b737ae1621f2f978c0af0706a8a295"></a><!-- doxytag: member="bdlf::Function_Rep::transferTo" ref="a07b737ae1621f2f978c0af0706a8a295" args="(Function_Rep *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlf::Function_Rep::transferTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlf_1_1Function__Rep.html">Function_Rep</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfer the invocable stored by this functor to the specified <code>target</code> functor. The behavior is undefined if <code>target</code> points to this function object representation. Note that once transferred, this functor will be empty. </p>

</div>
</div>
<a class="anchor" id="a4cf50b3cadfd008fedf31afabc509267"></a><!-- doxytag: member="bdlf::Function_Rep::invocable" ref="a4cf50b3cadfd008fedf31afabc509267" args="(bslmf::Tag&lt; IS_FUNCTION_POINTER &gt; *) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FUNC bdlf::Function_Rep::invocable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_FUNCTION_POINTER &gt; *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the function pointer of the parameterized <code>FUNC</code> type stored in this representation. </p>

</div>
</div>
<a class="anchor" id="a345ee605eced867f0b08fe29f938a687"></a><!-- doxytag: member="bdlf::Function_Rep::invocable" ref="a345ee605eced867f0b08fe29f938a687" args="(bslmf::Tag&lt; IS_IN_PLACE_WITH_POINTER_SEMANTICS &gt; *) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FUNC&amp; bdlf::Function_Rep::invocable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_IN_PLACE_WITH_POINTER_SEMANTICS &gt; *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a088a9a549a2a65e0db882b3305bb1e47"></a><!-- doxytag: member="bdlf::Function_Rep::invocable" ref="a088a9a549a2a65e0db882b3305bb1e47" args="(bslmf::Tag&lt; IS_OUT_OF_PLACE_WITH_POINTER_SEMANTICS &gt; *) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FUNC&amp; bdlf::Function_Rep::invocable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_OUT_OF_PLACE_WITH_POINTER_SEMANTICS &gt; *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable invocable of the parameterized <code>FUNC</code> type stored in this representation. Note that <code>FUNC</code> is not a function pointer but otherwise has pointer semantics (e.g., managed or shared pointer). </p>

</div>
</div>
<a class="anchor" id="a8d37f5839dae80d04cdd73597161714e"></a><!-- doxytag: member="bdlf::Function_Rep::invocable" ref="a8d37f5839dae80d04cdd73597161714e" args="(bslmf::Tag&lt; IS_IN_PLACE_WITHOUT_POINTER_SEMANTICS &gt; *) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FUNC* bdlf::Function_Rep::invocable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_IN_PLACE_WITHOUT_POINTER_SEMANTICS &gt; *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a13c93a32e6b5eb96beea67f98de81313"></a><!-- doxytag: member="bdlf::Function_Rep::invocable" ref="a13c93a32e6b5eb96beea67f98de81313" args="(bslmf::Tag&lt; IS_OUT_OF_PLACE_WITHOUT_POINTER_SEMANTICS &gt; *) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FUNC* bdlf::Function_Rep::invocable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt; IS_OUT_OF_PLACE_WITHOUT_POINTER_SEMANTICS &gt; *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer to the invocable of the parameterized <code>FUNC</code> type stored in this representation. Note that <code>FUNC</code> does <em>not</em> have pointer semantics (e.g., functor instance). </p>

</div>
</div>
<a class="anchor" id="a1a85d09029758efb3eb6162e2a78e9cd"></a><!-- doxytag: member="bdlf::Function_Rep::getAllocator" ref="a1a85d09029758efb3eb6162e2a78e9cd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>* bdlf::Function_Rep::getAllocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> instance used to supply memory by this function object. </p>

</div>
</div>
<a class="anchor" id="ac835611b64f97813a1bc0051ccc82a37"></a><!-- doxytag: member="bdlf::Function_Rep::isInplace" ref="ac835611b64f97813a1bc0051ccc82a37" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlf::Function_Rep::isInplace </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this representation is an inplace, and <code>false</code> otherwise. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a738379e180875b51137b741a60e81ff5"></a><!-- doxytag: member="bdlf::Function_Rep::FunctionUtil" ref="a738379e180875b51137b741a60e81ff5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structbdlf_1_1FunctionUtil.html">FunctionUtil</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9f22e3de2148c0ed380954d53874431a"></a><!-- doxytag: member="bdlf::Function_Rep::Function_RepUtil" ref="a9f22e3de2148c0ed380954d53874431a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structbdlf_1_1Function__RepUtil.html">Function_RepUtil</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlf__function_8h_source.html">bdlf_function.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:44 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
