<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlde_utf8util Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlde_utf8util<br/>
<small>
[<a class="el" href="group__bdlde.html">Package bdlde</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide basic utilities for UTF-8 encodings.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlde.html">bdlde</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Validating Strings and Counting Unicode Characters</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide basic utilities for UTF-8 encodings. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlde_1_1Utf8Util.html">bdlde::Utf8Util</a> </td><td>namespace for utilities for UTF-8 encodings  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides, within the <code><a class="el" href="structbdlde_1_1Utf8Util.html">bdlde::Utf8Util</a></code> <code>struct</code>, a suite of static functions supporting UTF-8 encoded strings. Two interfaces are provided for each function, one where the length of the string (in <em>bytes</em>) is passed as a separate argument, and one where the string is passed as a null-terminated C-style string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A string is deemed to contain valid UTF-8 if it is compliant with RFC 3629, meaning that only 1-, 2-, 3-, and 4-byte sequences are allowed. Values above <code>U+10ffff</code> are also not allowed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Three types of functions are provided: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
<code>isValid</code>, which checks for validity, per RFC 3629, of a (candidate) UTF-8 string. "Overlong values", that is, values encoded in more bytes than necessary, are not tolerated; nor are "surrogate values", which are values in the range <code>[U+d800 .. U+dfff]</code>.  </li>
<li>
<code>advanceIfValid</code> and <code>advanceRaw</code>, which advance some number of UTF-8 characters, each of which may be encoded in multiple bytes in a UTF-8 string. <code>advanceRaw</code> assumes the string is valid UTF-8, while <code>advanceIfValid</code> checks the input for validity and stops advancing if a sequence is encountered that is not valid UTF-8.  </li>
<li>
<code>numCharactersIfValid</code> and <code>numCharactersRaw</code>, which return the length of a sequence of UTF-8 characters, each of which may be encoded in multiple bytes. Note that <code>numCharactersIfValid</code> both validates a (candidate) UTF-8 string and counts the number of UTF-8 characters that it contains.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Embedded null characters are allowed in strings that are accompanied by an explicit length argument. Naturally, null-terminated C-style strings cannot contain embedded null characters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The UTF-8 format is described in the RFC 3629 document at: <br/>
<br/>
<div class="fragment"><pre class="fragment">  http:<span class="comment">//tools.ietf.org/html/rfc3629</span>
</pre></div><br/>
<br/>
 and in Wikipedia at: <br/>
<br/>
<div class="fragment"><pre class="fragment">  http:<span class="comment">//en.wikipedia.org/wiki/Utf-8</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_validating_strings_and_counting_unicode_characters"></a> <a class="anchor" id="usage.example_1~3A_validating_strings_and_counting_unicode_characters"></a> <a class="anchor" id="description.usage.example_1~3A_validating_strings_and_counting_unicode_characters"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Validating Strings and Counting Unicode Characters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>For our usage example we will define some functions that can encode UTF-8, use them to build some strings, and observe how the functions defined in this class perform on them. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> utf8AppendOneByte(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *<span class="keywordtype">string</span>, <span class="keywordtype">int</span> value)
 Append the specified 1-byte UTF-8-encoded <span class="stringliteral">&#39;value&#39;</span> to the end of the
 specified <span class="stringliteral">&#39;string&#39;</span>.
  {
      assert(0 == (value &amp; ~0x7f));

      *<span class="keywordtype">string</span> += <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(value);
  }

  <span class="keywordtype">void</span> utf8AppendTwoBytes(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *<span class="keywordtype">string</span>, <span class="keywordtype">int</span> value)
 Append the specified 2-byte UTF-8-encoded <span class="stringliteral">&#39;value&#39;</span> to the end of the
 specified <span class="stringliteral">&#39;string&#39;</span>.
  {
      assert(0 == (value &amp; ~0x7ff));

      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[3];
      buf[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(((value &amp; 0x7c0) &gt;&gt; 6) | 0xc0);
      buf[1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>( (value &amp;  0x3f)       | 0x80);
      buf[2] = 0;

      *<span class="keywordtype">string</span> += <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(buf);
  }

  <span class="keywordtype">void</span> utf8AppendThreeBytes(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *<span class="keywordtype">string</span>, <span class="keywordtype">int</span> value)
 Append the specified 3-byte UTF-8-encoded <span class="stringliteral">&#39;value&#39;</span> to the end of the
 specified <span class="stringliteral">&#39;string&#39;</span>.
  {
      assert(0 == (value &amp; ~0xffff));

      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[4];
      buf[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(((value &amp; 0xf000) &gt;&gt; 12) | 0xe0);
      buf[1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(((value &amp;  0xfc0) &gt;&gt;  6) | 0x80);
      buf[2] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>( (value &amp;   0x3f)        | 0x80);
      buf[3] = 0;

      *<span class="keywordtype">string</span> += <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(buf);
  }

  <span class="keywordtype">void</span> utf8AppendFourBytes(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *<span class="keywordtype">string</span>, <span class="keywordtype">int</span> value)
 Append the specified 4-byte UTF-8-encoded <span class="stringliteral">&#39;value&#39;</span> to the end of the
 specified <span class="stringliteral">&#39;string&#39;</span>.
  {
      assert(static_cast&lt;unsigned&gt;(value) &lt;= 0x10ffff);

      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[5];
      buf[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(((value &amp; 0x1c0000) &gt;&gt; 18) | 0xf0);
      buf[1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(((value &amp;  0x3f000) &gt;&gt; 12) | 0x80);
      buf[2] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(((value &amp;    0xfc0) &gt;&gt;  6) | 0x80);
      buf[3] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>( (value &amp;     0x3f)        | 0x80);
      buf[4] = 0;

      *<span class="keywordtype">string</span> += <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(buf);
  }

  <span class="keywordtype">void</span> utf8Append(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *<span class="keywordtype">string</span>, <span class="keywordtype">int</span> value)
 Append the specified UTF-8-encoded <span class="stringliteral">&#39;value&#39;</span> in the minimum number of
 bytes to the end of the specified <span class="stringliteral">&#39;string&#39;</span>.
  {
      assert(static_cast&lt;unsigned&gt;(value) &lt;= 0x10ffff);

      <span class="keywordflow">if</span> (value &lt;= 0x7f) {
          utf8AppendOneByte(<span class="keywordtype">string</span>, value);
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">if</span> (value &lt;= 0x7ff) {
          utf8AppendTwoBytes(<span class="keywordtype">string</span>, value);
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">if</span> (value &lt;= 0xffff) {
          utf8AppendThreeBytes(<span class="keywordtype">string</span>, value);
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }

      utf8AppendFourBytes(<span class="keywordtype">string</span>, value);
  }
</pre></div><br/>
<br/>
 In this usage example, we will encode some UTF-8 strings and demonstrate which ones are valid and which ones are not. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we build an unquestionably valid UTF-8 string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> string;
  utf8Append(&amp;<span class="keywordtype">string</span>, 0xff00);
  utf8Append(&amp;<span class="keywordtype">string</span>, 0x856);
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;a&#39;</span>);
  utf8Append(&amp;<span class="keywordtype">string</span>, 0x1008aa);
  utf8Append(&amp;<span class="keywordtype">string</span>, 0xfff);
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;w&#39;</span>);
  utf8Append(&amp;<span class="keywordtype">string</span>, 0x1abcd);
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;.&#39;</span>);
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;\n&#39;</span>);
</pre></div><br/>
<br/>
 Next we check its validity and measure its length: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">true</span> == <a class="code" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(<span class="keywordtype">string</span>.data(), <span class="keywordtype">string</span>.length()));
  assert(<span class="keyword">true</span> == <a class="code" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(<span class="keywordtype">string</span>.c_str()));

  assert(   9 == <a class="code" href="structbdlde_1_1Utf8Util.html#a0f385dc7a5f49a68375d5c88326b8633">bdlde::Utf8Util::numCharactersRaw</a>(<span class="keywordtype">string</span>.data(),
                                                  <span class="keywordtype">string</span>.length()));
  assert(   9 == <a class="code" href="structbdlde_1_1Utf8Util.html#a0f385dc7a5f49a68375d5c88326b8633">bdlde::Utf8Util::numCharactersRaw</a>(<span class="keywordtype">string</span>.c_str()));
</pre></div><br/>
<br/>
 Next we encode a lone surrogate value, which is not allowed: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> stringWithSurrogate = string;
  utf8Append(&amp;stringWithSurrogate, 0xd8ab);

  assert(<span class="keyword">false</span> == <a class="code" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(stringWithSurrogate.<a class="code" href="group__bslstl__string.html#ga18243cc2ae7fe91eee167259e0a98d0a">data</a>(),
                                          stringWithSurrogate.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>()));
  assert(<span class="keyword">false</span> == <a class="code" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(stringWithSurrogate.<a class="code" href="group__bslstl__string.html#gae8d40a93bd2ebc7ae696c6f63b3995c9">c_str</a>()));
</pre></div><br/>
<br/>
 We cannot use <code>numCharactersRaw</code> to count the characters in <code>stringWithSurrogate</code>, since the behavior of that method is undefined unless the string is valid. Instead, the <code>numCharactersIfValid</code> method can be used on strings whose validity we are uncertain of: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> *invalidPosition = 0;

  assert(-1 == <a class="code" href="structbdlde_1_1Utf8Util.html#a94a75b5f8b9a539b4ffd7ca4b5cc8dbb">bdlde::Utf8Util::numCharactersIfValid</a>(
                                              &amp;invalidPosition,
                                              stringWithSurrogate.<a class="code" href="group__bslstl__string.html#ga18243cc2ae7fe91eee167259e0a98d0a">data</a>(),
                                              stringWithSurrogate.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>()));
  assert(invalidPosition == stringWithSurrogate.<a class="code" href="group__bslstl__string.html#ga18243cc2ae7fe91eee167259e0a98d0a">data</a>() + <span class="keywordtype">string</span>.length());

  invalidPosition = 0;  <span class="comment">// reset</span>

  assert(-1 == <a class="code" href="structbdlde_1_1Utf8Util.html#a94a75b5f8b9a539b4ffd7ca4b5cc8dbb">bdlde::Utf8Util::numCharactersIfValid</a>(
                                              &amp;invalidPosition,
                                              stringWithSurrogate.<a class="code" href="group__bslstl__string.html#gae8d40a93bd2ebc7ae696c6f63b3995c9">c_str</a>()));
  assert(invalidPosition == stringWithSurrogate.<a class="code" href="group__bslstl__string.html#ga18243cc2ae7fe91eee167259e0a98d0a">data</a>() + <span class="keywordtype">string</span>.length());
</pre></div><br/>
<br/>
 Next we encode 0, which is allowed. However, note that we cannot use any interfaces that take a null-terminated string for this case: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> stringWithNull = string;
  utf8AppendOneByte(&amp;stringWithNull, 0);
</pre></div><br/>
<br/>
 assert(true == <a class="el" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(stringWithNull.data(), stringWithNull.length())); </dd></dl>
<dl class="user"><dt><b></b></dt><dd>assert( 10 == <a class="el" href="structbdlde_1_1Utf8Util.html#a0f385dc7a5f49a68375d5c88326b8633">bdlde::Utf8Util::numCharactersRaw</a>(stringWithNull.data(), stringWithNull.length())); <br/>
<br/>
<div class="fragment"><pre class="fragment"> Finally, we encode <span class="stringliteral">&#39;0x61&#39;</span> (<span class="charliteral">&#39;a&#39;</span>) as an overlong value <span class="keyword">using</span> 2 bytes, which is
 not valid UTF-8 (since <span class="charliteral">&#39;a&#39;</span> can be <span class="stringliteral">&quot;encoded&quot;</span> in 1 byte):
</pre></div><br/>
<br/>
 bsl::string stringWithOverlong = string; utf8AppendTwoBytes(&amp;stringWithOverlong, <code>a</code>); </dd></dl>
<dl class="user"><dt><b></b></dt><dd>assert(false == <a class="el" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(stringWithOverlong.data(), stringWithOverlong.length())); assert(false == <a class="el" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(stringWithOverlong.c_str())); <br/>
<br/>
<div class="fragment"><pre class="fragment">/Example 2: Advancing Characters
/- - - - - - - - - - - - - - - -
 In <span class="keyword">this</span> example, we will re-use the <span class="stringliteral">&#39;utf8Append&#39;</span> function from Example 1 to
 build a <span class="keywordtype">string</span>.

 First, build the string, keeping track of how many bytes are in each Unicode
 character:
</pre></div><br/>
<br/>
 bsl::string string; utf8Append(&amp;string, 0xff00); // 3 bytes utf8Append(&amp;string, 0x1ff); // 2 bytes utf8Append(&amp;string, <code>a</code>); // 1 byte utf8Append(&amp;string, 0x1008aa); // 4 bytes utf8Append(&amp;string, 0x1abcd); // 4 bytes string += "\xe3\x8f\xfe"; // 3 bytes (invalid 3-byte sequence, // the first 2 bytes are valid but the // last continuation byte is invalid) utf8Append(&amp;string, <code>w</code>); // 1 byte utf8Append(&amp;string, <code>\n</code>); // 1 byte <br/>
<br/>
<div class="fragment"><pre class="fragment"> Then, declare a few variables we<span class="stringliteral">&#39;ll need:</span>
</pre></div><br/>
<br/>
 int rc, status; const char *result; const char *const start = string.c_str(); <br/>
<br/>
<div class="fragment"><pre class="fragment"> Next, <span class="keywordflow">try</span> advancing 2 characters, then 3, then 4, observing that the value
 returned is the number of Unicode characters advanced.  Note that since
 we<span class="stringliteral">&#39;re only advancing over valid UTF-8, we can use either &#39;</span>advanceRaw<span class="stringliteral">&#39; or</span>
<span class="stringliteral"> &#39;</span>advanceIfValid<span class="stringliteral">&#39;:</span>
</pre></div><br/>
<br/>
 rc = <a class="el" href="structbdlde_1_1Utf8Util.html#a9af7c2c03fed38ec465758168e2e69a8">bdlde::Utf8Util::advanceRaw</a>( &amp;result, start, 2); assert(2 == rc); assert(3 + 2 == result - start); </dd></dl>
<dl class="user"><dt><b></b></dt><dd>rc = <a class="el" href="structbdlde_1_1Utf8Util.html#a6069428a5d986426cb5c6874bbb2b415">bdlde::Utf8Util::advanceIfValid</a>(&amp;status, &amp;result, start, 2); assert(0 == status); assert(2 == rc); assert(3 + 2 == result - start); </dd></dl>
<dl class="user"><dt><b></b></dt><dd>rc = <a class="el" href="structbdlde_1_1Utf8Util.html#a9af7c2c03fed38ec465758168e2e69a8">bdlde::Utf8Util::advanceRaw</a>( &amp;result, start, 3); assert(0 == status); assert(3 == rc); assert(3 + 2 + 1 == result - start); </dd></dl>
<dl class="user"><dt><b></b></dt><dd>rc = <a class="el" href="structbdlde_1_1Utf8Util.html#a6069428a5d986426cb5c6874bbb2b415">bdlde::Utf8Util::advanceIfValid</a>(&amp;status, &amp;result, start, 3); assert(0 == status); assert(3 == rc); assert(3 + 2 + 1 == result - start); </dd></dl>
<dl class="user"><dt><b></b></dt><dd>rc = <a class="el" href="structbdlde_1_1Utf8Util.html#a9af7c2c03fed38ec465758168e2e69a8">bdlde::Utf8Util::advanceRaw</a>( &amp;result, start, 4); assert(4 == rc); assert(3 + 2 + 1 + 4 == result - start); </dd></dl>
<dl class="user"><dt><b></b></dt><dd>rc = <a class="el" href="structbdlde_1_1Utf8Util.html#a6069428a5d986426cb5c6874bbb2b415">bdlde::Utf8Util::advanceIfValid</a>(&amp;status, &amp;result, start, 4); assert(0 == status); assert(4 == rc); assert(3 + 2 + 1 + 4 == result - start); <br/>
<br/>
<div class="fragment"><pre class="fragment"> Then, <span class="keywordflow">try</span> advancing by more characters than are present <span class="keyword">using</span>
 <span class="stringliteral">&#39;advanceIfValid&#39;</span>, and wind up stopping when we encounter invalid input.  The
 behavior of <span class="stringliteral">&#39;advanceRaw&#39;</span> is undefined <span class="keywordflow">if</span> it is used on invalid input, so we
 cannot use it here.  Also note that we will stop at the beginning of the
 invalid Unicode character, and not at the first incorrect byte, which is two
 bytes later:
</pre></div><br/>
<br/>
 rc = <a class="el" href="structbdlde_1_1Utf8Util.html#a6069428a5d986426cb5c6874bbb2b415">bdlde::Utf8Util::advanceIfValid</a>(&amp;status, &amp;result, start, INT_MAX); assert(0 != status); assert(5 == rc); assert(3 + 2 + 1 + 4 + 4 == result - start); assert(static_cast&lt;int&gt;(string.length()) &gt; result - start); <br/>
<br/>
<div class="fragment"><pre class="fragment"> Now, doctor the <span class="keywordtype">string</span> to replace the invalid character with a valid one, so
 the <span class="keywordtype">string</span> is entirely correct UTF-8:
.
  <span class="keywordtype">string</span>[3 + 2 + 1 + 4 + 4 + 2] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0x8a);
</pre></div><br/>
<br/>
 Finally, advance using both functions by more characters than are in the string and in both cases wind up at the end of the string. Note that <code>advanceIfValid</code> does not return an error (non-zero) value to <code>status</code> when it encounters the end of the string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a9af7c2c03fed38ec465758168e2e69a8">bdlde::Utf8Util::advanceRaw</a>(             &amp;result, start, INT_MAX);
  assert(8 == rc);
  assert(3 + 2 + 1 + 4 + 4 + 3 + 1 + 1     == result - start);
  assert(static_cast&lt;int&gt;(<span class="keywordtype">string</span>.length()) == result - start);

  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a6069428a5d986426cb5c6874bbb2b415">bdlde::Utf8Util::advanceIfValid</a>(&amp;status, &amp;result, start, INT_MAX);
  assert(0 == status);
  assert(8 == rc);
  assert(3 + 2 + 1 + 4 + 4 + 3 + 1 + 1     == result - start);
  assert(static_cast&lt;int&gt;(<span class="keywordtype">string</span>.length()) == result - start);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:42 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
