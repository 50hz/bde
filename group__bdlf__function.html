<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlf_function Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<h1>Component bdlf_function<br/>
<small>
[<a class="el" href="group__bdlf.html">Package bdlf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a signature-specific function object (functor).  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlf.html">bdlf</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__function.html#ga27f0d87a81f3f18127432173f6f10fe1">BDLF_FUNCTION_DECLARE_INVOKER_TAG</a>(FUNC)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__function.html#ga95e2e3bb8519b9ca37bce4b6a00d0618">BDLF_FUNCTION_INVOKER</a>(FUNC, rep)&nbsp;&nbsp;&nbsp;(rep-&gt;invocable&lt;FUNC&gt;((<a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt;INVOKER_TAG&gt; *)0))</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Basic Usage</a> <ul>
<li>
<a href="#3.1.1">Declaring a Functor</a> </li>
<li>
<a href="#3.1.2">Initializing a Functor</a> </li>
<li>
<a href="#3.1.3">Invoking a Functor</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Functors and Memory Allocation</a> <ul>
<li>
<a href="#3.2.1">Specific Guarantees</a> </li>
<li>
<a href="#3.2.2">Design Rationale</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a signature-specific function object (functor). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a> </td><td>signature-specific function object (functor)  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlf__memfn.html" title="Provide member function pointer wrapper classes and utility.">Component bdlf_memfn</a>, <a class="el" href="group__bdlf__bind.html" title="Provide a signature-specific function object (functor).">Component bdlf_bind</a>, bdlcf_bindutil </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a polymorphic function object (functor) <code><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a></code> that returns an arbitrary result type and accepts up to fourteen arguments of arbitrary types. A "functor" is similar to a C/C++ function pointer, but unlike function pointers, functors can be used to invoke any object that can be syntactically invoked as a function. Functors are generally used as callback functions or to avoid templatizing a function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="basic_usage"></a> <a class="anchor" id="description.basic_usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Basic Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Before documenting the finer points of the <code>bdlf_function</code> component, we offer the following examples to illustrate the various steps of using functors. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="declaring_a_functor"></a> <a class="anchor" id="basic_usage.declaring_a_functor"></a> <a class="anchor" id="description.basic_usage.declaring_a_functor"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Declaring a Functor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a></code> functor takes a single C-style function pointer template argument that describes the prototype of the functor. For example, the declaration of a functor that returns <code>void</code> and accepts no arguments, would look as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlf_1_1Function.html">bdlf::Function&lt; void (*)() &gt;</a> voidFunctor;
</pre></div><br/>
<br/>
 To declare a functor that returns <code>int</code> and accepts two <code>double</code> arguments: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlf_1_1Function.html">bdlf::Function&lt; int (*)(double, double) &gt;</a> intFunctor;
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="initializing_a_functor"></a> <a class="anchor" id="basic_usage.initializing_a_functor"></a> <a class="anchor" id="description.basic_usage.initializing_a_functor"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Initializing a Functor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If there exists an object <code>F</code> for which the expression <code>F(X1, ..., XN)</code> is legal, then <code>F</code> can be represented by a functor that accepts <code>N</code> arguments of types compatible with <code>X1</code>, ..., <code>XN</code>, respectively. For example, given the following <code>Functor</code> definition: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Function.html">bdlf::Function&lt;void(*)(int, const char*)&gt;</a> Functor;
</pre></div><br/>
<br/>
 any of the following object may be assigned to a <code>Functor</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> freeFunction(<span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span>*);

  <span class="keywordtype">int</span> freeFunctionNonVoid(<span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span>*);

  <span class="keywordtype">void</span> freeFunctionCompatibleArgs(<span class="keywordtype">double</span>, <span class="keyword">const</span> <span class="keywordtype">char</span>*);

  <span class="keyword">class </span>FunctionObject {
      <span class="comment">// ....</span>
    <span class="keyword">public</span>:
      <span class="keywordtype">void</span> operator() (<span class="keywordtype">int</span> , <span class="keyword">const</span> <span class="keywordtype">char</span>*);
  };

  <span class="keyword">class </span>FunctionObject2 {
      <span class="comment">// ....</span>
    <span class="keyword">public</span>:
      <span class="keywordtype">void</span> operator() (<span class="keywordtype">int</span> , <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>);
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="invoking_a_functor"></a> <a class="anchor" id="basic_usage.invoking_a_functor"></a> <a class="anchor" id="description.basic_usage.invoking_a_functor"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Invoking a Functor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Once initialized, the functor objects can be invoked in the same way as regular functions: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> usageExampleTest1()
  {
     Functor func;

     func = &amp;freeFunction;
     func(100, <span class="stringliteral">&quot;It works&quot;</span>);

     func = &amp;freeFunctionNonVoid;
     func(100, <span class="stringliteral">&quot;Still works - &#39;int&#39; result discarded&quot;</span>);

     func = &amp;freeFunctionCompatibleArgs;
     func(100, <span class="stringliteral">&quot;Works too - 100 promoted to (double)100.0&quot;</span>);

     FunctionObject o;
     func = o;
     func(100, <span class="stringliteral">&quot;This works too!!!!!&quot;</span>);

     FunctionObject2 o2;
     func = o2;
     func(100, <span class="stringliteral">&quot;This also works - &#39;bsl::string&#39; temporary created!&quot;</span>);
  }
</pre></div><br/>
<br/>
 Note that member function pointers cannot be directly invoked by a functor since for a given pointer <code>memFnPtr</code> to a member function on an object <code>o</code>, the invocation syntax is <code>o.*memFnPtr(...)</code> which is syntactically different from <code>memFnPtr(o, ...)</code>. The <code>bdlf_memfn</code> and <code>bdlf_bind</code> components provide adapters to allow member function pointers to be invoked as functors, either taking the object on which to invoke the member function as parameter, or storing a reference to it and adding it implicitly to the function call. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="functors_and_memory_allocation"></a> <a class="anchor" id="description.functors_and_memory_allocation"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Functors and Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a></code> uses and follows the <code>bdema</code> allocator model. However, the implementation exposes the details of an important memory optimization with specific guarantees. It is important to expose this implementation detail both for testing and for its proper use in an environment where memory allocation is a restricted call. We detail on the specific guarantees and on the rationale for exposing this implementation detail. The rationale section can be skipped in a first reading. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="specific_guarantees"></a> <a class="anchor" id="functors_and_memory_allocation.specific_guarantees"></a> <a class="anchor" id="description.functors_and_memory_allocation.specific_guarantees"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Specific Guarantees: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Functors are guaranteed <em>not</em> to trigger a memory allocation when created with or assigned from the following invocables: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
a free function pointer or pointer to a static member function,  </li>
<li>
a member function pointer together with a pointer to an object, (i.e., <code><a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a></code> objects created by <code><a class="el" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a></code> function, as illustrated at the end of the subsection 'Initializing a functor' in the usage section below),  </li>
<li>
another object (e.g., user-defined object, or functor created by one of the <code>bdefu::Vfunc*make*</code> factory methods) whose size is at most <code><a class="el" href="structbdlf_1_1FunctionUtil.html#ae48e1e3dc2e9e79560291d4917a91796a3c6a30f3d87bdd9b1f74bacbedbd49bf">bdlf::FunctionUtil::MAX_INPLACE_OBJECT_SIZE</a></code>.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that "size" in item number 3 refers to the return value of the <code>sizeof</code> operator on the object. Also note that the constant <code><a class="el" href="structbdlf_1_1FunctionUtil.html#ae48e1e3dc2e9e79560291d4917a91796a3c6a30f3d87bdd9b1f74bacbedbd49bf">bdlf::FunctionUtil::MAX_INPLACE_OBJECT_SIZE</a></code> is platform- and implementation-dependent, but it is guaranteed to be at least as large one member function pointer and one additional pointer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Functors are guaranteed to <em>trigger</em> a memory allocation when constructed with or assigned from an invokable object which is a user-defined class of size larger than <code><a class="el" href="structbdlf_1_1FunctionUtil.html#ae48e1e3dc2e9e79560291d4917a91796a3c6a30f3d87bdd9b1f74bacbedbd49bf">bdlf::FunctionUtil::MAX_INPLACE_OBJECT_SIZE</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, once a <code><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a></code> object has been constructed, it is possible to check if it was created in-place or not, by using the <code>isInplace</code> method. A compile-time check is also provided by the meta-function <code>bdlf::FunctionUtil::isInplace</code>. See the illustration of design rationale number two in the next section for an example of how this assertion can be useful. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="design_rationale"></a> <a class="anchor" id="functors_and_memory_allocation.design_rationale"></a> <a class="anchor" id="description.functors_and_memory_allocation.design_rationale"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Design Rationale: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are two reasons why this component exposes the memory allocation algorithm: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
In order to enable proper testing of the <code>bdema</code>-allocator model in components that use <code><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a></code> objects.  </li>
<li>
In order to avoid defining an allocator in environments where default-allocated memory should not be allowed, and yet be able to certify that the default allocator is not used.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>To illustrate reason number one, imagine testing a component that defines a class that uses a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> and stores function objects. According to the <code>bdema</code> allocation model, this class should propagate its allocator to all its members. In order to test this, typically a test allocator is passed to the class at construction and a default allocator guard is used to assert that no default allocation was performed. If the class fails to implement the proper allocation model, but also uses a function object whose size is at most <code><a class="el" href="structbdlf_1_1FunctionUtil.html#ae48e1e3dc2e9e79560291d4917a91796a3c6a30f3d87bdd9b1f74bacbedbd49bf">bdlf::FunctionUtil::MAX_INPLACE_OBJECT_SIZE</a></code>, the test driver will fail to expose the violation of the allocation model. In order to expose it, the test sequence must make sure that it creates its function objects from an invokable object whose size is larger than <code><a class="el" href="structbdlf_1_1FunctionUtil.html#ae48e1e3dc2e9e79560291d4917a91796a3c6a30f3d87bdd9b1f74bacbedbd49bf">bdlf::FunctionUtil::MAX_INPLACE_OBJECT_SIZE</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To illustrate reason number two, suppose that long-term (i.e., non-temporary) memory should never be allocated for reasons touching the environment in which the program will be run. A run-time check can be put wherever a <code><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a></code> object is created without an allocator (perhaps because it would be too costly to create an allocator just for that function object, or perhaps because the function object has static storage and could not be created with an allocator), as in the following example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Function.html">bdlf::Function&lt;int (*)(void *)&gt;</a>  MyCallback;

  <span class="keyword">static</span> MyCallback currentCallback = 0;

  <span class="keywordtype">void</span> scheduleCallback(<span class="keyword">const</span> MyCallback&amp; func) {
      assert(!currentCallback);
      currentCallback = func;

      <span class="comment">// Note: this function may run in malloc-restricted environment, so we</span>
      <span class="comment">// much make sure we did not accidentally use the default allocator.</span>
      assert(currentCallback.isInplace());
  }
</pre></div><br/>
<br/>
 The last line makes sure that an allocator was not used for the assignment of the function object. Note that the invokable itself may have triggered a memory allocation for its own members, which will not be detected by this assert; in that case it is safer to use a default-allocator guard (see the <code>bslma_defaultallocatorguard</code> component). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Basic usage examples were given in the section <code>Basic usage</code> earlier in this documentation. We complement this by an illustration of a typical use of <code><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For small interfaces, functors can often be used in place of virtual functions, reducing the need for inheritance. Take for example a class, <code>MessageHandler</code> that reads data from a stream, and invokes a user-supplied handler for each message extracted from the stream. Without functors, a inheritance hierarchy of message handler needs to be created. However, with <code><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a></code>, any function or functor that matches the required signature can be passed in. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following implementation, we pass either a message handler function object or a free function to the constructor of <code>MessageProcessor</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Message {
      <span class="comment">// ...</span>
  };

  <span class="keyword">class </span>MessageProcessor {
      <span class="comment">// This class reads data from a stream, then invokes a user-supplied</span>
      <span class="comment">// handler for each message extracted from the stream.</span>

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Function.html">bdlf::Function&lt;void(*)(const Message&amp;)&gt;</a> MessageHandler;

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      MessageHandler d_handler;

      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">int</span> extractMessage(Message *messageBuffer, bsl::istream&amp; stream);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      MessageProcessor(MessageHandler handler);

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> processMessages(bsl::istream&amp; stream);
  };

  <span class="comment">// PRIVATE MANIPULATORS</span>
  <span class="keywordtype">int</span> MessageProcessor::extractMessage(Message *messageBuffer,
                                       bsl::istream&amp; stream)
  {
      <span class="comment">// ...</span>
      <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// CREATORS</span>
  MessageProcessor::MessageProcessor(MessageHandler handler)
  : d_handler(handler)
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> MessageProcessor::processMessages(bsl::istream&amp; stream)
  {
      <span class="keywordtype">int</span> ret = 1;
      <span class="keywordflow">do</span> {
          Message msg;
          ret = extractMessage(&amp;msg, stream);
          <span class="keywordflow">if</span> (!ret) {
              d_handler(msg);
          }
      } <span class="keywordflow">while</span> (!ret);
  }
</pre></div><br/>
<br/>
 The two concrete classes implementing the <code>MessageHandler</code> protocol can now provide their functionality within a function object or in free functions, as desired: <br/>
<br/>
<div class="fragment"><pre class="fragment">                       <span class="comment">// ==================</span>
                       <span class="comment">// class PrintHandler</span>
                       <span class="comment">// ==================</span>

  <span class="keyword">class </span>PrintHandler {

      <span class="comment">// DATA</span>
      bsl::ostream *d_stream_p;  <span class="comment">// held, not owned</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      printHandler(bsl::ostream&amp; stream);

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> Message &amp;msg);
  }

  <span class="comment">// CREATORS</span>
  printHandler::printHandler(bsl::ostream&amp; stream)
  : d_stream_p(&amp;stream)
  {
  }

  <span class="comment">// MANIPULATORS</span>
  printHandler::operator() ((<span class="keyword">const</span> Message&amp; msg) {
      (*d_stream_p) &lt;&lt; msg &lt;&lt; bsl::endl;
  }

                       <span class="comment">// ====================</span>
                       <span class="comment">// function freeHandler</span>
                       <span class="comment">// ====================</span>

  <span class="keywordtype">void</span> freeHandler(<span class="keyword">const</span> Message &amp;)
  {
     <span class="comment">// Implementation elided.</span>
     <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 It is now possible to store either message handler (of different types, and not connected by any inheritance relationship) into the polymorphic <code><a class="el" href="classbdlf_1_1Function.html">bdlf::Function</a></code> handler: <br/>
<br/>
<div class="fragment"><pre class="fragment">                      <span class="comment">// ========================</span>
                      <span class="comment">// function processMessages</span>
                      <span class="comment">// ========================</span>

  <span class="keywordtype">void</span> processMessages(<span class="keywordtype">bool</span> printOnly, bsl::istream&amp; stream)
  {
      MessageProcessor::MessageHandler handler;
      <span class="keywordflow">if</span> (printOnly) {
          handler = PrintHandler(stream);
      }
      <span class="keywordflow">else</span> {
          handler = &amp;processMessage;
      }
      MessageProcessor processor(handler);
      processor.processMessages(stream);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga27f0d87a81f3f18127432173f6f10fe1"></a><!-- doxytag: member="bdlf_function.h::BDLF_FUNCTION_DECLARE_INVOKER_TAG" ref="ga27f0d87a81f3f18127432173f6f10fe1" args="(FUNC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BDLF_FUNCTION_DECLARE_INVOKER_TAG</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">FUNC</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">enum</span> {                                                                    \
        IS_IN_PLACE           = <a class="code" href="structbdlf_1_1FunctionUtil_1_1IsInplace.html">bdlf::FunctionUtil::IsInplace&lt;FUNC&gt;::VALUE</a>    \
      , HAS_POINTER_SEMANTICS = <a class="code" href="structbslalg_1_1HasTrait.html">bslalg::HasTrait</a>&lt;FUNC,                        \
                                 <a class="code" href="structbslalg_1_1TypeTraitHasPointerSemantics.html">bslalg::TypeTraitHasPointerSemantics</a>&gt;::VALUE \
      , INVOKER_TAG           = <a class="code" href="structbslmf_1_1IsFunctionPointer.html">bslmf::IsFunctionPointer&lt;FUNC&gt;::VALUE</a>         \
                              ? (int)<a class="code" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7a1e5555546b0cdcb8d6ce81df17269bf3">bdlf::Function_Rep::IS_FUNCTION_POINTER</a>  \
                              : IS_IN_PLACE ? (HAS_POINTER_SEMANTICS          \
         ? (<span class="keywordtype">int</span>)<a class="code" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7aae7070d90d0504b62705a26ddebe8897">bdlf::Function_Rep::IS_IN_PLACE_WITH_POINTER_SEMANTICS</a>        \
         : (int)<a class="code" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7a4e042dc5b196c4b0ffb5da81e2c81344">bdlf::Function_Rep::IS_IN_PLACE_WITHOUT_POINTER_SEMANTICS</a>)    \
                                            : (HAS_POINTER_SEMANTICS          \
         ? (int)<a class="code" href="classbdlf_1_1Function__Rep.html#aad1a0c01e9f033efa1e00d5c880069d7ae40dea28c9feb0911fef68e26c59ff83">bdlf::Function_Rep::IS_OUT_OF_PLACE_WITH_POINTER_SEMANTICS</a>    \
         : (<span class="keywordtype">int</span>)bdlf::Function_Rep::IS_OUT_OF_PLACE_WITHOUT_POINTER_SEMANTICS)\
    };
</pre></div>
<p>Referenced by <a class="el" href="structbdlf_1_1Function__Invoker_3_0114_00_01void_00_01ARGS_01_4.html#a8a2d2baf66a96046508979f829bcbe52">bdlf::Function_Invoker&lt; 14, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0114_00_01RET_00_01ARGS_01_4.html#aefbea9133a9d217be2d3faea89a122c4">bdlf::Function_Invoker&lt; 14, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0113_00_01void_00_01ARGS_01_4.html#a26a008757225143a5f1384d33b3e8e0c">bdlf::Function_Invoker&lt; 13, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0113_00_01RET_00_01ARGS_01_4.html#a9862e3299c91f9e5218434c48b788d7b">bdlf::Function_Invoker&lt; 13, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0112_00_01void_00_01ARGS_01_4.html#a9ecc0074297934c55a8009f7d1dd8f79">bdlf::Function_Invoker&lt; 12, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0112_00_01RET_00_01ARGS_01_4.html#a0a410e735aa0b1529976f13b165dd60f">bdlf::Function_Invoker&lt; 12, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0111_00_01void_00_01ARGS_01_4.html#abef0626e515ad4dc52894fd84ec2d3e3">bdlf::Function_Invoker&lt; 11, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0111_00_01RET_00_01ARGS_01_4.html#acad8b4e5c1f20ced5684a6a20e5dfdcf">bdlf::Function_Invoker&lt; 11, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0110_00_01void_00_01ARGS_01_4.html#ac881e56deee20d06c3295976d3d0f007">bdlf::Function_Invoker&lt; 10, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0110_00_01RET_00_01ARGS_01_4.html#a0df01bc636165ff24fafb99075c1d64a">bdlf::Function_Invoker&lt; 10, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_019_00_01void_00_01ARGS_01_4.html#a081cb773b8c13c16258c10e3574a074c">bdlf::Function_Invoker&lt; 9, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_019_00_01RET_00_01ARGS_01_4.html#acca8a433c61aa93f1e8a53dd26b31789">bdlf::Function_Invoker&lt; 9, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_018_00_01void_00_01ARGS_01_4.html#afe4d32bb58b78ff73db185d4b93215a9">bdlf::Function_Invoker&lt; 8, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_018_00_01RET_00_01ARGS_01_4.html#a8996411b83acabf297a37fca80e5bf5d">bdlf::Function_Invoker&lt; 8, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_017_00_01void_00_01ARGS_01_4.html#a0754edf1905cbe01a12a437bbdc87e75">bdlf::Function_Invoker&lt; 7, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_017_00_01RET_00_01ARGS_01_4.html#ac6d3c84f452e7018a402adad5fe6ac19">bdlf::Function_Invoker&lt; 7, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_016_00_01void_00_01ARGS_01_4.html#ae2721fb961ef439651b09f23b813ee3c">bdlf::Function_Invoker&lt; 6, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_016_00_01RET_00_01ARGS_01_4.html#a8c726cd34fa3cd20fb966fd786c6edb9">bdlf::Function_Invoker&lt; 6, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_015_00_01void_00_01ARGS_01_4.html#a42d5885f417accf5e2a811429aec1c61">bdlf::Function_Invoker&lt; 5, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_015_00_01RET_00_01ARGS_01_4.html#ae39a88432b731e5adb85cd1e8845edb6">bdlf::Function_Invoker&lt; 5, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_014_00_01void_00_01ARGS_01_4.html#a5d5d2cc0e45050c1c19921d6494ac3eb">bdlf::Function_Invoker&lt; 4, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_014_00_01RET_00_01ARGS_01_4.html#a47a91970e2bf43631bc3775e17908d90">bdlf::Function_Invoker&lt; 4, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_013_00_01void_00_01ARGS_01_4.html#adadd96c569ae1172aea2805b7118f538">bdlf::Function_Invoker&lt; 3, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_013_00_01RET_00_01ARGS_01_4.html#a86ea6f8c3b19fab9ee311c48dd18aa45">bdlf::Function_Invoker&lt; 3, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_012_00_01void_00_01ARGS_01_4.html#a72e6f1bdc1578da79926da31516f9c40">bdlf::Function_Invoker&lt; 2, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_012_00_01RET_00_01ARGS_01_4.html#ab9b8769172bb63e193da198ce69dd63a">bdlf::Function_Invoker&lt; 2, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_011_00_01void_00_01ARGS_01_4.html#abd668c1046889aa6abe668cf0e891721">bdlf::Function_Invoker&lt; 1, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_011_00_01RET_00_01ARGS_01_4.html#a1f949576e30e290c28f84b2e59c4a7b4">bdlf::Function_Invoker&lt; 1, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_010_00_01void_00_01ARGS_01_4.html#a22f05dfaedad2fb6fe24582241ab9956">bdlf::Function_Invoker&lt; 0, void, ARGS &gt;::invoke()</a>, and <a class="el" href="structbdlf_1_1Function__Invoker_3_010_00_01RET_00_01ARGS_01_4.html#a657fc27a8f0e23c5a062085af381733c">bdlf::Function_Invoker&lt; 0, RET, ARGS &gt;::invoke()</a>.</p>

</div>
</div>
<a class="anchor" id="ga95e2e3bb8519b9ca37bce4b6a00d0618"></a><!-- doxytag: member="bdlf_function.h::BDLF_FUNCTION_INVOKER" ref="ga95e2e3bb8519b9ca37bce4b6a00d0618" args="(FUNC, rep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BDLF_FUNCTION_INVOKER</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">FUNC, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">rep</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>&nbsp;&nbsp;&nbsp;(rep-&gt;invocable&lt;FUNC&gt;((<a class="el" href="structbslmf_1_1Tag.html">bslmf::Tag</a>&lt;INVOKER_TAG&gt; *)0))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="structbdlf_1_1Function__Invoker_3_0114_00_01void_00_01ARGS_01_4.html#a8a2d2baf66a96046508979f829bcbe52">bdlf::Function_Invoker&lt; 14, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0114_00_01RET_00_01ARGS_01_4.html#aefbea9133a9d217be2d3faea89a122c4">bdlf::Function_Invoker&lt; 14, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0113_00_01void_00_01ARGS_01_4.html#a26a008757225143a5f1384d33b3e8e0c">bdlf::Function_Invoker&lt; 13, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0113_00_01RET_00_01ARGS_01_4.html#a9862e3299c91f9e5218434c48b788d7b">bdlf::Function_Invoker&lt; 13, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0112_00_01void_00_01ARGS_01_4.html#a9ecc0074297934c55a8009f7d1dd8f79">bdlf::Function_Invoker&lt; 12, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0112_00_01RET_00_01ARGS_01_4.html#a0a410e735aa0b1529976f13b165dd60f">bdlf::Function_Invoker&lt; 12, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0111_00_01void_00_01ARGS_01_4.html#abef0626e515ad4dc52894fd84ec2d3e3">bdlf::Function_Invoker&lt; 11, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0111_00_01RET_00_01ARGS_01_4.html#acad8b4e5c1f20ced5684a6a20e5dfdcf">bdlf::Function_Invoker&lt; 11, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0110_00_01void_00_01ARGS_01_4.html#ac881e56deee20d06c3295976d3d0f007">bdlf::Function_Invoker&lt; 10, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_0110_00_01RET_00_01ARGS_01_4.html#a0df01bc636165ff24fafb99075c1d64a">bdlf::Function_Invoker&lt; 10, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_019_00_01void_00_01ARGS_01_4.html#a081cb773b8c13c16258c10e3574a074c">bdlf::Function_Invoker&lt; 9, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_019_00_01RET_00_01ARGS_01_4.html#acca8a433c61aa93f1e8a53dd26b31789">bdlf::Function_Invoker&lt; 9, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_018_00_01void_00_01ARGS_01_4.html#afe4d32bb58b78ff73db185d4b93215a9">bdlf::Function_Invoker&lt; 8, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_018_00_01RET_00_01ARGS_01_4.html#a8996411b83acabf297a37fca80e5bf5d">bdlf::Function_Invoker&lt; 8, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_017_00_01void_00_01ARGS_01_4.html#a0754edf1905cbe01a12a437bbdc87e75">bdlf::Function_Invoker&lt; 7, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_017_00_01RET_00_01ARGS_01_4.html#ac6d3c84f452e7018a402adad5fe6ac19">bdlf::Function_Invoker&lt; 7, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_016_00_01void_00_01ARGS_01_4.html#ae2721fb961ef439651b09f23b813ee3c">bdlf::Function_Invoker&lt; 6, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_016_00_01RET_00_01ARGS_01_4.html#a8c726cd34fa3cd20fb966fd786c6edb9">bdlf::Function_Invoker&lt; 6, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_015_00_01void_00_01ARGS_01_4.html#a42d5885f417accf5e2a811429aec1c61">bdlf::Function_Invoker&lt; 5, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_015_00_01RET_00_01ARGS_01_4.html#ae39a88432b731e5adb85cd1e8845edb6">bdlf::Function_Invoker&lt; 5, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_014_00_01void_00_01ARGS_01_4.html#a5d5d2cc0e45050c1c19921d6494ac3eb">bdlf::Function_Invoker&lt; 4, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_014_00_01RET_00_01ARGS_01_4.html#a47a91970e2bf43631bc3775e17908d90">bdlf::Function_Invoker&lt; 4, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_013_00_01void_00_01ARGS_01_4.html#adadd96c569ae1172aea2805b7118f538">bdlf::Function_Invoker&lt; 3, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_013_00_01RET_00_01ARGS_01_4.html#a86ea6f8c3b19fab9ee311c48dd18aa45">bdlf::Function_Invoker&lt; 3, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_012_00_01void_00_01ARGS_01_4.html#a72e6f1bdc1578da79926da31516f9c40">bdlf::Function_Invoker&lt; 2, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_012_00_01RET_00_01ARGS_01_4.html#ab9b8769172bb63e193da198ce69dd63a">bdlf::Function_Invoker&lt; 2, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_011_00_01void_00_01ARGS_01_4.html#abd668c1046889aa6abe668cf0e891721">bdlf::Function_Invoker&lt; 1, void, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_011_00_01RET_00_01ARGS_01_4.html#a1f949576e30e290c28f84b2e59c4a7b4">bdlf::Function_Invoker&lt; 1, RET, ARGS &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Function__Invoker_3_010_00_01void_00_01ARGS_01_4.html#a22f05dfaedad2fb6fe24582241ab9956">bdlf::Function_Invoker&lt; 0, void, ARGS &gt;::invoke()</a>, and <a class="el" href="structbdlf_1_1Function__Invoker_3_010_00_01RET_00_01ARGS_01_4.html#a657fc27a8f0e23c5a062085af381733c">bdlf::Function_Invoker&lt; 0, RET, ARGS &gt;::invoke()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
