<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslma Package</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Components</a>  </div>
  <div class="headertitle">
<h1>Package bslma<br/>
<small>
[<a class="el" href="group__bsl.html">Package Group bsl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide allocators, guards, and other memory-management tools.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Components</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__allocator.html">Component bslma_allocator</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a pure abstract interface for memory-allocation mechanisms. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__autodeallocator.html">Component bslma_autodeallocator</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a range proctor to managed a block of memory. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__autodestructor.html">Component bslma_autodestructor</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a range proctor to manage an array of objects. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__autorawdeleter.html">Component bslma_autorawdeleter</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a range proctor to manage a sequence objects. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__deallocatorguard.html">Component bslma_deallocatorguard</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a guard to unconditionally manage a block of memory. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__deallocatorproctor.html">Component bslma_deallocatorproctor</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a proctor to conditionally manage a block memory. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__default.html">Component bslma_default</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide utilities to set/fetch the default and global allocators. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__defaultallocatorguard.html">Component bslma_defaultallocatorguard</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide scoped guard to temporarily change the default allocator. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__deleterhelper.html">Component bslma_deleterhelper</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide namespace for functions used to delete objects. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__destructorguard.html">Component bslma_destructorguard</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a guard to unconditionally manage an object. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__destructorproctor.html">Component bslma_destructorproctor</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a proctor to conditionally manage an object. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__mallocfreeallocator.html">Component bslma_mallocfreeallocator</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide malloc/free adaptor to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__newdeleteallocator.html">Component bslma_newdeleteallocator</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide singleton new/delete adaptor to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__rawdeleterguard.html">Component bslma_rawdeleterguard</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a guard to unconditionally manage an object. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__rawdeleterproctor.html">Component bslma_rawdeleterproctor</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a proctor to conditionally manage an object. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__testallocator.html">Component bslma_testallocator</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide instrumented malloc/free allocator to track memory usage. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__testallocatorexception.html">Component bslma_testallocatorexception</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide an exception class for memory allocation operations. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__testallocatormonitor.html">Component bslma_testallocatormonitor</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a mechanism to summarize <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code> object use. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__usesbslmaallocator.html">Component bslma_usesbslmaallocator</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provide a metafunction that indicates the use of bslma allocators. </p>
</td></tr>
</p>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">MNEMONIC: Basic Standard Library Memory Allocators (bslma)</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Hierarchical Synopsis</a> </li>
<li>
<a href="#3.2">Component Synopsis</a> </li>
<li>
<a href="#3.3">Component Overview</a> <ul>
<li>
<a href="#3.3.1"><code>bslma_allocator</code></a> </li>
<li>
<a href="#3.3.2"><code>bslma_autodeallocator</code></a> </li>
<li>
<a href="#3.3.3"><code>bslma_autodestructor</code></a> </li>
<li>
<a href="#3.3.4"><code>bslma_autorawdeleter</code></a> </li>
<li>
<a href="#3.3.5"><code>bslma_deallocatorguard</code></a> </li>
<li>
<a href="#3.3.6"><code>bslma_deallocatorproctor</code></a> </li>
<li>
<a href="#3.3.7"><code>bslma_default</code></a> </li>
<li>
<a href="#3.3.8"><code>bslma_defaultallocatorguard</code></a> </li>
<li>
<a href="#3.3.9"><code>bslma_deleterhelper</code></a> </li>
<li>
<a href="#3.3.10"><code>bslma_destructorguard</code></a> </li>
<li>
<a href="#3.3.11"><code>bslma_destructorproctor</code></a> </li>
<li>
<a href="#3.3.12"><code>bslma_mallocfreeallocator</code></a> </li>
<li>
<a href="#3.3.13"><code>bslma_managedallocator</code></a> </li>
<li>
<a href="#3.3.14"><code>bslma_newdeleteallocator</code></a> </li>
<li>
<a href="#3.3.15"><code>bslma_rawdeleterguard</code></a> </li>
<li>
<a href="#3.3.16"><code>bslma_rawdeleterproctor</code></a> </li>
<li>
<a href="#3.3.17"><code>bslma_testallocator</code></a> </li>
<li>
<a href="#3.3.18"><code>bslma_testallocatorexception</code></a> </li>
<li>
<a href="#3.3.19"><code>bslma_testallocatormonitor</code></a> </li>
</ul>
</li>
<li>
<a href="#3.4">Allocators and Other Memory-Dispensing Mechanisms</a> </li>
<li>
<a href="#3.5">Alignment</a> </li>
<li>
<a href="#3.6">Deallocation</a> </li>
<li>
<a href="#3.7">Type and Origination</a> </li>
<li>
<a href="#3.8">The Default Allocator</a> </li>
<li>
<a href="#3.9">Interaction With Other Packages</a> </li>
<li>
<a href="#3.10">Usage</a> <ul>
<li>
<a href="#3.10.1">Example 1: <code>bslma_SequentialAllocator</code> for a Database Driver</a> </li>
<li>
<a href="#3.10.2">Example 2: Sketch Use of <code>bslma::BufferAllocator</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide allocators, guards, and other memory-management tools. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="mnemonic"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>MNEMONIC: Basic Standard Library Memory Allocators (bslma): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bslma</code> package provides an allocator protocol (i.e., a pure abstract interface) and a variety of concrete allocators derived from this protocol, as well as other memory-dispensing mechanisms and various guard constructs to prevent loss in case of exceptions. In addition, <code>bslma</code> also provides a mechanism for installing a "default allocator" that will then be visible to all BDE and BDE-compliant code throughout that process. If this mechanism is not invoked explicitly, then an allocator that uses global <code>new</code> and <code>delete</code> is the BDE default allocator. This topic is discussed in more detail below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hierarchical_synopsis"></a> <a class="anchor" id="description.hierarchical_synopsis"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Hierarchical Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bslma</code> package currently has 19 components having 6 levels of physical dependency. The table below shows the hierarchical ordering of the components. The order of components within each level is not architecturally significant, just alphabetical. <br/>
<br/>
<div class="fragment"><pre class="fragment">  6. bslma_autorawdeleter
     bslma_destructorproctor
     bslma_testallocatormonitor

  5. bslma_autodeallocator
     bslma_autodestructor
     bslma_deallocatorguard
     bslma_deallocatorproctor
     bslma_defaultallocatorguard
     bslma_destructorguard
     bslma_rawdeleterguard
     bslma_rawdeleterproctor

  4. bslma_default
     bslma_testallocator

  3. bslma_mallocfreeallocator
     bslma_newdeleteallocator
     bslma_testallocatorexception
     bslma_usesbslmaallocator

  2. bslma_allocator

  1. bslma_deleterhelper
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="component_synopsis"></a> <a class="anchor" id="description.component_synopsis"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Component Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_allocator</code>: <br/>
 Provide a pure abstract interface for memory-allocation mechanisms.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_autodeallocator</code>: <br/>
 Provide a range proctor to managed a block of memory.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_autodestructor</code>: <br/>
 Provide a range proctor to manage an array of objects.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_autorawdeleter</code>: <br/>
 Provide a range proctor to manage a sequence objects.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_deallocatorguard</code>: <br/>
 Provide a guard to unconditionally manage a block of memory.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_deallocatorproctor</code>: <br/>
 Provide a proctor to conditionally manage a block memory.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_default</code>: <br/>
 Provide utilities to set/fetch the default and global allocators.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_defaultallocatorguard</code>: <br/>
 Provide scoped guard to temporarily change the default allocator.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_deleterhelper</code>: <br/>
 Provide namespace for functions used to delete objects.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_destructorguard</code>: <br/>
 Provide a guard to unconditionally manage an object.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_destructorproctor</code>: <br/>
 Provide a proctor to conditionally manage an object.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_mallocfreeallocator</code>: <br/>
 Provide malloc/free adaptor to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_newdeleteallocator</code>: <br/>
 Provide singleton new/delete adaptor to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_rawdeleterguard</code>: <br/>
 Provide a guard to unconditionally manage an object.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_rawdeleterproctor</code>: <br/>
 Provide a proctor to conditionally manage an object.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_testallocator</code>: <br/>
 Provide instrumented malloc/free allocator to track memory usage.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_testallocatorexception</code>: <br/>
 Provide an exception class for memory allocation operations.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_testallocatormonitor</code>: <br/>
 Provide a mechanism to summarize <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code> object use.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bslma_usesbslmaallocator</code>: <br/>
 Provide a metafunction that indicates the use of bslma allocators</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="component_overview"></a> <a class="anchor" id="description.component_overview"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Component Overview: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section summarizes the components that are available in <code>bslma</code>. Subsequent sections provide more detail on component selection, performance, and usage. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_allocator"></a> <a class="anchor" id="component_overview.bslma_allocator"></a> <a class="anchor" id="description.component_overview.bslma_allocator"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma_allocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_allocator</code> defines a protocol (i.e., an abstract base class) requiring the following interface: <code>allocate</code> for memory allocation, and <code>deallocate</code>, for deallocation of individual allocated memory blocks. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_autodeallocator"></a> <a class="anchor" id="component_overview.bslma_autodeallocator"></a> <a class="anchor" id="description.component_overview.bslma_autodeallocator"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>bslma_autodeallocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_autodeallocator</code> provides a "scoped guard" mechanism that assumes ownership responsibility for a block of memory obtained from an allocator having a <code>deallocate</code> method; the memory is deallocated when the scoped guard goes out of scope, unless the memory is explicitly released. This proctor mechanism is useful in guarding against memory leaks, e.g., when additional allocations may throw an exception. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_autodestructor"></a> <a class="anchor" id="component_overview.bslma_autodestructor"></a> <a class="anchor" id="description.component_overview.bslma_autodestructor"></a> <a class="anchor" id="3.3.3"></a> </dd></dl>
<dl class="user"><dt><b>bslma_autodestructor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_autodestructor</code> provides a "scoped guard" mechanism that assumes ownership of a sequence of objects that reside on contiguous memory that is <em>not</em> managed by the guard. The objects are destroyed when the guard goes out of scope unless the proctored objects are explicitly released from management. Instance methods allow for adding objects to and removing objects from the sequence of managed objects. This proctor mechanism is useful in guarding against memory leaks, e.g., when additional allocations may throw an exception. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_autorawdeleter"></a> <a class="anchor" id="component_overview.bslma_autorawdeleter"></a> <a class="anchor" id="description.component_overview.bslma_autorawdeleter"></a> <a class="anchor" id="3.3.4"></a> </dd></dl>
<dl class="user"><dt><b>bslma_autorawdeleter: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_autorawdeleter</code> provides a range proctor class template to manage a sequence of (otherwise-unmanaged) objects of parameterized <code>TYPE</code> supplied at construction. If not explicitly released, the sequence of managed objects are deleted automatically when the range proctor goes out of scope by iterating over each object, first calling the (managed) object's destructor, and then freeing its memory footprint by invoking the <code>deallocate</code> method of an allocator (or pool) of parameterized <code>ALLOCATOR</code> type also supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_deallocatorguard"></a> <a class="anchor" id="component_overview.bslma_deallocatorguard"></a> <a class="anchor" id="description.component_overview.bslma_deallocatorguard"></a> <a class="anchor" id="3.3.5"></a> </dd></dl>
<dl class="user"><dt><b>bslma_deallocatorguard: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_deallocatorguard</code> provides a guard class template to unconditionally manage a block of (otherwise-unmanaged) memory. The managed memory is deallocated automatically when the guard object goes out of scope using the <code>deallocate</code> method of the parameterized <code>ALLOCATOR</code> (allocator or pool) supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_deallocatorproctor"></a> <a class="anchor" id="component_overview.bslma_deallocatorproctor"></a> <a class="anchor" id="description.component_overview.bslma_deallocatorproctor"></a> <a class="anchor" id="3.3.6"></a> </dd></dl>
<dl class="user"><dt><b>bslma_deallocatorproctor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_deallocatorproctor</code> provides a proctor class template to conditionally manage a block of (otherwise-unmanaged) memory. If not explicitly released, the managed memory is deallocated automatically when the proctor object goes out of scope by freeing the memory using the parameterized <code>ALLOCATOR</code> (allocator or pool) supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_default"></a> <a class="anchor" id="component_overview.bslma_default"></a> <a class="anchor" id="description.component_overview.bslma_default"></a> <a class="anchor" id="3.3.7"></a> </dd></dl>
<dl class="user"><dt><b>bslma_default: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_default</code> provides a namespace in which to declare a default allocator that can be used by any component requiring an allocator in cases where the client does not supply one, and two functions relating to this default allocator: a "setter", and a "getter". </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_defaultallocatorguard"></a> <a class="anchor" id="component_overview.bslma_defaultallocatorguard"></a> <a class="anchor" id="description.component_overview.bslma_defaultallocatorguard"></a> <a class="anchor" id="3.3.8"></a> </dd></dl>
<dl class="user"><dt><b>bslma_defaultallocatorguard: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_defaultallocatorguard</code> provides a mechanism to enable safe, temporary replacement of the default allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_deleterhelper"></a> <a class="anchor" id="component_overview.bslma_deleterhelper"></a> <a class="anchor" id="description.component_overview.bslma_deleterhelper"></a> <a class="anchor" id="3.3.9"></a> </dd></dl>
<dl class="user"><dt><b>bslma_deleterhelper: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_deleterhelper</code> provides non-primitive procedures used to delete objects of parameterized <code>TYPE</code> by first calling the destructor of the object, and then freeing the memory footprint of the object using a parameterized <code>ALLOCATOR</code> (allocator or pool) provided as a second argument. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_destructorguard"></a> <a class="anchor" id="component_overview.bslma_destructorguard"></a> <a class="anchor" id="description.component_overview.bslma_destructorguard"></a> <a class="anchor" id="3.3.10"></a> </dd></dl>
<dl class="user"><dt><b>bslma_destructorguard: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_destructorguard</code> provides a guard class template to unconditionally manage an (otherwise-unmanaged) object of parameterized <code>TYPE</code> supplied at construction. The managed object is destroyed automatically when the guard object goes out of scope by calling the (managed) object's destructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_destructorproctor"></a> <a class="anchor" id="component_overview.bslma_destructorproctor"></a> <a class="anchor" id="description.component_overview.bslma_destructorproctor"></a> <a class="anchor" id="3.3.11"></a> </dd></dl>
<dl class="user"><dt><b>bslma_destructorproctor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_destructorproctor</code> provides a proctor class template to conditionally manage an (otherwise-unmanaged) object of parameterized <code>TYPE</code> supplied at construction. If not explicitly released, the managed object is destroyed automatically when the proctor object goes out of scope by calling the object's destructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_mallocfreeallocator"></a> <a class="anchor" id="component_overview.bslma_mallocfreeallocator"></a> <a class="anchor" id="description.component_overview.bslma_mallocfreeallocator"></a> <a class="anchor" id="3.3.12"></a> </dd></dl>
<dl class="user"><dt><b>bslma_mallocfreeallocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_mallocfreeallocator</code> provides a wrapper around <code>std::malloc</code> and <code>std::free</code> that adheres to the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol (i.e., provides <code>allocate</code> and <code>deallocate</code> functions). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_managedallocator"></a> <a class="anchor" id="component_overview.bslma_managedallocator"></a> <a class="anchor" id="description.component_overview.bslma_managedallocator"></a> <a class="anchor" id="3.3.13"></a> </dd></dl>
<dl class="user"><dt><b>bslma_managedallocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_managedallocator</code> defines a protocol that extends the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol with a <code>release</code> function. <code>release</code> indicates that all memory allocated since the previous <code>release</code> call is to be deallocated. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_newdeleteallocator"></a> <a class="anchor" id="component_overview.bslma_newdeleteallocator"></a> <a class="anchor" id="description.component_overview.bslma_newdeleteallocator"></a> <a class="anchor" id="3.3.14"></a> </dd></dl>
<dl class="user"><dt><b>bslma_newdeleteallocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_newdeleteallocator</code> provides a wrapper around <code>operator new</code> and <code>operator delete</code> that adheres to the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol (i.e., provides an <code>allocate</code> function and a <code>deallocate</code> function). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_rawdeleterguard"></a> <a class="anchor" id="component_overview.bslma_rawdeleterguard"></a> <a class="anchor" id="description.component_overview.bslma_rawdeleterguard"></a> <a class="anchor" id="3.3.15"></a> </dd></dl>
<dl class="user"><dt><b>bslma_rawdeleterguard: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_rawdeleterguard</code> provides a guard class template to unconditionally manage an (otherwise-unmanaged) object of parameterized <code>TYPE</code> supplied at construction. The managed object is deleted automatically when the guard object goes out of scope by first calling the (managed) object's destructor, and then freeing the memory using the parameterized <code>ALLOCATOR</code> (allocator or pool) also supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_rawdeleterproctor"></a> <a class="anchor" id="component_overview.bslma_rawdeleterproctor"></a> <a class="anchor" id="description.component_overview.bslma_rawdeleterproctor"></a> <a class="anchor" id="3.3.16"></a> </dd></dl>
<dl class="user"><dt><b>bslma_rawdeleterproctor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_rawdeleterproctor</code> provides a proctor class template to conditionally manage an (otherwise-unmanaged) object of parameterized <code>TYPE</code> supplied at construction. If not explicitly released, the managed object is deleted automatically when the proctor object goes out of scope by first calling the (managed) object's destructor, and then freeing the memory using the parameterized <code>ALLOCATOR</code> (allocator or pool) also supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_testallocator"></a> <a class="anchor" id="component_overview.bslma_testallocator"></a> <a class="anchor" id="description.component_overview.bslma_testallocator"></a> <a class="anchor" id="3.3.17"></a> </dd></dl>
<dl class="user"><dt><b>bslma_testallocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_testallocator</code> provides an instrumented memory allocator drawing on <code>malloc</code>-provided memory, that can be exceedingly useful during development. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_testallocatorexception"></a> <a class="anchor" id="component_overview.bslma_testallocatorexception"></a> <a class="anchor" id="description.component_overview.bslma_testallocatorexception"></a> <a class="anchor" id="3.3.18"></a> </dd></dl>
<dl class="user"><dt><b>bslma_testallocatorexception: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_testallocatorexception</code> defines an exception object for use in testing exceptions during memory allocations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma_testallocatormonitor"></a> <a class="anchor" id="component_overview.bslma_testallocatormonitor"></a> <a class="anchor" id="description.component_overview.bslma_testallocatormonitor"></a> <a class="anchor" id="3.3.19"></a> </dd></dl>
<dl class="user"><dt><b>bslma_testallocatormonitor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslma_testallocatormonitor</code> provides a "monitor", a mechanism class, that allows concise tests of state change (or lack of change) in the test allocator provided at the monitor's construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="allocators_and_other_memory-dispensing_mechanisms"></a> <a class="anchor" id="description.allocators_and_other_memory-dispensing_mechanisms"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Allocators and Other Memory-Dispensing Mechanisms: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An allocator is a memory manager that derives from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol and provides an <code>allocate</code> method for obtaining memory, and a <code>deallocate</code> method for returning memory (to the allocator). <code>bslma</code> also provides many memory-dispensing mechanisms that also provide an <code>allocate</code> and a <code>deallocate</code> method, but these memory managers are not properly referred to as "allocators", since we reserve the term "allocator" for concrete memory dispensers that actually derive from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> and are therefore usable anywhere that a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> is specified. Objects that dispense memory but that are not actually "allocators" are sometimes called "end-point allocators", and may offer performance advantages to certain users. Choosing an allocation mechanisms is complex, and many factors will influence the decision. The discussions here are aimed at shedding light on this important selection process. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Characteristics differentiating among <code>bslma</code> memory-allocation objects <em>in</em> <em>general</em> are: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
Whether or not the object is a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>.  </li>
<li>
Whether or not the allocator supports memory reuse.  </li>
<li>
Whether allocation requests consume the exact amount of memory requested, an additive number of additional bytes, or a non-additive number of additional bytes (e.g., the smallest power of two that can satisfy the request).  </li>
<li>
Whether allocation requests consume the exact amount of memory requested,  </li>
<li>
Whether or not the allocator supports multi-threading.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>All <code>bslma</code> allocators are thread-safe but not thread-enabled (see the <code>bcema</code> package-level documentation for information on thread-enabled allocators). In BDE terminology, a class is thread-safe if distinct threads can safely access <em>different</em> <em>instances</em> of that class simultaneously; a class is thread-enabled if distinct threads can safely access <em>the</em> <em>same</em> <em>instance</em> of that class simultaneously. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <em>BDE</em> allocators have two more differentiating properties. First, whether the allocator is intended to be part of a chain (or other grouping) of allocators, or is an "end-point" allocator. The former kind support the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol. "End-point" allocators, such as <code>bslma::SequentialPool</code>, are designed for minimizing the runtime overhead of allocation and deallocation on a call-by-call basis. This essentially corresponds to inlining the <code>allocate</code> and <code>deallocate</code> methods. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Supporting a common protocol (the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol) allows passing conformant allocators to BDE (and other) objects requiring an allocator at construction. Support of this common protocol also facilitates grouping the memory used by an object into one allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The second differentiating property is whether the allocator is a "managed" or "unmanaged" allocator. Unmanaged allocators require every allocation to be matched by a deallocation, similar to <code>malloc</code> and <code>free</code>, or <code>new</code> and <code>delete</code>. They also allow for simultaneous deallocation of all memory with one call to <code>release</code>. This <code>release</code> optimization can provide significant performance improvements if the only system resource held by an object (and all the objects it manages) is memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The BDE libraries use allocators with all classes requiring dynamic memory allocation, allowing clients to fine-tune memory-related performance characteristics by replacing the established defaults with client-chosen alternatives. Because the protocol is public, clients can even write their own, customized implementations, and use those. But none of these actions are required. BDE components all work with a (preset) default allocator, and clients without special requirements need never concern themselves with allocators. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Some other concerns regarding memory allocation are described next. The discussion here broadens beyond allocators (strictly speaking, subtypes of <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>) to include both allocators and the other memory managers, i.e., the memory pools. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="alignment"></a> <a class="anchor" id="description.alignment"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Alignment: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Alignment of an <em>address</em> in memory refers to the relative position of that address with respect to specific (hardware-imposed) boundaries within the memory space. Any one address can be said to be on a one-byte boundary, a two-byte boundary, a four-byte boundary, or an eight-byte boundary. (Clearly, this sequence can be extended, but, as of this writing, boundaries beyond eight-byte boundaries are not relevant for these discussions on any hardware platform of interest. In particular, "alignment" as we are using the term here does not deal with page boundaries or other larger memory structures, although these considerations are important elsewhere.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In general, we also speak about the alignment of (the <em>first</em> <em>byte</em> of) an entity (e.g., an <code>int</code>, a <code>double</code>, or a pointer) whose size is not necessarily one byte. As a practical matter, for each entity separately, some alignments are "safe" and some are not. By "not safe" we mean that, for most platforms (e.g., all of our Unix machines), attempting to access an entity at an address that is not safely aligned for that entity will cause a bus error, crashing the program on the spot. In the very best case, the access will incur a performance penalty as the memory is shifted appropriately between its initial address and its target address (e.g., a register). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The BDE memory managers provide three kinds of alignment: NATURAL, MAXIMAL, and BYTE -- but note that BYTE alignment is also referred to as "no alignment" or "none" in this document, since every address is aligned to <em>some</em> byte. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A C/C++ variable is "naturally aligned" if its size divides the numerical value of its address. An address is "maximally aligned" if it can serve as a naturally-aligned address no matter what type of object might be stored there. That is, it meets the alignment requirements of the type with the maximally restrictive needs. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, on a platform where <code>int</code> is 4 bytes, a variable such as <br/>
<br/>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">int</span> index;
</pre></div><br/>
<br/>
 is naturally aligned if the compiler assigns it an address such as <br/>
<br/>
<div class="fragment"><pre class="fragment">     0x00A3920
</pre></div><br/>
<br/>
 because 4 divides 66984 (the decimal equivalent of A3920). The variable would not be naturally aligned were the compiler to place it at <br/>
<br/>
<div class="fragment"><pre class="fragment">     0x00A3921
</pre></div><br/>
<br/>
 because 4 does not divide 66985. An address whose numerical value is divisible by 8 is generally naturally aligned for any possible type, and so meets the definition of MAXIMUM alignment. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Accessing data stored at an aligned address is <em>faster</em> on Intel platforms and <em>required</em> on almost all Unix platforms. Reading (or writing) a C/C++ variable at an unaligned address will cause a Bus Error on these Unix platforms, and thus crash the program. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Normally, programmers need not worry about alignment for dynamically allocated memory. The runtime system's <code>new</code> (or <code>malloc</code>, for C) automatically return memory blocks beginning at maximally-aligned addresses (the C++ standard requires it of <code>new</code>). The <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> does the same. Certain <code>bslma</code> allocators and pools, however, return arbitrary addresses. IT IS THEREFORE UNSAFE TO USE THOSE ALLOCATORS for storing <code>int</code>s, <code>double</code>s, <code>struct</code>s, and other non-'char' types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A number of the <code>bslma</code> memory managers <em>do</em> align. They do so by: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
Inferring the needed alignment from the size of the request, and returning a NATURALLY aligned address for it, or  </li>
<li>
Returning a chunk of memory aligned to an address that would serve as a properly-aligned address for a type with the largest possible alignment needs, i.e., returning a MAXIMALLY aligned address.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The cost of obtaining aligned addresses is twofold: an increase in the memory used (allocators returning aligned addresses do so by skipping bytes that could otherwise be used, so as to return an appropriate address), and additional computation time to calculate the needed alignment and subsequent offset. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="deallocation"></a> <a class="anchor" id="description.deallocation"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Deallocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Some of the managers do not deallocate individual items. (The <code>deallocate</code> function is almost always provided, but in these managers it performs no action.) Such managers provide a <code>release</code> function instead, which relinquishes <em>all</em> memory allocated by that manager since the previous <code>release</code> call. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="type_and_origination"></a> <a class="anchor" id="description.type_and_origination"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Type and Origination: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Most managers provide variable-sized, untyped (i.e., <code>void *</code>) memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The different components manage memory in different ways, but they necessarily <em>obtain</em> the memory that they manage from one of the two usual sources: the heap or the stack. The <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> is hard-coded to obtain memory from the heap -- its underlying source is <code>operator new</code>. The <code>bslma::BufferAllocator</code> is the best-suited manager for working with stack memory -- its source is a client-supplied array, a <code>char *</code> plus length indicator. All the other memory managers must be passed a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>- derived type in their constructor, which they then use as the source of the memory they will manage. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The managers are compared in the following tables: <br/>
<br/>
<div class="fragment"><pre class="fragment">                              PERFORMANCE CHARACTERISTICS

               Memory Source     Allocation   Alignment     Out-of-memory
                                 Cost OVER                     Handling
                                 Underlying
                                  Source
            +-----------------+--------------+---------+----------------------+
Infrequent- | Client-provided | O(1) node    |   None  |       None           |
Delete      |   allocator     | creation &amp;   |         |                      |
Block List  |                 | insertion    |         |                      |
            +-----------------+--------------+---------+----------------------+

            +-----------------+--------------+---------+----------------------+
Sequential  |Infrequent-Delete|  negative*   |NATURAL, |       None           |
Pool        |  Block List     |              | MAXIMAL |                      |
            +-----------------+--------------+---------+----------------------+

            +-----------------+--------------+---------+----------------------+
Buffer      | Client-provided |  vfn + O(1)  |NATURAL, | Client callback, or  |
Allocator   | buffer (a &#39;<span class="keywordtype">char</span>&#39;|align. comp. &amp;| MAXIMAL | return value 0 if no |
            | pointer)        |cursor maint. |         | callback registered  |
            +-----------------+--------------+---------+----------------------+
Sequential  | Sequential Pool | 0 if inlined,|NATURAL  |       None           |
Allocator   |                 |else vfn call+|         |                      |
            +-----------------+--------------+---------+----------------------+
NewDelete   | &#39;operator new&#39;  | 0 if inlined,|MAXIMAL  | Return value 0       |
Allocator   |                 |else vfn call+|         |                      |
            +-----------------+--------------+---------+----------------------+
Test        | &#39;malloc&#39;        |     N/A      |   None  | Return value 0       |
Allocator   |                 |              |         |                      |
            +-----------------+--------------+---------+----------------------+
</pre></div><br/>
<br/>
 * Pooling potentially speeds up allocation over the allocation done by some underlying source, by (sub)allocating (and reclaiming) memory more quickly than the underlying source itself does. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>+ Calling <code>allocate</code> directly through an item of this (derived) type <em>will</em> result in an inlined function. But calling through a base-class pointer, e.g., <br/>
<br/>
<div class="fragment"><pre class="fragment">  bslma::SequentialAllocator  sqa;
  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>           *allocPtr = &amp;sqa;
  allocPtr-&gt;<a class="code" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">allocate</a>();
</pre></div><br/>
<br/>
 will incur the overhead of a virtual function call. <br/>
<br/>
<div class="fragment"><pre class="fragment">                                     SEMANTICS

                      Deallocation             Storage Facility
                  +-----------------------+-------------------------+
Infrequent Delete | Single and all items  | Untyped, varying sizes  |
Block List        |                       |                         |
                  +-----------------------+-------------------------+
                  +-----------------------+-------------------------+
Sequential Pool   | All items only        | Untyped, varying sizes  |
                  +-----------------------+-------------------------+

                  +-----------------------+-------------------------+
Buffered          | Single items only     | Untyped, varying sizes  |
Allocator         |                       |                         |
                  +-----------------------+-------------------------+
Sequential        | All items only        | Untyped, varying sizes  |
Allocator         |                       |                         |
                  +-----------------------+-------------------------+
Newdelete         | Single items only     | Untyped, varying sizes  |
Allocator         |                       |                         |
                  +-----------------------+-------------------------+
Test              | Single items only     | Untyped, varying sizes  |
Allocator         |                       |                         |
                  +-----------------------+-------------------------+
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_default_allocator"></a> <a class="anchor" id="description.the_default_allocator"></a> <a class="anchor" id="3.8"></a> </dd></dl>
<dl class="user"><dt><b>The Default Allocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>All object types in BDE libraries needing dynamic memory require that an allocator be passed to their constructor. They take a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> argument, which defaults to the value of <code><a class="el" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator()</a></code>. This value is set by BDE library code to be <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html#a1d38f6dd5b0f1cf4744c4cf7bcb69da1">bslma::NewDeleteAllocator::singleton()</a></code>, but it can be changed: <code><a class="el" href="structbslma_1_1Default.html#af60e1ab6d61791aaadcbf91e159639f3">bslma::Default::setDefaultAllocator</a></code> sets the value of the (global) default allocator, and <code><a class="el" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a></code> returns it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="interaction_with_other_packages"></a> <a class="anchor" id="description.interaction_with_other_packages"></a> <a class="anchor" id="3.9"></a> </dd></dl>
<dl class="user"><dt><b>Interaction With Other Packages: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>All BDE library objects needing dynamic memory require that an allocator be passed to their constructor, which defaults to the allocator currently installed as the default allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.10"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.10.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: bslma_SequentialAllocator for a Database Driver: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>ODBC/JDBC drivers are libraries providing standardized, language-appropriate API's for accessing SQL databases. The standardization allows programmers using these drivers to access any vendor's SQL-based DBMS in the same way. Language-appropriate means that the provided API's conform better to how programmers typically work with data in C/C++ (or Java, respectively); they provide functions for reading the data as language-specific types, e.g., <code>getInt</code>, <code>getString</code>, and so on. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wanted to write an ODBC/JDBC-like driver for legacy files, so that application could access these data files with the same API used for accessing DBMS-stored data. Which memory manager would be best? </dd></dl>
<dl class="user"><dt><b></b></dt><dd>ODBC drivers return C++ types, and initially this indicates use of a memory manager that will provide properly-aligned addresses for storing those types. This example will in fact use such a manager, illustrating alignment considerations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>But note that an alternative design would store the returned data in the character-sequence form in which they are stored in the file, and convert them to type-correct values <em>only</em> when the client <em>asks</em> for a particular item. This kind of lazy evaluation would be more effective in scenarios where clients read fields at most once (i.e., sometimes not at all). In such a design, a non-aligning manager would do. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We cannot know in advance how long a client will want to hold onto a result set (the data returned from a SQL query). But because we are implementing in C++, the language provides a construct whose semantics correspond directly to the notion of "no longer needing an object" -- i.e., a destructor. If we make our result set a class, invocation of the destructor will serve as our indication that the client no longer needs the result set contents. We use this knowledge in our design by giving each result set object a unique memory allocator (a <code>bslma::SequentialAllocator</code>) and have the destructor of the result object release in a single operation all memory acquired for each result in the result set. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(Most ODBC/JDBC drivers provide separate classes representing a database connection, an SQL statement, a query result set, and so on. We simplify the example by defining one class, <code>MyResultSet</code>, that executes the query as well as returning the results; query execution in a real driver would typically belong to a <code>Statement</code> class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the use of allocators in this example is similar to the use in the previous example -- allocation when needed, and the performance-enhancing simultaneous <code>release</code> when deallocating. The intent in providing this example is not to show a different pattern, but to motivate use of aligning allocators, as distinct from the unaligned one in Usage Example 1.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As before, we highlight use of the allocator by commenting its use with asterisks. <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;bslma_sequentialallocator.h&gt;</span>
<span class="preprocessor">  #include &lt;bsl_vector.h&gt;</span>
<span class="preprocessor">  #include &lt;bsl_string.h&gt;</span>

  <span class="keyword">using namespace </span>BloombergLP;

  <span class="comment">// The following (de-facto struct) holds:</span>
  <span class="comment">//: 1 metadata defining a column, and</span>
  <span class="comment">//: 2 a container to hold column contents.</span>

  <span class="keyword">class </span>Column {

      <span class="keyword">enum</span> TypeCode {
          INT,
          DOUBLE,
          STRING
      };

      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>         d_columnName; <span class="comment">// Name of the &quot;column&quot; in the query</span>
      TypeCode            d_typeCode;   <span class="comment">// C++ type for this column</span>
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;void *&gt;</a> d_items;      <span class="comment">// Pointers to column data</span>

      <span class="keyword">friend</span> <span class="keyword">class </span>MyResultSet;
  };

  <span class="keyword">class </span>MyResultSet {

      <span class="keyword">enum</span> { SUCCESS = 0, FAILURE = 1 };

      bslma::SequentialAllocator d_memSource;  <span class="comment">// &lt;=********</span>
          <span class="comment">// The memory source for storing database-retrieved items.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;Column&gt;</a> d_columns;
      <span class="keywordtype">int</span>                 d_cursor;    <span class="comment">// specifies the row being accessed</span>

      <span class="keywordtype">int</span> findIndexForName(<span class="keyword">const</span> <span class="keywordtype">char</span> *columnName);
          <span class="comment">// Return the index in the &#39;d_columns&#39; vector of the column with the</span>
          <span class="comment">// specified &#39;columnName&#39;.</span>

    <span class="keyword">public</span>:
      MyResultSet(<span class="keywordtype">void</span>);
      ~MyResultSet(<span class="keywordtype">void</span>);

      <span class="keywordtype">bool</span> fakeExecute(<span class="keyword">const</span> <span class="keywordtype">char</span> *sqlQuery);
          <span class="comment">// Simulate the exection of the specified &#39;sqlQuery&#39;.  Return &#39;true&#39;</span>
          <span class="comment">// if successful, and &#39;false&#39; otherwise.</span>

      <span class="keywordtype">bool</span> next(<span class="keywordtype">void</span>);
          <span class="comment">// Move the result cursor to the next row.  Return &#39;true&#39; if</span>
          <span class="comment">// successful, and &#39;false&#39; otherwise.</span>

      <span class="comment">// ODBC &quot;PROTOCOL&quot; -- DATA EXTRACTION ROUTINES</span>
      <span class="keywordtype">int</span> getInt   (<span class="keywordtype">int</span>         *result, <span class="keyword">const</span> <span class="keywordtype">char</span> *columnName);
      <span class="keywordtype">int</span> getString(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *result, <span class="keyword">const</span> <span class="keywordtype">char</span> *columnName);
      <span class="keywordtype">int</span> getDouble(<span class="keywordtype">double</span>      *result, <span class="keyword">const</span> <span class="keywordtype">char</span> *columnName);
          <span class="comment">// Load into the specified &#39;result&#39;, the result corresponding to the</span>
          <span class="comment">// specified &#39;columnName&#39;.  Return 0 if successful, and a non-zero</span>
          <span class="comment">// value otherwise.</span>
  };
</pre></div><br/>
<br/>
 We simplify this example by only implementing data retrieval for three types. (A real driver, of course, would define an API for each supported type.) Note also that the function signature style conforms to BDE design -- rather than returning the data as the <em>return</em> <em>result</em> of the function call, we return it by placing it into the variable whose address we are passed as the first function argument, the <em>output</em> parameter. We reserve the return value for indicating error status. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We further simplify the example by <em>simulating</em> query execution, so that the example code can be extracted from this file and executed. The simulation involves including a (const) sequence of <code>char</code>s representing a data block as it would come back from the read file, a block which our code then parses. This simplification necessarily also involves hard-coding metadata that would also be obtained by computation, such as how many records were returned. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { SUCCESS = 0, FAILURE = 1 };

  MyResultSet::MyResultSet(<span class="keywordtype">void</span>)
  : d_memSource(bslma::Default::defaultAllocator())  <span class="comment">// &lt;=******</span>
  , d_cursor(-1)
  {
      d_columns.reserve(20);  <span class="comment">// few queries request more than 20 columns</span>
  }

  MyResultSet::~MyResultSet(<span class="keywordtype">void</span>)
  {
      d_memSource.release();  <span class="comment">// &lt;= ******</span>
  }

  <span class="keywordtype">bool</span> MyResultSet::fakeExecute(<span class="keyword">const</span> <span class="keywordtype">char</span> *sqlQuery)
  {
      <span class="comment">// This block simulates a &#39;char&#39; sequence that might be returned</span>
      <span class="comment">// from the file.  It simulates a legacy file that stores the data</span>
      <span class="comment">// as &#39;@&#39;-separated fields.</span>
      <span class="comment">//</span>
      <span class="comment">// The query being simulated appears in &#39;main&#39;, below.</span>

      <span class="keywordtype">char</span> *fileData =
     <span class="stringliteral">&quot;Harold@Effective XML@0321150406@44.99@&quot;</span>
     <span class="stringliteral">&quot;Alexandrescu@Modern C++ Design@0201704315@42.99@&quot;</span>
     <span class="stringliteral">&quot;McLaughlin@Java &amp; XML@0596001975@44.95@&quot;</span>
     <span class="stringliteral">&quot;Leung@Professional XML Development with Apache Tools@0764543555@39.99@&quot;</span>
     <span class="stringliteral">&quot;Rago@UNIX System V Network Programming@0201563185@47.50@&quot;</span>;

      <span class="keyword">const</span> <span class="keywordtype">int</span> numRows = 5;  <span class="comment">// would be computed</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> numCols = 4;  <span class="comment">// would be parsed from query</span>

      <span class="comment">// Set up &#39;MyResultSet&#39; metadata</span>

      Column rsmd;

      rsmd.d_columnName = <span class="stringliteral">&quot;AUTHOR&quot;</span>;
      rsmd.d_typeCode   = Column::STRING;
      d_columns.push_back(rsmd);

      rsmd.d_columnName = <span class="stringliteral">&quot;TITLE&quot;</span>;
      rsmd.d_typeCode   = Column::STRING;
      d_columns.push_back(rsmd);

      rsmd.d_columnName = <span class="stringliteral">&quot;ISBN&quot;</span>;
      rsmd.d_typeCode   = Column::INT;
      d_columns.push_back(rsmd);

      rsmd.d_columnName = <span class="stringliteral">&quot;PRICE&quot;</span>;
      rsmd.d_typeCode   = Column::DOUBLE;
      d_columns.push_back(rsmd);

      <span class="keyword">const</span> <span class="keywordtype">char</span> *endOfWord = fileData;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numRows; i++) {
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; numCols; ++j) {

              <span class="comment">// Find the start and end of next column&#39;s data</span>

              <span class="keyword">const</span> <span class="keywordtype">char</span> *startOfWord = endOfWord;
              endOfWord = strchr(endOfWord, <span class="charliteral">&#39;@&#39;</span>);

              <span class="comment">// Because of our simulation, the &quot;file-returned block&quot;</span>
              <span class="comment">// is stored in const memory.  We can&#39;t replace the &#39;@&#39; signs</span>
              <span class="comment">// with the needed NULL directly in const memory, so we  make</span>
              <span class="comment">// a copy of the parsed items instead.</span>
              <span class="comment">// This extra copy would not be needed in a real driver.</span>

              <span class="keywordtype">char</span> scratchSpace[100];
              <span class="keywordtype">int</span>  hackLen = endOfWord - startOfWord;

              strncpy(scratchSpace, startOfWord, hackLen);
              scratchSpace[hackLen] = 0;

              <span class="keywordtype">int</span>    *iMemBlock;  <span class="comment">// define these outside the switch</span>
              <span class="keywordtype">double</span> *dMemBlock;  <span class="comment">// to silence erroneous compiler</span>
              <span class="keywordtype">char</span>   *sMemBlock;  <span class="comment">// errors</span>

              <span class="comment">// Extract the data, storing in allocated memory.</span>

              <span class="keywordflow">switch</span> (d_columns[j].d_typeCode) {
                <span class="keywordflow">case</span> Column::INT:
                  iMemBlock = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>  <span class="comment">// &lt;=**********</span>
                                         (d_memSource.allocate(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)));

                  *iMemBlock = atoi(scratchSpace);   <span class="comment">// SAFE because aligned!</span>
                  d_columns[j].d_items.push_back(iMemBlock);
                  <span class="keywordflow">break</span>;

                <span class="keywordflow">case</span> Column::DOUBLE:
                  dMemBlock = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span> *<span class="keyword">&gt;</span> <span class="comment">// &lt;=***********</span>
                                      (d_memSource.allocate(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)));
                  *dMemBlock = atof(scratchSpace);   <span class="comment">// SAFE because aligned!</span>
                  d_columns[j].d_items.push_back(dMemBlock);
                  <span class="keywordflow">break</span>;

                <span class="keywordflow">case</span> Column::STRING:
                  <span class="keywordtype">int</span> strLen = endOfWord - startOfWord;
                  sMemBlock = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>  <span class="comment">// &lt;=*********</span>
                                      (d_memSource.allocate(strLen + 1));
                  strncpy(sMemBlock, startOfWord, strLen);
                  sMemBlock[strLen] = 0;
                  d_columns[j].d_items.push_back(sMemBlock);
                  <span class="keywordflow">break</span>;
              }
              ++endOfWord;
          }
      }
      <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }

  <span class="keywordtype">bool</span> MyResultSet::next(<span class="keywordtype">void</span>)
  {
      <span class="keywordflow">if</span> (++d_cursor &gt;= d_columns[0].d_items.size()) {
          <span class="comment">// All columns have the same number of items, so it suffices to</span>
          <span class="comment">// ask about &#39;d_columns[0]&#39;.</span>

          <span class="keywordflow">return</span> <span class="keyword">false</span>;
      }

      <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }

  <span class="keywordtype">int</span> MyResultSet::getInt(<span class="keywordtype">int</span> *result, <span class="keyword">const</span> <span class="keywordtype">char</span> *columnName)
  {
      <span class="keywordtype">int</span> index = findIndexForName(columnName);
      <span class="keywordflow">if</span> (-1 == index) {
          <span class="keywordflow">return</span> FAILURE;
      }

      *result = *(<span class="keywordtype">int</span> *)(d_columns[index].d_items[d_cursor]);
      <span class="keywordflow">return</span> SUCCESS;
  }

  <span class="keywordtype">int</span> MyResultSet::getString(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *result, <span class="keyword">const</span> <span class="keywordtype">char</span> *columnName)
  {
      <span class="keywordtype">int</span> index = findIndexForName(columnName);
      <span class="keywordflow">if</span> (-1 == index) {
          <span class="keywordflow">return</span> FAILURE;
      }

      *result = (<span class="keywordtype">char</span> *)(d_columns[index].d_items[d_cursor]);
      <span class="keywordflow">return</span> SUCCESS;
  }

  <span class="keywordtype">int</span> MyResultSet::getDouble(<span class="keywordtype">double</span> *result, <span class="keyword">const</span> <span class="keywordtype">char</span> *columnName)
  {
      <span class="keywordtype">int</span> index = findIndexForName(columnName);
      <span class="keywordflow">if</span> (-1 == index) {
          <span class="keywordflow">return</span> FAILURE;
      }

      *result = *(<span class="keywordtype">double</span> *)(d_columns[index].d_items[d_cursor]);
      <span class="keywordflow">return</span> SUCCESS;
  }

  <span class="keywordtype">int</span> MyResultSet::findIndexForName(<span class="keyword">const</span> <span class="keywordtype">char</span> *columnName)
  {
      <span class="comment">// In production code, we might have used an &#39;bsl::map&#39;.</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d_columns.size(); ++i) {
          <span class="keywordflow">if</span> (d_columns[i].d_columnName == columnName) {
              <span class="keywordflow">return</span> i;
          }
      }
      <span class="keywordflow">return</span> -1;
  }
</pre></div><br/>
<br/>
 The <code>main</code> procedure is then coded as expected: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">using namespace </span>BloombergLP;

  <span class="keywordtype">int</span> myMain1()
  {
      MyResultSet rs;
      rs.fakeExecute(<span class="stringliteral">&quot;SELECT author, title, isbn, price &quot;</span>
                     <span class="stringliteral">&quot;FROM &lt;table list&gt; &quot;</span>
                     <span class="stringliteral">&quot;WHERE &lt;join criteria&gt;&quot;</span>);

      <span class="comment">// Walk through entire result set and print out entries.</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> author;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> title;
      <span class="keywordtype">int</span>         isbn;
      <span class="keywordtype">double</span>      price;

      <span class="keywordflow">while</span> (rs.next()) {  <span class="comment">// position at the next row</span>
          rs.getString(&amp;author, <span class="stringliteral">&quot;AUTHOR&quot;</span>);
          rs.getString(&amp;title,  <span class="stringliteral">&quot;TITLE&quot;</span>);
          rs.getInt   (&amp;isbn,   <span class="stringliteral">&quot;ISBN&quot;</span>);
          rs.getDouble(&amp;price,  <span class="stringliteral">&quot;PRICE&quot;</span>);

          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Author: &quot;</span> &lt;&lt; author &lt;&lt; bsl::endl;
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Title : &quot;</span> &lt;&lt; title  &lt;&lt; bsl::endl;
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;ISBN #: &quot;</span> &lt;&lt; isbn   &lt;&lt; bsl::endl;
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Price : &quot;</span> &lt;&lt; price  &lt;&lt; bsl::endl &lt;&lt; bsl::endl;
      }

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.10.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Sketch Use of bslma::BufferAllocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Clients can take advantage of the faster and cheaper memory originating on the stack for use with objects (wanting allocators) that are used as <em>local</em> <em>variables</em> within some procedure. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyLargeObject {
      <span class="comment">// ....</span>
  };

  <span class="keywordtype">int</span> myMain2()
  {
      {
          <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;MyLargeObject&gt;</a> someLocalVariable;
      }
</pre></div><br/>
<br/>
 Vectors accept allocators, too, which (along with other BDE components) use the default allocator when none is explicitly supplied. For most applications, the default is heap-originated memory (i.e., the <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can often speed up such local use by grabbing sufficient stack space and passing it in to the local object, wrapped in a <code>bslma::_BufferAllocator</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The code above might look like <br/>
<br/>
<div class="fragment"><pre class="fragment">      {
          <span class="keywordtype">int</span>                        initSize = 10;
          <span class="keywordtype">char</span>                       hugeLocalArray[5000];
          bslma::BufferAllocator     allocator(hugeLocalArray, <span class="comment">// DEPRECATED!</span>
                                               <span class="keyword">sizeof</span>(hugeLocalArray));
          <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;MyLargeObject&gt;</a> someLocalVariable(initSize,
                                                       &amp;allocator);
      }
</pre></div><br/>
<br/>
 The safest use passes the <code>bslma::BufferAllocator</code> a "fallback" to use, should the stack space we grabbed prove insufficient. The fallback must be a (pointer to a) function that accepts an <code>int</code> (the requested number of bytes) and returns a <code>void *</code> (the presumed pointer to an allocated memory block). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We write a simple fallback function as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>Local {
      <span class="keyword">static</span> <span class="keywordtype">void</span> *ersatzNew(<span class="keywordtype">int</span> numBytes)
      {
          <span class="keywordflow">return</span> <span class="keyword">new</span> <span class="keywordtype">char</span>[numBytes];
      }
  };
</pre></div><br/>
<br/>
 and then redo the above code to pass this fallback to our buffer allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">      {
         <span class="keywordtype">int</span>                        initSize = 10;
         <span class="keywordtype">char</span>                       hugeLocalArray[5000];
         bslma::BufferAllocator     allocator(hugeLocalArray,
                                              <span class="keyword">sizeof</span>(hugeLocalArray),
                                              Local::ersatzNew);
         <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;MyLargeObject&gt;</a> someLocalVariable(initSize,
                                                      &amp;allocator);
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
