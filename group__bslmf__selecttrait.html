<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslmf_selecttrait Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Component bslmf_selecttrait<br/>
<small>
[<a class="el" href="group__bslmf.html">Package bslmf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a meta-function for overload dispatch per trait.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
</table>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Dispatch on traits</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a meta-function for overload dispatch per trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bslmf::SelectTrait </td><td>meta-function  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates the intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Dispatch on traits: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We would like to create a function template, <code>ScalarPrimitives::copyConstruct</code>, that takes an original object and an allocator constructs a copy of <code>original</code> using the most efficient valid mechanism. The function should take into account that the original type might be bitwise copyable, or have an allocator that can be different in the copy than in the original object, or that the original might be a pair type, where the correct method of copying <code>first</code> and <code>second</code> is (recursively) goverened by the same concerns. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The old (legacy) <code>bsls::HasTrait</code> mechanism has a clumsy mechanism for dispatching on multple traits at once. For example, the <code>bslalg::scalarprimitives::copyConstruct</code>, function uses four different implementations, depending on the traits of the object being copied. The existing code looks like this: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span>
  ScalarPrimitives::copyConstruct(TARGET_TYPE        *address,
                                  <span class="keyword">const</span> TARGET_TYPE&amp;  original,
                                  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *allocator)
  {
      BSLS_assert_SAFE(address);

      <span class="keyword">enum</span> {
          VALUE = HasTrait&lt;TARGET_TYPE,
                                  TypeTraitUsesBslmaAllocator
                                 &gt;::VALUE ? Imp::USES_BSLMA_ALLOCATOR_TRAITS
                : HasTrait&lt;TARGET_TYPE,
                                  TypeTraitBitwiseCopyable
                                 &gt;::VALUE ? Imp::BITWISE_COPYABLE_TRAITS
                : HasTrait&lt;TARGET_TYPE,
                                  TypeTraitPair
                                 &gt;::VALUE ? Imp::PAIR_TRAITS
                : Imp::NIL_TRAITS
      };
      Imp::copyConstruct(address, original, allocator,
                         (<a class="code" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt&lt;VALUE&gt;</a>*)0);
  }
</pre></div><br/>
<br/>
 We would like to replace the cumbersome chain of <code>?:</code> operations with a clean mechanism for producing one of four different types based on the first matching trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create three traits metafunctions to replace the three legacy traits used above: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt; <span class="keyword">struct </span>UsesBslmaAllocator : bsl::<a class="code" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">false_type</a> { };
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt; <span class="keyword">struct </span>IsBitwiseCopyable : bsl::<a class="code" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">false_type</a> { };
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt; <span class="keyword">struct </span>IsPair : bsl::<a class="code" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">false_type</a> { };
</pre></div><br/>
<br/>
 Note that these definitions are simplified to avoid excess dependencies; A proper traits definition would inherit from <code><a class="el" href="structbslmf_1_1DetectNestedTrait.html">bslmf::DetectNestedTrait</a></code> instead of from <code><a class="el" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">bsl::false_type</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we forward-declare <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> and <code>bslalg::scalarprimitives::copyConstruct</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">namespace </span>bslma { <span class="keyword">class </span>Allocator; }

  <span class="keyword">namespace </span>bslalg {
  <span class="keyword">struct </span>ScalarPrimitives {
      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">copyConstruct</a>(TARGET_TYPE        *address,
                                <span class="keyword">const</span> TARGET_TYPE&amp;  original,
                                <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *allocator);
  };
</pre></div><br/>
<br/>
 Next, we implement four overloads of <code>Imp::copyConstruct</code>, each taking a different <code><a class="el" href="structbsl_1_1integral__constant.html">bsl::integral_constant</a></code> specialization. For testing purposes, in addition to copying the data member, each overload also increments a separate counter. These implemenations are slightly simplified for readability: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>Imp {

      <span class="keyword">enum</span> {
          <span class="comment">// These constants are used in the overloads below, when the last</span>
          <span class="comment">// argument is of type &#39;bslmf::MetaInt&lt;N&gt; *&#39;, indicating that</span>
          <span class="comment">// &#39;TARGET_TYPE&#39; has the traits for which the enumerator equal to</span>
          <span class="comment">// &#39;N&#39; is named.</span>

          USES_BSLMA_ALLOCATOR_TRAITS     = 5,
          PAIR_TRAITS                     = 4,
          BITWISE_COPYABLE_TRAITS         = 2,
          NIL_TRAITS                      = 0
      };

      <span class="keyword">static</span> <span class="keywordtype">int</span> d_counters[USES_BSLMA_ALLOCATOR_TRAITS + 1];

      <span class="keyword">static</span> <span class="keywordtype">void</span> clearCounters()
          { std::memset(d_counters, 0, <span class="keyword">sizeof</span>(d_counters)); }

      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span>
      copyConstruct(TARGET_TYPE                                 *address,
                    <span class="keyword">const</span> TARGET_TYPE&amp;                           original,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                            *allocator,
                    <a class="code" href="structbsl_1_1integral__constant.html">bsl::integral_constant&lt;int, USES_BSLMA_ALLOCATOR_TRAITS&gt;</a>)
      {
          <span class="keyword">new</span> (address) TARGET_TYPE(original, allocator);
          ++d_counters[USES_BSLMA_ALLOCATOR_TRAITS];
      }

      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span>
      copyConstruct(TARGET_TYPE                 *address,
                    <span class="keyword">const</span> TARGET_TYPE&amp;           original,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>            *allocator,
                    <a class="code" href="structbsl_1_1integral__constant.html">bsl::integral_constant&lt;int, PAIR_TRAITS&gt;</a>)
      {
          ScalarPrimitives::copyConstruct(&amp;address-&gt;first, original.first,
                                          allocator);
          ScalarPrimitives::copyConstruct(&amp;address-&gt;second, original.second,
                                          allocator);
          ++d_counters[PAIR_TRAITS];
      }

      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span>
      copyConstruct(TARGET_TYPE                             *address,
                    <span class="keyword">const</span> TARGET_TYPE&amp;                       original,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                        *,
                    <a class="code" href="structbsl_1_1integral__constant.html">bsl::integral_constant&lt;int, BITWISE_COPYABLE_TRAITS&gt;</a>)
      {
          std::memcpy(address, &amp;original, <span class="keyword">sizeof</span>(original));
          ++d_counters[BITWISE_COPYABLE_TRAITS];
      }

      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span>
      copyConstruct(TARGET_TYPE                *address,
                    <span class="keyword">const</span> TARGET_TYPE&amp;          original,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>           *,
                    <a class="code" href="structbsl_1_1integral__constant.html">bsl::integral_constant&lt;int, NIL_TRAITS&gt;</a>)
      {
          <span class="keyword">new</span> (address) TARGET_TYPE(original);
          ++d_counters[NIL_TRAITS];
      }
  };

  <span class="keywordtype">int</span> bslalg::Imp::d_counters[USES_BSLMA_ALLOCATOR_TRAITS + 1] = { 0 };
</pre></div><br/>
<br/>
 Then, we implement <code>ScalarPrimitives::copyConstruct</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_TYPE&gt;
  <span class="keyword">inline</span> <span class="keywordtype">void</span>
  ScalarPrimitives::copyConstruct(TARGET_TYPE        *address,
                                  <span class="keyword">const</span> TARGET_TYPE&amp;  original,
                                  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *allocator)
  {
</pre></div><br/>
<br/>
 We use <code>bslmf::SelectTrait</code> to declare <code>Selection</code> as an instantiation of <code><a class="el" href="structbsl_1_1integral__constant.html">bsl::integral_constant</a></code> corresponding to the first match of the specified traits: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">typedef</span> bslmf::SelectTrait&lt;TARGET_TYPE,
          UsesBslmaAllocator,        Imp::USES_BSLMA_ALLOCATOR_TRAITS,
          IsBitwiseCopyable,         Imp::BITWISE_COPYABLE_TRAITS,
          IsPair,                    Imp::PAIR_TRAITS,
          bslmf::SelectTraitDefault, Imp::NIL_TRAITS&gt; Selection;
</pre></div><br/>
<br/>
 Now, we use <code>Selection</code> to choose (at compiler time), one of the <code>Imp::copyConstruct</code> overloads defined above: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::copyConstruct(address, original, allocator, Selection());
  }
  } <span class="comment">// Close namespace bslalg</span>
</pre></div><br/>
<br/>
 Finally, we define three classes, associated with each of the three traits of interest, a fourth class associated with more than one trait (to show that the selection mechanism respects preference) and a fifth class that is not associated with any trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The first class is associated with the <code>UsesBslmaAllocator</code> trait: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>TypeWithAllocator {
      <span class="keywordtype">int</span>               d_value;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_alloc;
  <span class="keyword">public</span>:
      TypeWithAllocator(<span class="keywordtype">int</span> v = 0, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *a = 0)
          : d_value(v), d_alloc(a) { }
      TypeWithAllocator(<span class="keyword">const</span> TypeWithAllocator&amp; other,
                        <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *a = 0)
          : d_value(other.d_value), d_alloc(a) {  }

      <span class="keywordtype">int</span> value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_value; }
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_alloc; }
  };

  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>UsesBslmaAllocator&lt;TypeWithAllocator&gt;
      : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> { };
</pre></div><br/>
<br/>
 The second class is associated with the <code>IsBitwiseCopyiable</code> trait: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>BitwiseCopyableType {
      <span class="keywordtype">int</span> d_value;
  <span class="keyword">public</span>:
      BitwiseCopyableType(<span class="keywordtype">int</span> v = 0) : d_value(v) { }
      <span class="keywordtype">int</span> value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_value; }
  };

  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>IsBitwiseCopyable&lt;BitwiseCopyableType&gt;
      : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> { };
</pre></div><br/>
<br/>
 The third class is associated with the <code>IsPair</code> trait: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>PairType {
      TypeWithAllocator   first;
      BitwiseCopyableType second;

      PairType(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) : first(a), second(b) { }
  };

  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>IsPair&lt;PairType&gt; : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> { };
</pre></div><br/>
<br/>
 The fourth class is associated with both the the <code>IsPair</code> and <code>IsBitwiseCopyiable</code> traits: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>BitwiseCopyablePairType {
      BitwiseCopyableType first;
      BitwiseCopyableType second;

      BitwiseCopyablePairType(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) : first(a), second(b) { }
  };

  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>IsPair&lt;BitwiseCopyablePairType&gt; : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> { };
  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>IsBitwiseCopyable&lt;BitwiseCopyablePairType&gt;
      : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> { };
</pre></div><br/>
<br/>
 The fifth class is not associated with any explicit traits: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>TypeWithNoTraits {
      <span class="keywordtype">int</span> d_value;
  <span class="keyword">public</span>:
      TypeWithNoTraits(<span class="keywordtype">int</span> v = 0) : d_value(v) { }
      <span class="keywordtype">int</span> value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_value; }
  };
</pre></div><br/>
<br/>
 We use these classes to instantiate <code>ScalarPrimitives::copyConstruct</code> and verify that the most efficient copy operation that is valid for each type is applied: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main()
  {
      <span class="keyword">using</span> bslalg::Imp;

      <span class="comment">// This buffer is properly aligned and big enough to hold any of the</span>
      <span class="comment">// test types.</span>
      <span class="keywordtype">void</span> *buffer[4];
      <span class="keywordtype">char</span> dummy[2];  <span class="comment">// Dummy addresses</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *a1 = (<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*) &amp;dummy[0];
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *a2 = (<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*) &amp;dummy[1];
</pre></div><br/>
<br/>
 When we call <code>ScalarPrimitives::copyConstruct</code> for an object of <code>TypeWithAllocator</code>, we expect that the copy will have the same value but a different allocator than the original and that the <code>USES_BSLMA_ALLOCATOR_TRAITS</code> copy implementation will be called once: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::clearCounters();
      TypeWithAllocator  twa(1, a1);
      TypeWithAllocator *twaptr = (TypeWithAllocator*) buffer;
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(twaptr, twa, a2);
      assert(1 == Imp::d_counters[Imp::USES_BSLMA_ALLOCATOR_TRAITS]);
      assert(1 == twaptr-&gt;value());
      assert(a2 == twaptr-&gt;allocator());
      twaptr-&gt;~TypeWithAllocator();
</pre></div><br/>
<br/>
 When we call <code>ScalarPrimitives::copyConstruct</code> for an object of <code>BitwiseCopyableType</code>, we expect that the <code>BITWISE_COPYABLE_TRAITS</code> copy implementation will be called once: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::clearCounters();
      BitwiseCopyableType  bct(2);
      BitwiseCopyableType *bctptr = (BitwiseCopyableType*) buffer;
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(bctptr, bct, a2);
      assert(1 == Imp::d_counters[Imp::BITWISE_COPYABLE_TRAITS]);
      assert(2 == bctptr-&gt;value());
      bctptr-&gt;~BitwiseCopyableType();
</pre></div><br/>
<br/>
 When we call <code>ScalarPrimitives::copyConstruct</code> for an object of <code>PairType</code>, we expect that the <code>PAIR_TRAITS</code> copy implementation will be called once for the pair as whole and that the <code>USES_BSLMA_ALLOCATOR_TRAITS</code> and <code>BITWISE_COPYABLE_TRAITS</code> implementations will be called for the <code>first</code> and <code>second</code> members, respectively: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::clearCounters();
      PairType  pt(3, 4);
      PairType *ptptr = (PairType*) buffer;
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(ptptr, pt, a2);
      assert(1 == Imp::d_counters[Imp::PAIR_TRAITS]);
      assert(1 == Imp::d_counters[Imp::USES_BSLMA_ALLOCATOR_TRAITS]);
      assert(1 == Imp::d_counters[Imp::BITWISE_COPYABLE_TRAITS]);
      assert(3 == ptptr-&gt;first.value());
      assert(a2 == ptptr-&gt;first.allocator());
      assert(4 == ptptr-&gt;second.value());
      ptptr-&gt;~PairType();
</pre></div><br/>
<br/>
 When we call <code>ScalarPrimitives::copyConstruct</code> for an object of <code>BitwiseCopyablePairType</code>, the <code>IsBitwiseCopyable</code> trait takes precedence over the <code>IsPair</code> trait (because it appears first in the list of traits used to instantiate <code>SelectTrait</code>). Therefore, we expect to see the <code>BITWISE_COPYABLE_TRAITS</code> copy implementation called once for the whole pair and the <code>PAIR_TRAITS</code> copy implementation not called at all: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::clearCounters();
      BitwiseCopyablePairType  bcpt(5, 6);
      BitwiseCopyablePairType *bcptbcptr = (BitwiseCopyablePairType*) buffer;
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(bcptbcptr, bcpt, a2);
      <span class="comment">// Prefer IsBitwiseCopyable over IsPair trait</span>
      assert(1 == Imp::d_counters[Imp::BITWISE_COPYABLE_TRAITS]);
      assert(0 == Imp::d_counters[Imp::PAIR_TRAITS]);
      assert(5 == bcptbcptr-&gt;first.value());
      assert(6 == bcptbcptr-&gt;second.value());
      bcptbcptr-&gt;~BitwiseCopyablePairType();
</pre></div><br/>
<br/>
 When we call <code>ScalarPrimitives::copyConstruct</code> for an object of <code>TypeWithNoTraits</code>, we expect none of the specialized copy implementations to be called, thus defaulting to the <code>NIL_TRAITS</code> copy implementation: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::clearCounters();
      TypeWithNoTraits  twnt(7);
      TypeWithNoTraits *twntptr = (TypeWithNoTraits*) buffer;
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(twntptr, twnt, a2);
      assert(1 == Imp::d_counters[Imp::NIL_TRAITS]);
      assert(7 == twntptr-&gt;value());
      twntptr-&gt;~TypeWithNoTraits();

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Note that using <code>SelectTraits</code> for dispatching using overloading imposes little or no overhead, since the compiler typically generates no code for the constructor or copy constructor of the <code><a class="el" href="structbsl_1_1integral__constant.html">bsl::integral_constant</a></code> argument to the overloaded functions. When inlining is in effect, the result is very efficient. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:42 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
