<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslstl_hashtablebucketiterator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_hashtablebucketiterator<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL compliant iterator over hash table buckets.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef NcType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga3140d7267a369638df6985d3ce220ea7">BloombergLP::bslstl::HashTableBucketIterator::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef DIFFERENCE_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga8b72d49be511f4dd77eca7803e8ea93d">BloombergLP::bslstl::HashTableBucketIterator::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga0664cedab9e6386583626e9b5a0ca4f2">BloombergLP::bslstl::HashTableBucketIterator::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#gacd8804d543cd70f851795d51e5031577">BloombergLP::bslstl::HashTableBucketIterator::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
native_std::forward_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga3dd4745f2326cd275d4c3a367cf78d24">BloombergLP::bslstl::HashTableBucketIterator::iterator_category</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga34e05872e63c75b771a6d54027136b34">BloombergLP::bslstl::HashTableBucketIterator::HashTableBucketIterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#gac6d4cc13224c2079e1ce4b6003b8e87b">BloombergLP::bslstl::HashTableBucketIterator::HashTableBucketIterator</a> (const <a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a> *bucket)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga63016ce0aa0d348b989f29cd6cd02625">BloombergLP::bslstl::HashTableBucketIterator::HashTableBucketIterator</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *node, const <a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a> *bucket)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga65b302aa4baa97132ba92d7cc247d9ce">BloombergLP::bslstl::HashTableBucketIterator::HashTableBucketIterator</a> (const NcIter &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HashTableBucketIterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#gadc2efdb3a56031bd5513ef4b488d1429">BloombergLP::bslstl::HashTableBucketIterator::operator++</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HashTableBucketIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga9eaf9db7977c7e78745b3ceee1ae31ee">BloombergLP::bslstl::HashTableBucketIterator::operator++</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga6eee300fdc95bbaf4987dfa10cd0b8e1">BloombergLP::bslstl::HashTableBucketIterator::operator*</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga8835fab232d3c1550a757c6cc42c2a88">BloombergLP::bslstl::HashTableBucketIterator::operator-&gt;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga75477586a19e2f3d03f725f06147479f">BloombergLP::bslstl::HashTableBucketIterator::node</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#gad5d542041dd90e79841c4f1f89f07003">BloombergLP::bslstl::HashTableBucketIterator::bucket</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#gadfa920b400d12cc5e7c48253c51d534e">BloombergLP::bslstl::operator==</a> (const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga410e771f7e06e37f80f528b420a698b4">BloombergLP::bslstl::operator==</a> (const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#gac398afdc303476a714bc1b1547782e2d">BloombergLP::bslstl::operator==</a> (const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga151dad22b647ff8e88f9f7ebe9545f9f">BloombergLP::bslstl::operator==</a> (const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#gae4044832cad05668b1bfebe1c93c13aa">BloombergLP::bslstl::operator!=</a> (const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga3f4a64d810d76baa378444e8bf11a1ed">BloombergLP::bslstl::operator!=</a> (const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#gaf71d9015604d57b2f67a40ffd3442df6">BloombergLP::bslstl::operator!=</a> (const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtablebucketiterator.html#ga6c82e3668693f7da12f69f8ff807bfe4">BloombergLP::bslstl::operator!=</a> (const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL compliant iterator over hash table buckets. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bslstl::HashBucketIterator </td><td>iterator to walk a hash-table bucket  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__unorderedmultimap.html" title="Provide an STL-compliant unordered_multimap class.">Component bslstl_unorderedmultimap</a>, <a class="el" href="group__bslstl__unorderedmultiset.html" title="Provide an STL-compliant unordered_multiset class.">Component bslstl_unorderedmultiset</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a common foundation to implement the four <code>unordered</code> containers specified by the C++11 standard. It supplies a hash table, which stores values in buckets determined by the supplied hashing policy, and iterators to walk the table returning access to said values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This implementation will be the <code>monkey-skin</code> approach that minimizes the size of the nodes, by using the preceding element in the list when storing references to nodes, e.g., in iterators or buckets. The main container is a singly-linked list, indexed by a vector of buckets. The overhead is: o one pointer in each node o one pointer per bucket (no. buckets determined by max_load_factor) o one additional (empty) sentinel node As we do not cache the hashed value, if any hash function throws we will either do nothing and allow the exception to propagate, or, if some change of state has already been made, clear the whole container to provide the basic exception guarantee. There are similar concerns for the <code>equal_to</code> predicate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga3140d7267a369638df6985d3ce220ea7"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::value_type" ref="ga3140d7267a369638df6985d3ce220ea7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef NcType <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8b72d49be511f4dd77eca7803e8ea93d"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::difference_type" ref="ga8b72d49be511f4dd77eca7803e8ea93d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DIFFERENCE_TYPE <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0664cedab9e6386583626e9b5a0ca4f2"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::pointer" ref="ga0664cedab9e6386583626e9b5a0ca4f2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE* <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacd8804d543cd70f851795d51e5031577"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::reference" ref="gacd8804d543cd70f851795d51e5031577" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE&amp; <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3dd4745f2326cd275d4c3a367cf78d24"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::iterator_category" ref="ga3dd4745f2326cd275d4c3a367cf78d24" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef native_std::forward_iterator_tag <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::iterator_category<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga34e05872e63c75b771a6d54027136b34"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::HashTableBucketIterator" ref="ga34e05872e63c75b771a6d54027136b34" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::HashTableBucketIterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator object with the default value for this type. All default-constructed <code><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a></code> objects represent non-dereferenceable iterators into the same empty range. They do not have a singular value. </p>

</div>
</div>
<a class="anchor" id="gac6d4cc13224c2079e1ce4b6003b8e87b"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::HashTableBucketIterator" ref="gac6d4cc13224c2079e1ce4b6003b8e87b" args="(const bslalg::HashTableBucket *bucket)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::HashTableBucketIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a> *&nbsp;</td>
          <td class="paramname"> <em>bucket</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator referring to the specified <code>bucket</code>, initially pointing to the first node in that <code>bucket</code>, or a past-the-end value if the <code>bucket</code> is empty. Note that this constructor is an implementation detail and is not part of the C++ standard. </p>

</div>
</div>
<a class="anchor" id="ga63016ce0aa0d348b989f29cd6cd02625"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::HashTableBucketIterator" ref="ga63016ce0aa0d348b989f29cd6cd02625" args="(bslalg::BidirectionalLink *node, const bslalg::HashTableBucket *bucket)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::HashTableBucketIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a> *&nbsp;</td>
          <td class="paramname"> <em>bucket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator referring to the specified <code>bucket</code>, initially pointing to the specified <code>node</code> in that bucket. The behavior is undefined unless <code>node</code> is part of <code>bucket</code>, or <code>node</code> is 0. Note that this constructor is an implementation detail and is not part of the C++ standard. </p>

</div>
</div>
<a class="anchor" id="ga65b302aa4baa97132ba92d7cc247d9ce"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::HashTableBucketIterator" ref="ga65b302aa4baa97132ba92d7cc247d9ce" args="(const NcIter &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::HashTableBucketIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">NcIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator having the same value as the specified <code>original</code>. Note that this operation is either defined by the constructor taking <code>NcIter</code> (if <code>NcType</code> is the same as <code>VALUE_TYPE</code>), or generated automatically by the compiler. Also note that this constructor cannot be defined explicitly (without using <code>bsls::enableif</code>) to avoid a duplicate declaration when <code>NcType</code> is the same as <code>VALUE_TYPE</code>. </p>

</div>
</div>
<a class="anchor" id="gadc2efdb3a56031bd5513ef4b488d1429"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::operator++" ref="gadc2efdb3a56031bd5513ef4b488d1429" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HashTableBucketIterator&amp; <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move this iterator to the next element in the hash table bucket and return a reference providing modifiable access to this iterator. The behavior is undefined unless the iterator refers to a valid (not yet erased) node a hash table bucket. Note that <code><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a></code>s are invalidated when the underlying hash table is rehashed. </p>

</div>
</div>
<a class="anchor" id="ga9eaf9db7977c7e78745b3ceee1ae31ee"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::operator++" ref="ga9eaf9db7977c7e78745b3ceee1ae31ee" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HashTableBucketIterator <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move this iterator to the next element in the hash table bucket and return value of this iterator prior to this call. The behavior is undefined unless the iterator refers to a valid (not yet erased) node a hash table bucket. Note that <code><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a></code>s are invalidated when the underlying hash table is rehashed. </p>

</div>
</div>
<a class="anchor" id="ga6eee300fdc95bbaf4987dfa10cd0b8e1"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::operator*" ref="ga6eee300fdc95bbaf4987dfa10cd0b8e1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the value (of the parameterized <code>VALUE_TYPE</code>) of the element at which this iterator is positioned. The behavior is undefined unless the iterator refers to a valid (not yet erased) node a hash table. Note that <code><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a></code>s are invalidated when the underlying hash table is rehashed. </p>

</div>
</div>
<a class="anchor" id="ga8835fab232d3c1550a757c6cc42c2a88"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::operator&#45;&gt;" ref="ga8835fab232d3c1550a757c6cc42c2a88" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the value (of the parameterized <code>VALUE_TYPE</code>) of the element at which this iterator is positioned. The behavior is undefined unless the iterator refers to a valid (not yet erased) node a hash table. Note that <code><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a></code>s are invalidated when the underlying hash table is rehashed. </p>

</div>
</div>
<a class="anchor" id="ga75477586a19e2f3d03f725f06147479f"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::node" ref="ga75477586a19e2f3d03f725f06147479f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the list-node at which this iterator is positioned, or 0 if this iterator is positioned after the end of a bucket. Note that this method is an implementation detail and is not part of the C++ standard. </p>

</div>
</div>
<a class="anchor" id="gad5d542041dd90e79841c4f1f89f07003"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableBucketIterator::bucket" ref="gad5d542041dd90e79841c4f1f89f07003" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a>* <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::bucket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the list-node at which this iterator is positioned, or 0 if this iterator is positioned after the end of a bucket. Note that this method is an implementation detail intended for debugging purposes only, and is not part of the C++ standard. </p>

</div>
</div>
<a class="anchor" id="gadfa920b400d12cc5e7c48253c51d534e"></a><!-- doxytag: member="BloombergLP::bslstl::operator==" ref="gadfa920b400d12cc5e7c48253c51d534e" args="(const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga410e771f7e06e37f80f528b420a698b4"></a><!-- doxytag: member="BloombergLP::bslstl::operator==" ref="ga410e771f7e06e37f80f528b420a698b4" args="(const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac398afdc303476a714bc1b1547782e2d"></a><!-- doxytag: member="BloombergLP::bslstl::operator==" ref="gac398afdc303476a714bc1b1547782e2d" args="(const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga151dad22b647ff8e88f9f7ebe9545f9f"></a><!-- doxytag: member="BloombergLP::bslstl::operator==" ref="ga151dad22b647ff8e88f9f7ebe9545f9f" args="(const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators have the same value and <code>false</code> otherwise. Two iterators have the same value if they refer to the same node in the same hash table, or if both iterators are positioned after the end of a hash table bucket. </p>

</div>
</div>
<a class="anchor" id="gae4044832cad05668b1bfebe1c93c13aa"></a><!-- doxytag: member="BloombergLP::bslstl::operator!=" ref="gae4044832cad05668b1bfebe1c93c13aa" args="(const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3f4a64d810d76baa378444e8bf11a1ed"></a><!-- doxytag: member="BloombergLP::bslstl::operator!=" ref="ga3f4a64d810d76baa378444e8bf11a1ed" args="(const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf71d9015604d57b2f67a40ffd3442df6"></a><!-- doxytag: member="BloombergLP::bslstl::operator!=" ref="gaf71d9015604d57b2f67a40ffd3442df6" args="(const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6c82e3668693f7da12f69f8ff807bfe4"></a><!-- doxytag: member="BloombergLP::bslstl::operator!=" ref="ga6c82e3668693f7da12f69f8ff807bfe4" args="(const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators do not have the same value and <code>false</code> otherwise. Two iterators do not have the same value if they refer to the different nodes in the same hash table, or if either (but not both) of the iterators are positioned after the end of a hash table bucket. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
