<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslstl_hashtableiterator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_hashtableiterator<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL compliant iterator for hash tables.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef NcType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga13d5b9c9f7c8c242b770fc914d4e24cb">BloombergLP::bslstl::HashTableIterator::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef DIFFERENCE_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga426f4f62748b4597ad3def8bbb7d313b">BloombergLP::bslstl::HashTableIterator::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#gab022d07f503bac77df4a762c53f7b471">BloombergLP::bslstl::HashTableIterator::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga64719af257dc3eaa6879cecb410a506b">BloombergLP::bslstl::HashTableIterator::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::forward_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#gac0ddff5788cb1215823b5a532f8706e8">BloombergLP::bslstl::HashTableIterator::iterator_category</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#gabd3a8077b0b8be3d16a3d51d9c1b5f38">BloombergLP::bslstl::HashTableIterator::HashTableIterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga2d9b15b5dde881a14c069b9550759dd8">BloombergLP::bslstl::HashTableIterator::HashTableIterator</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga5efbcc2543addd3618fccc493c19e4f8">BloombergLP::bslstl::HashTableIterator::HashTableIterator</a> (const NcIter &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#gaf8c90762fbf52bd4cc4341988a7f5f5f">BloombergLP::bslstl::HashTableIterator::~HashTableIterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HashTableIterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga23f4dfaae18571ce48d693a4f3b84111">BloombergLP::bslstl::HashTableIterator::operator=</a> (const HashTableIterator &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HashTableIterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga4d024ab3ab43baccab9abd5b5b143d9e">BloombergLP::bslstl::HashTableIterator::operator++</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HashTableIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#gaea1148dd029151b4e7d9d73bf6aef13d">BloombergLP::bslstl::HashTableIterator::operator++</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga1be4388f2dbaa7db041d8292c8af5e45">BloombergLP::bslstl::HashTableIterator::operator*</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga6cd07454cbd07325094f1f2480197a59">BloombergLP::bslstl::HashTableIterator::operator-&gt;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#gae7436ce33bd669753885c2912a3dd15f">BloombergLP::bslstl::HashTableIterator::node</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga7d6922b7b3a249484e9d09b6dbb66133">BloombergLP::bslstl::operator==</a> (const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#gad9e3a5f0f3480ca85dc47d609f818d34">BloombergLP::bslstl::operator==</a> (const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga492a54267a4bd1900fdc2b515fd0322c">BloombergLP::bslstl::operator==</a> (const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga1153b8ba0d4a2427c48b02e1dd8c72f1">BloombergLP::bslstl::operator==</a> (const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga8cd2139d3b7893f392993b4da7fd47ca">BloombergLP::bslstl::operator!=</a> (const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#gacc0e5b18831c4d0b589512ac5e9c0128">BloombergLP::bslstl::operator!=</a> (const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#gabd8157342fff04065cf60ba5ea81c061">BloombergLP::bslstl::operator!=</a> (const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__hashtableiterator.html#ga56f6384f1a95f95c91fa4ff5704a6513">BloombergLP::bslstl::operator!=</a> (const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL compliant iterator for hash tables. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">bslstl::HashTableIterator</a> </td><td>an STL compliant forward iterator  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__bidirectionallink.html" title="Provide a basic link type for building doubly-linked lists.">Component bslalg_bidirectionallink</a>, <a class="el" href="group__bslstl__unorderedmap.html" title="Provide an STL-compliant unordered_map class.">Component bslstl_unorderedmap</a>, <a class="el" href="group__bslstl__unorderedset.html" title="Provide an STL-compliant unordered_set class.">Component bslstl_unorderedset</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides an STL-compliant forward iterator over the elements of a hash table. The requirements of a STL forward iterator are outlined in the C++11 standard in section [24.2.5] under the tag [forward.iterators]. A <code><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">HashTableIterator</a></code> object is parameterized on <code>VALUE_TYPE</code>, <code>', and 'DIFFERENCE_TYPE</code>. The parameterized <code>VALUE_TYPE</code> indicates the type of the value to which this iterator provides as references, and may be const-qualified for constant iterators. The parameterized <code>' shall provide a static 'extractValue</code> member function returning a reference values stored through <code>bslstl::BidirectionalLink *</code> pointers to nodes in the hash table data structure. Note that <code>VALUE_TYPE</code> may have additional const-qualification over the type of reference returned by the '', in order to support constant iterators. Finally, the parameterized <code>DIFFERENCE_TYPE</code> determines the (standard mandated) <code>difference_type</code> for the iterator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga13d5b9c9f7c8c242b770fc914d4e24cb"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::value_type" ref="ga13d5b9c9f7c8c242b770fc914d4e24cb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef NcType <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga426f4f62748b4597ad3def8bbb7d313b"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::difference_type" ref="ga426f4f62748b4597ad3def8bbb7d313b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DIFFERENCE_TYPE <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab022d07f503bac77df4a762c53f7b471"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::pointer" ref="gab022d07f503bac77df4a762c53f7b471" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE* <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga64719af257dc3eaa6879cecb410a506b"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::reference" ref="ga64719af257dc3eaa6879cecb410a506b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE&amp; <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac0ddff5788cb1215823b5a532f8706e8"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::iterator_category" ref="gac0ddff5788cb1215823b5a532f8706e8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::forward_iterator_tag <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::iterator_category<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gabd3a8077b0b8be3d16a3d51d9c1b5f38"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::HashTableIterator" ref="gabd3a8077b0b8be3d16a3d51d9c1b5f38" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::HashTableIterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator object with the default value for this type. All default-constructed <code><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">HashTableIterator</a></code> objects represent non-dereferenceable iterators into the same empty range. They do not have a singular value. </p>

</div>
</div>
<a class="anchor" id="ga2d9b15b5dde881a14c069b9550759dd8"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::HashTableIterator" ref="ga2d9b15b5dde881a14c069b9550759dd8" args="(bslalg::BidirectionalLink *node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::HashTableIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>create an iterator referring to the specified <code>node</code>. the behavior is undefined unless <code>node</code> is of the parameterized <code>NODE</code>, which is derived from <code><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a></code>. Note that this constructor is an implementation detail and is not part of the C++ standard. </p>

</div>
</div>
<a class="anchor" id="ga5efbcc2543addd3618fccc493c19e4f8"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::HashTableIterator" ref="ga5efbcc2543addd3618fccc493c19e4f8" args="(const NcIter &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::HashTableIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">NcIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator having the same value as the specified <code>original</code>. Note that this operation is either defined by the constructor taking <code>NcIter</code> (if <code>NcType</code> is the same as <code>VALUE_TYPE</code>), or generated automatically by the compiler. Also note that this constructor cannot be defined explicitly (without using <code>bsls::enableif</code>) to avoid a duplicate declaration when <code>NcType</code> is the same as <code>VALUE_TYPE</code>. </p>

</div>
</div>
<a class="anchor" id="gaf8c90762fbf52bd4cc4341988a7f5f5f"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::~HashTableIterator" ref="gaf8c90762fbf52bd4cc4341988a7f5f5f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::~HashTableIterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga23f4dfaae18571ce48d693a4f3b84111"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::operator=" ref="ga23f4dfaae18571ce48d693a4f3b84111" args="(const HashTableIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HashTableIterator&amp; <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy the value of the specified <code>rhs</code> to this iterator. Return a reference to this modifiable object. Note that this method's definition is compiler generated. </p>

</div>
</div>
<a class="anchor" id="ga4d024ab3ab43baccab9abd5b5b143d9e"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::operator++" ref="ga4d024ab3ab43baccab9abd5b5b143d9e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HashTableIterator&amp; <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move this iterator to the next element in the hash table and return a reference providing modifiable access to this iterator. The behavior is undefined unless the iterator refers to a valid (not yet erased) node a hash table. </p>

</div>
</div>
<a class="anchor" id="gaea1148dd029151b4e7d9d73bf6aef13d"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::operator++" ref="gaea1148dd029151b4e7d9d73bf6aef13d" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HashTableIterator <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move this iterator to the next element in the hash table and return value of this iterator prior to this call. The behavior is undefined unless the iterator refers to a valid (not yet erased) node a hash table. </p>

</div>
</div>
<a class="anchor" id="ga1be4388f2dbaa7db041d8292c8af5e45"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::operator*" ref="ga1be4388f2dbaa7db041d8292c8af5e45" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the value (of the parameterized <code>VALUE_TYPE</code>) of the element at which this iterator is positioned. The behavior is undefined unless the iterator refers to a valid (not yet erased) node a hash table. </p>

</div>
</div>
<a class="anchor" id="ga6cd07454cbd07325094f1f2480197a59"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::operator&#45;&gt;" ref="ga6cd07454cbd07325094f1f2480197a59" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the value (of the parameterized <code>VALUE_TYPE</code>) of the element at which this iterator is positioned. The behavior is undefined unless the iterator refers to a valid (not yet erased) node a hash table. </p>

</div>
</div>
<a class="anchor" id="gae7436ce33bd669753885c2912a3dd15f"></a><!-- doxytag: member="BloombergLP::bslstl::HashTableIterator::node" ref="gae7436ce33bd669753885c2912a3dd15f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;::node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the list-node at which this iterator is positioned, or 0 if this iterator is positioned after the end of a list. Note that this method is an implementation detail and is not part of the C++ standard. </p>

</div>
</div>
<a class="anchor" id="ga7d6922b7b3a249484e9d09b6dbb66133"></a><!-- doxytag: member="BloombergLP::bslstl::operator==" ref="ga7d6922b7b3a249484e9d09b6dbb66133" args="(const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad9e3a5f0f3480ca85dc47d609f818d34"></a><!-- doxytag: member="BloombergLP::bslstl::operator==" ref="gad9e3a5f0f3480ca85dc47d609f818d34" args="(const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga492a54267a4bd1900fdc2b515fd0322c"></a><!-- doxytag: member="BloombergLP::bslstl::operator==" ref="ga492a54267a4bd1900fdc2b515fd0322c" args="(const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1153b8ba0d4a2427c48b02e1dd8c72f1"></a><!-- doxytag: member="BloombergLP::bslstl::operator==" ref="ga1153b8ba0d4a2427c48b02e1dd8c72f1" args="(const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators have the same value and <code>false</code> otherwise. Two iterators have the same value if they refer to the same node in the same hash table, or if both iterators are positioned after the end of a hash table. </p>

</div>
</div>
<a class="anchor" id="ga8cd2139d3b7893f392993b4da7fd47ca"></a><!-- doxytag: member="BloombergLP::bslstl::operator!=" ref="ga8cd2139d3b7893f392993b4da7fd47ca" args="(const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacc0e5b18831c4d0b589512ac5e9c0128"></a><!-- doxytag: member="BloombergLP::bslstl::operator!=" ref="gacc0e5b18831c4d0b589512ac5e9c0128" args="(const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabd8157342fff04065cf60ba5ea81c061"></a><!-- doxytag: member="BloombergLP::bslstl::operator!=" ref="gabd8157342fff04065cf60ba5ea81c061" args="(const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga56f6384f1a95f95c91fa4ff5704a6513"></a><!-- doxytag: member="BloombergLP::bslstl::operator!=" ref="ga56f6384f1a95f95c91fa4ff5704a6513" args="(const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators do not have the same value and <code>false</code> otherwise. Two iterators do not have the same value if they refer to the different nodes in the same hash table, or if either (but not both) of the iterators are positioned after the end of a hash table. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
