<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BSL 2.20 OSS: bslstl_sharedptr Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_sharedptr<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a generic reference-counted shared pointer wrapper.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt; ELEMENT_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt; LHS_TYPE, RHS_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1owner__less_3_01shared__ptr_3_01ELEMENT__TYPE_01_4_01_4.html">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1owner__less_3_01weak__ptr_3_01ELEMENT__TYPE_01_4_01_4.html">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01shared__ptr_3_01ELEMENT__TYPE_01_4_01_4.html">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtr__DefaultDeleter.html">bslstl::SharedPtr_DefaultDeleter&lt; ANY_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtr__ImpUtil.html">bslstl::SharedPtr_ImpUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtr__SwapUtil.html">bslstl::SharedPtr_SwapUtil</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ELEMENT_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga61ba33bd2aeb0d92257c509d5871e5e2">bsl::shared_ptr::element_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ELEMENT_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga499733138e91edd57c5e1094a3a3ab57">bsl::shared_ptr::ElementType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ELEMENT_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab3b2afafcf0e37543aa0bf0e8c7803f5">bsl::weak_ptr::element_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ELEMENT_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga5d753b3327b24f518ab0d05f20a8e985">bsl::weak_ptr::ElementType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad18ba3b1d12a9f2d1fdb0ef39acb2dc3">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::first_argument_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9482ae2147e2729abd1ce870a9667b6a">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::second_argument_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef weak_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6992b48fcdcae895c9039a318f4796c2">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::first_argument_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef weak_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga06d414bbe414681c2e68d25a25b0f824">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::second_argument_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gabeaf6a273e56efa86bf7f783d0fc2f01">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::argument_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga7616cc4e8610c55e5e215c9d352a1e0c">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::result_type</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaca7d79d152d01a4c84f0abf8700d21ec">bsl::shared_ptr::BSLMF_NESTED_TRAIT_DECLARATION</a> (shared_ptr, BloombergLP::bslmf::HasPointerSemantics)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gabcc0de1c75fa2a6bf722f90eb97f5877">bsl::shared_ptr::BSLMF_NESTED_TRAIT_DECLARATION</a> (shared_ptr, BloombergLP::bslmf::IsBitwiseMoveable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga25bfad5e168d83249437014e7b6b8892">bsl::shared_ptr::shared_ptr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga5d2c2bd0c5dedf8e1198be362c0e0a82">bsl::shared_ptr::shared_ptr</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga841c0f3459e54c1bf2158eb56b285093">bsl::shared_ptr::shared_ptr</a> (COMPATIBLE_TYPE *ptr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab7e1c63bc0f6cdf8a18745b0c52139ea">bsl::shared_ptr::shared_ptr</a> (COMPATIBLE_TYPE *ptr, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2a2e4bbff3006535d3173733b9f8ae2e">bsl::shared_ptr::shared_ptr</a> (ELEMENT_TYPE *ptr, BloombergLP::bslma::SharedPtrRep *rep)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2db442bb3e385f4935f2e779f73631cd">bsl::shared_ptr::shared_ptr</a> (COMPATIBLE_TYPE *ptr, DELETER *const &amp;deleter)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad777109e95969ee05342235b11034b71">bsl::shared_ptr::shared_ptr</a> (COMPATIBLE_TYPE *ptr, const DELETER &amp;deleter, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DELETER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf12a5d7a0361ed3bde88f59deaba07e4">bsl::shared_ptr::shared_ptr</a> (nullptr_t nullPointerLiteral, const DELETER &amp;deleter, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaadfe208676a03d4f1a718ac73b9f02e5">bsl::shared_ptr::shared_ptr</a> (nullptr_t nullPointerLiteral, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad32ea0635de6a74d765ff432e7b6567e">bsl::shared_ptr::shared_ptr</a> (BloombergLP::bslma::ManagedPtr&lt; COMPATIBLE_TYPE &gt; managedPtr, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga54a369c9151825ea5e7fd6f6fa173845">bsl::shared_ptr::shared_ptr</a> (std::auto_ptr&lt; COMPATIBLE_TYPE &gt; &amp;autoPtr, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa9b51141c8cfd23be3242d3176663ed1">bsl::shared_ptr::shared_ptr</a> (std::auto_ptr_ref&lt; ELEMENT_TYPE &gt; autoRef, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga12461f1c2a32564f2e6aed992f147811">bsl::shared_ptr::shared_ptr</a> (const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga52fd5aa2c3c730f07461871d120d2030">bsl::shared_ptr::shared_ptr</a> (const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae1ba18a40fd81b46b1a579a0500164f2">bsl::shared_ptr::shared_ptr</a> (const shared_ptr &amp;original)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga00a7faf4ca60527b1506d9f90696d904">bsl::shared_ptr::shared_ptr</a> (const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaec035331c8d985691fd7c5929173259a">bsl::shared_ptr::~shared_ptr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">shared_ptr &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga1888243089d89d2d68487862ebe43eb8">bsl::shared_ptr::operator=</a> (const shared_ptr &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga40dddf94f309f6c0cfbe24d83a175f4c">bsl::shared_ptr::operator=</a> (const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga8d417935c309096fbd01300a0cbd16d4">bsl::shared_ptr::operator=</a> (std::auto_ptr&lt; COMPATIBLE_TYPE &gt; rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga1ac38efc4b5f79af4345a0ac95062fea">bsl::shared_ptr::load</a> (COMPATIBLE_TYPE *ptr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga25eab96a84917d2630d842f8701367fc">bsl::shared_ptr::load</a> (COMPATIBLE_TYPE *ptr, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga41ad7b8e77821c8bfdf6a2f8c33703d5">bsl::shared_ptr::load</a> (COMPATIBLE_TYPE *ptr, const DELETER &amp;deleter, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga37f640bcf2343ba65ee81e87a794e35f">bsl::shared_ptr::reset</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga1a88d1f07d3287acb0a33871f005c6be">bsl::shared_ptr::reset</a> (COMPATIBLE_TYPE *ptr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga12ad3c548d4fd47803dbb53c84c83524">bsl::shared_ptr::reset</a> (COMPATIBLE_TYPE *ptr, const DELETER &amp;deleter)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga880253329316183fae55d7670bf02cd5">bsl::shared_ptr::reset</a> (const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6e070cf988e142180441f65b18780a60">bsl::shared_ptr::clear</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga710218b15aeac3ab96e1269038a5aa21">bsl::shared_ptr::loadAlias</a> (const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaafc3dbf236739df5e017f082b64db6ea">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga03b9c9c63a4f1edccfb12a1a1075f72e">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga39246fe1a4523a81686c59232495a3f5">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab3fc58be99de52434c7974e3d6fa795e">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga652422a023fdaa27313f11d5d0ce384c">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga55af65860795eb30bad02fb83508d5e2">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9260b9f283836bd34814564f475759e3">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga02d1f3eb9a6c35471edb1ac1979b2da0">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae3066aae4de276e4327ba8d94a09f130">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga640c4b75bf8a9ac0fb2af1604605a833">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6565009e5d3855e7dc86f62de741b928">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa80b3327e687a5abf2c479986507d1aa">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga64401cd05e867290147dabf55dfbf3b1">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga51e62667dc0fa364f94d7d70d34f424b">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf998e53f52f90d11c49a564bdbf5ae61">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; ELEMENT_TYPE <br class="typebreak"/>
*, BloombergLP::bslma::SharedPtrRep * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga54f46f5bb220e063bd7c097b8302a838">bsl::shared_ptr::release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa54386ccdd73e52de6e463a6a86eb5b8">bsl::shared_ptr::swap</a> (shared_ptr&lt; ELEMENT_TYPE &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga31292c33e0410049a25c59c0c4b74049">bsl::shared_ptr::operator BoolType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">add_lvalue_reference<br class="typebreak"/>
&lt; ELEMENT_TYPE &gt;::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gac951c0325b8179829b715d8e9e48c595">bsl::shared_ptr::operator[]</a> (ptrdiff_t index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">add_lvalue_reference<br class="typebreak"/>
&lt; ELEMENT_TYPE &gt;::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga7561cfb064b73fc506712a0bf4b4f6d1">bsl::shared_ptr::operator*</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ELEMENT_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf0b9e0d68f8775c9f64c4df92d0f0d9b">bsl::shared_ptr::operator-&gt;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BloombergLP::bslma::SharedPtrRep *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa2c9e02ec8be7cb54746f8a41b0b5c12">bsl::shared_ptr::rep</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BloombergLP::bslma::ManagedPtr<br class="typebreak"/>
&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gacf1fa65139ac6e757e041353be18897e">bsl::shared_ptr::managedPtr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ELEMENT_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga48f002a13755bd11276a297079d8254e">bsl::shared_ptr::get</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gac888622df34e855572e95f569686308c">bsl::shared_ptr::owner_before</a> (const shared_ptr&lt; ANY_TYPE &gt; &amp;other) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga02e27d5b5b2bd9654791f92988bad1ea">bsl::shared_ptr::owner_before</a> (const weak_ptr&lt; ANY_TYPE &gt; &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga71ce3c0494bfb53b944cfad471f458cc">bsl::shared_ptr::unique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga577317da7b2aa99e58309cc7db1941de">bsl::shared_ptr::use_count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaffc20461dd32631b36b527f5e10adf48">bsl::shared_ptr::numReferences</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ELEMENT_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab307824fde26db221e749450e1cef713">bsl::shared_ptr::ptr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab53cc9a650d033a3674425de336b5c2b">bsl::weak_ptr::BSLALG_DECLARE_NESTED_TRAITS</a> (weak_ptr, BloombergLP::bslalg::TypeTraitBitwiseMoveable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9940e0e924ecfb7a502c2be1507dfd87">bsl::weak_ptr::weak_ptr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2a17d36d821e10ad16262d7f87a97555">bsl::weak_ptr::weak_ptr</a> (const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;original)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad7dac6852f146dbef51807a77d3f5cc4">bsl::weak_ptr::weak_ptr</a> (const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae3bcfbc12277b8ccce95c264e758b0cb">bsl::weak_ptr::weak_ptr</a> (const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga83c5b6a7e59b4b83fd92eb55dd94d13c">bsl::weak_ptr::~weak_ptr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">weak_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae6c7e632d8987a466915157a32f4e6c5">bsl::weak_ptr::operator=</a> (const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">weak_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gac8efdd1f795cb9be3badb432fe6c34ef">bsl::weak_ptr::operator=</a> (const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">weak_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga05faca26d2b73604656d4c409555cfa7">bsl::weak_ptr::operator=</a> (const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa78169359c056e9f1e460428cda0ec0d">bsl::weak_ptr::reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga54ee587ceb82f9e93065157fbb41e8c3">bsl::weak_ptr::swap</a> (weak_ptr&lt; ELEMENT_TYPE &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa75a9c8ed01c2a85f198fc83af4feee1">bsl::weak_ptr::expired</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga34104a654a94454a482db63125d71221">bsl::weak_ptr::lock</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9a2064e628262e110c375aeb57183324">bsl::weak_ptr::owner_before</a> (const shared_ptr&lt; ANY_TYPE &gt; &amp;other) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga404af02b5e8e178639b74bc2eb0c43f5">bsl::weak_ptr::owner_before</a> (const weak_ptr&lt; ANY_TYPE &gt; &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BloombergLP::bslma::SharedPtrRep *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gac873ee69042167ce8d257e2a682a83dd">bsl::weak_ptr::rep</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga99089c0e74da9d1aa08b8e273948953d">bsl::weak_ptr::use_count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaeb92560e5d8c45b7a24f98b7fcabcb33">bsl::weak_ptr::acquireSharedPtr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga85d8ae9bc109530b35e8264fd2e28b27">bsl::weak_ptr::numReferences</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga69302cc359a55777cf7b2fdf1bc68733">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6a6b3096a48bbb4ffb32e252f7000210">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less</a> (const owner_less &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2d82db2872d23d64adc96bae2cdc1334">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::~owner_less</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">owner_less &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa1c6ef296eea1a400edeccd9bbbf7112">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator=</a> (const owner_less &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9d485fbe334df7d34ae859bbba235ba8">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()</a> (const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga98b17ce9979a4c4fd1b844e2f0ba255d">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()</a> (const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga3e7af2d8e7c74ed24cbc226007c52c04">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()</a> (const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga4629e6da6ca7c4ead4fc636319152dd9">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga4d84a321ab410a3b0ef0dee34d2bb9ac">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less</a> (const owner_less &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6de2a85fec1f3effa0113f9d855a0bd9">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::~owner_less</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">owner_less &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga344b738470792c82bc59431461a22b1b">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator=</a> (const owner_less &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga02364b92faffdeba5f2680412e92dc79">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()</a> (const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaced4de8eeaa0af6c4d766e679a83b7bb">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()</a> (const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6eebdb7fff30f13ba6852f52622aee2e">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()</a> (const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga4f5045e9116c7afd014c1a6b0b41b5df">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gafa521e9dd34d7759aa9dbc726499045f">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga5d280e2986743f6ed16022c658fd911b">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae31bcc4016306c89295802b85d460490">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad689cb8f390fb7628ad531a3a11e1420">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()</a> (const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga1c1c2704b92642dd439cdad97a848d57">bsl::operator==</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga3a77beaa9951f55de2c793f025d576c4">bsl::operator!=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga66ad66d30f8224d17b9a095394af53a3">bsl::operator&lt;</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga18eb1b3e0476913d7ba6ba1af5f1bde0">bsl::operator&gt;</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf7d2404f8ddbbf36bbf27fe3fb8685a7">bsl::operator&lt;=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae407f6ed76abc4c51b61472c966c28fc">bsl::operator&gt;=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga02586f71629626fe00132cefebf9d0f6">bsl::operator==</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6ebbfc95461e707c1219dcfd8d5eb65c">bsl::operator==</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf6de5b2e8b27c39f51c873993d71f9ad">bsl::operator!=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae1eab178a468625aa5836216595b076c">bsl::operator!=</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf4c4bb456f48f1842cb63357527e9644">bsl::operator&lt;</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga88c588f14653fec148e0f293794505a4">bsl::operator&lt;</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2fcb633c59eda20af4715e688bf0dbee">bsl::operator&lt;=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga013b0c9607f5b710d6e54a95137560ed">bsl::operator&lt;=</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga8b013ca7ef46710259e40234cfcc735a">bsl::operator&gt;</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaeb88e103f0bc7111f829207a03644bcb">bsl::operator&gt;</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gac55976d83a9c4bb361e6d9acdb221405">bsl::operator&gt;=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad53c3f8eaccc4210b0d6aa129870e5f8">bsl::operator&gt;=</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::basic_ostream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga3c14f6b0f548e336c44341124f278434">bsl::operator&lt;&lt;</a> (std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;stream, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga050d5c3fbf77c1ddc00d3e18c07cebc8">bsl::swap</a> (shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; TO_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga903f6e4e7b2befd616936456786efa34">bsl::const_pointer_cast</a> (const shared_ptr&lt; FROM_TYPE &gt; &amp;source)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; TO_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa4dded295fd97099aa32efb1d6e2a054">bsl::dynamic_pointer_cast</a> (const shared_ptr&lt; FROM_TYPE &gt; &amp;source)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; TO_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga22893acbe6dca3b4184b1b5f92891c09">bsl::static_pointer_cast</a> (const shared_ptr&lt; FROM_TYPE &gt; &amp;source)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad7f43c35a15e87ad6e3f859c47f135f4">bsl::swap</a> (weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa1e0c5e3e5a6041d830b7909dfe00bbd">bslstl::SharedPtrUtil::staticCast</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gafcce9eb23f8b3a7c494351c7cf9246f7">bslstl::SharedPtrUtil::constCast</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga69f6feecf72eebbdb5154d80b313cea6">bslstl::SharedPtrUtil::dynamicCast</a> (<a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *target, const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf025d8bc5b749fb04ae5d983e9fb605f">bslstl::SharedPtrUtil::staticCast</a> (<a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *target, const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa7c3c7f1ae148cf6352b0fa6708a4aff">bslstl::SharedPtrUtil::constCast</a> (<a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *target, const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga08e81fb21b279dfe9d5d1c18e7e8eb13">bslstl::SharedPtrUtil::createInplaceUninitializedBuffer</a> (bsl::size_t bufferSize, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td colspan="2"><h2><a name="friend-members"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9a4da829475f0cf1809fc6ef555ffe06">bsl::shared_ptr::shared_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga73fb185cab8b7bb5f231491bb497071c">bsl::weak_ptr::weak_ptr</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread-Safety</a> <ul>
<li>
<a href="#3.1.1">Shared and Weak References</a> </li>
</ul>
</li>
<li>
<a href="#3.2">In-place/Out-of-place Representations</a> <ul>
<li>
<a href="#3.2.1">Weak Pointers using "in-place" or Pooled Shared Pointer Representations</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Correct Usage of the Allocator Model</a> </li>
<li>
<a href="#3.4">Deleters</a> </li>
<li>
<a href="#3.5">Aliasing</a> </li>
<li>
<a href="#3.6">Comparison of Shared Pointers and Conversion to <code>bool</code></a> </li>
<li>
<a href="#3.7">Type Casting</a> <ul>
<li>
<a href="#3.7.1">Implicit Casting</a> </li>
<li>
<a href="#3.7.2">Explicit Casting</a> </li>
</ul>
</li>
<li>
<a href="#3.8">Converting to and from <code>BloombergLP::bslma::ManagedPtr</code></a> </li>
<li>
<a href="#3.9">Storing a <code>shared_ptr</code> in an Invokable in a <code>bdef_Function</code> object</a> </li>
<li>
<a href="#3.10">C++ Standard Compliance</a> </li>
<li>
<a href="#3.11">Usage</a> <ul>
<li>
<a href="#3.11.1">Example 1: Basic Usage</a> </li>
<li>
<a href="#3.11.2">Using Custom Deleters</a> </li>
<li>
<a href="#3.11.3">Example 2: Nil Deleters</a> <ul>
<li>
<a href="#3.11.3.1">Example 3: Custom Deleters</a> </li>
</ul>
</li>
<li>
<a href="#3.11.4">Implementation Hiding</a> </li>
<li>
<a href="#3.11.5">Example 4: Hidden Interfaces</a> </li>
<li>
<a href="#3.11.6">Example 5: Opaque Types</a> </li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Thread-Safety</a> <ul>
<li>
<a href="#4.1.1">Weak Pointers using "in-place" or Pooled Shared Pointer Representations</a> </li>
</ul>
</li>
<li>
<a href="#4.2">Usage</a> <ul>
<li>
<a href="#4.2.1">Example 1: Basic Usage</a> </li>
<li>
<a href="#4.2.2">Example 2: Breaking Cyclical Dependencies</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a generic reference-counted shared pointer wrapper. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a> </td><td>shared pointer  </td></tr>
<tr>
<td><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a> </td><td>"weak" reference to reference-counted shared object  </td></tr>
<tr>
<td><a class="el" href="structbslstl_1_1SharedPtrUtil.html">bslstl::SharedPtrUtil</a> </td><td>shared pointer utility functions  </td></tr>
<tr>
<td><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a> </td><td>no-op deleter  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__managedptr.html" title="Provide a managed pointer class.">Component bslma_managedptr</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a thread-safe, generic, reference-counted "smart pointer" to support "shared ownership" of objects (of parameterized <code>ELEMENT_TYPE</code>). Shared pointers implement a form of the "envelope/letter" idiom. For each shared object, a representation that manages the number of references to it is created. Many shared pointers can simultaneously refer to the same shared object by storing a reference to the same representation. Shared pointers also implement the "construction is
 acquisition, destruction is release" idiom. When a shared pointer is created it increments the number of shared references to the shared object that was specified to its constructor (or was referred to by a shared pointer passed to the copy constructor). When a shared pointer is assigned to or destroyed, then the number of shared references to the shared object is decremented. When all references to the shared object are released, both the representation and the object are destroyed. <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> emulates the interface of a native pointer. The shared object may be accessed directly using the <code>-&gt;</code> operator, or the dereference operator (operator <code>*</code>) can be used to obtain a reference to the shared object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread-safety"></a> <a class="anchor" id="description.thread-safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread-Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section qualifies the thread-safety of <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> objects themselves rather than the thread-safety of the objects being referenced. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to access or modify two distinct <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> objects simultaneously, each from a separate thread, even if they share ownership of a common object. It is safe to access a single <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object simultaneously from two or more separate threads, provided no other thread is simultaneously modifying the object. It is not safe to access or modify a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object in one thread while another thread modifies the same object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to access, modify, copy, or delete a shared pointer in one thread, while other threads access or modify other shared pointers pointing to or managing the same object (the reference count is managed using atomic operations). However, there is no guarantee regarding the safety of accessing or modifying the object <em>referred</em> <em>to</em> by the shared pointer simultaneously from multiple threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="shared_and_weak_references"></a> <a class="anchor" id="thread-safety.shared_and_weak_references"></a> <a class="anchor" id="description.thread-safety.shared_and_weak_references"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Shared and Weak References: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are two types of references to shared objects: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>1) A shared reference allows users to share the ownership of an object and control its lifetime. A shared object is destroyed only when the last shared reference to it is released. A shared reference to an object can be obtained by creating a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> referring to it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>2) A weak reference provides users conditional access to an object without sharing its ownership (or affecting its lifetime). A shared object can be destroyed even if there are weak references to it. A weak reference to an object can be obtained by creating a <code><a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a></code> referring to the object from a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> referring to that object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="in-place~2Fout-of-place_representations"></a> <a class="anchor" id="description.in-place~2Fout-of-place_representations"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>In-place/Out-of-place Representations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> provides two types of representations: an out-of-place representation, and an in-place representation. Out-of-place representations are used to refer to objects that are constructed externally to their associated representations. Out-of-place objects are provided to a shared pointer by passing their address along with the deleter that should be used to destroy the object when all references to it have been released. In-place objects can be constructed directly within a shared pointer representation (see <code>createInplace</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Below we provide a diagram illustrating the differences between the two representations for a shared pointer to an <code>int</code>. First we create an <code>int</code> object on the heap, initialized to 10, and pass its address to a shared pointer constructor, resulting in an out-of-place representation for the shared object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a> nda;
  <span class="keywordtype">int</span> *value = <span class="keyword">new</span> (nda) <span class="keywordtype">int</span>(10);
  shared_ptr&lt;int&gt; outOfPlaceSharedPtr(value, &amp;nda);
</pre></div><br/>
<br/>
 Next we create an in-place representation of a shared <code>int</code> object that is also initialized to 10: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;int&gt; inPlaceSharedPtr;
  inPlaceSharedPtr.createInplace(&amp;nda, 10);
</pre></div><br/>
<br/>
 The memory layouts of these two representations are shown below (where <code>d_ptr_p</code> refers to the shared object and <code>d_rep_p</code> refers to the representation): <br/>
<br/>
<div class="fragment"><pre class="fragment">  Out-of-Place Representation                 In-Place Representation
  ----------------------------              ----------------------------

  +------------+                            +------------+
  |            |                            |            |
  |  d_ptr_p ------&gt;+-----------+           |  d_ptr_p ---------+
  |            |    |     10    |           |            |      |
  |            |    +-----------+           |            |      |
  |            |                            |            |      |
  |  d_rep_p ------&gt;+-----------+           |  d_rep_p ------&gt;+-v---------+
  |            |    | reference |           |            |    |+---------+|
  |            |    |  counts   |           |            |    ||    10   ||
  +------------+    +-----------+           +------------+    |+---------+|
                                                              | reference |
                                                              |  counts   |
                                                              +-----------+
</pre></div><br/>
<br/>
 An out-of-place representation is generally less efficient than an in-place representation since it usually requires at least two allocations (one to construct the object and one to construct the shared pointer representation for the object). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Creating an in-place shared pointer does not require the parameterized type to inherit from a special class (such as <code>bsl::enable_shared_from_this</code>); in that case, <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> supports up to fourteen arguments that can be passed directly to the object's constructor. For in-place representations, both the object and the representation can be constructed in one allocation as opposed to two, effectively creating an "intrusive" reference counter. Note that the size of the allocation is determined at compile-time from the combined footprint of the object and of the reference counter. It is also possible to create shared pointers to buffers whose sizes are determined at runtime, although such buffers consist of raw (uninitialized) memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="in-place~2Fout-of-place_representations.weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="description.in-place~2Fout-of-place_representations.weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Weak Pointers using "in-place" or Pooled Shared Pointer Representations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A weak pointer that is not in the empty state shares a common representation (used to refer to the shared object) with the shared (or other weak) pointer from which it was constructed, and holds this representation until it is either destroyed or reset. This common representation is not destroyed and deallocated (although the shared object itself may have been destroyed) until all weak references to that common representation have been released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to this behavior the <em>memory</em> <em>footprint</em> of shared objects that are constructed "in-place" in the shared pointer representation (see above) is not deallocated until all weak references to that shared object are released. Note that a shared object is always destroyed when the last shared reference to it is released. Also note that the same behavior applies if the shared object were obtained from a class that pools shared pointer representations (for example, <code>bcec_SharedObjectPool</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example suppose we have a class with a large memory footprint: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ClassWithLargeFootprint {
      <span class="comment">// This class has a large memory footprint.</span>

      <span class="comment">// TYPES</span>
      <span class="keyword">enum</span> { BUFFER_SIZE = 1024 };
          <span class="comment">// The size of the buffer owned by this &#39;class&#39;.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> d_buffer[BUFFER_SIZE];

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 We then create an "in-place" shared pointer to an object of <code>ClassWithLargeFootprint</code> using the <code>createInplace</code> method of <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code>. The <code>sp</code> shared pointer representation of <code>sp</code> will create a <code>ClassWithLargeFootprint</code> object "in-place": <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;ClassWithLargeFootprint&gt; sp;
  sp.createInplace();
</pre></div><br/>
<br/>
 Next we construct a weak pointer from this (in-place) shared pointer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  weak_ptr&lt;ClassWithLargeFootprint&gt; wp(sp);
</pre></div><br/>
<br/>
 Now releasing all shared references to the shared object (using the <code>reset</code> function) causes the object's destructor to be called, but the representation is not destroyed (and the object's footprint is not deallocated) until <code>wp</code> releases its weak reference: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sp.reset(); <span class="comment">// The object&#39;s footprint is not deallocated until all weak</span>
              <span class="comment">// references to it are released.</span>

  wp.reset(); <span class="comment">// The release of the *last* weak reference results in the</span>
              <span class="comment">// destruction and deallocation of the representation and the</span>
              <span class="comment">// object&#39;s footprint.</span>
</pre></div><br/>
<br/>
 If a shared object has a large footprint, and the client anticipates there will be weak references to it, then an out-of-place shared pointer representation may be preferred because it destroys the shared object and deallocates its footprint when the last <em>shared</em> reference is released, regardless of whether there are any outstanding weak references to the same representation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="correct_usage_of_the_allocator_model"></a> <a class="anchor" id="description.correct_usage_of_the_allocator_model"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Correct Usage of the Allocator Model: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that once constructed, there is no difference in type, usage, or efficiency between in-place and out-of-place shared pointers, except that an in-place shared pointer will exhibit greater locality of reference and faster destruction (because there is only one allocated block). Also note that an object created with an allocator needs to have this allocator specified as its last constructor argument, but this allocator may be different from the one passed as the first argument to <code>createInplace</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, consider the following snippet of code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator1, *allocator2;
  <span class="comment">// ...</span>
  shared_ptr&lt;bsl::string&gt; ptr;
  ptr.createInplace(allocator1, <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>(<span class="stringliteral">&quot;my string&quot;</span>), allocator2);
</pre></div><br/>
<br/>
 Here <code>allocator1</code> is used to obtain the shared pointer representation and the in-place <code>bsl::string</code> object, and <code>allocator2</code> is used by the <code>bsl::string</code> object (having the value "my string") for its memory allocations. Typically, both allocators will be the same, and so the same allocator will need to be specified twice. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="deleters"></a> <a class="anchor" id="description.deleters"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the last shared reference to a shared object is released, the object is destroyed using the "deleter" provided when the associated shared pointer representation was created. <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> supports two kinds of "deleter" objects, which vary in how they are invoked. A "function-like" deleter is any language entity that can be invoked such that the expression <code>deleterInstance(objectPtr)</code> is a valid expression, and a "factory" deleter is any language entity that can be invoked such that the expression <code>deleterInstance.deleteObject(objectPtr)</code> is a valid expression, where <code>deleterInstance</code> is an instance of the "deleter" object, and <code>objectPtr</code> is a pointer to the shared object. In summary: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Deleter                     Expression used to destroy <span class="stringliteral">&#39;objectPtr&#39;</span>
  - - - - - - - - - - - -     - - - - - - - - - - - - - - - - - - -
  <span class="stringliteral">&quot;function-like&quot;</span>             deleterInstance(objectPtr);
  <span class="stringliteral">&quot;factory&quot;</span>                   deleterInstance.deleteObject(objectPtr);
</pre></div><br/>
<br/>
 The following are examples of function-like deleters that delete an object of <code>my_Type</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> deleteObject(my_Type *<span class="keywordtype">object</span>);
      <span class="comment">// Delete the specified &#39;object&#39;.</span>

  <span class="keywordtype">void</span> releaseObject(my_Type *<span class="keywordtype">object</span>);
      <span class="comment">// Release the specified &#39;object&#39;.</span>

  <span class="keyword">struct </span>FunctionLikeDeleterObject {
      <span class="comment">// This &#39;struct&#39; provides an &#39;operator()&#39; that can be used to delete a</span>
      <span class="comment">// &#39;my_Type&#39; object.</span>

      <span class="keywordtype">void</span> operator()(my_Type *<span class="keywordtype">object</span>);
          <span class="comment">// Destroy the specified &#39;object&#39;.</span>
  };
</pre></div><br/>
<br/>
 The following, on the other hand is an example of a factory deleter: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Factory {

     <span class="comment">// . . .</span>

     <span class="comment">// MANIPULATORS</span>
     my_Type *createObject(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
         <span class="comment">// Create a &#39;my_Type&#39; object.  Optionally specify a</span>
         <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
         <span class="comment">// 0, the currently installed default allocator is used.</span>

     <span class="keywordtype">void</span> deleteObject(my_Type *<span class="keywordtype">object</span>);
         <span class="comment">// Delete the specified &#39;object&#39;.</span>
  };

  <span class="keyword">class </span>my_Allocator : <span class="keyword">public</span> bslma::Allocator { <span class="comment">/* ... */</span> };
</pre></div><br/>
<br/>
 Note that <code>deleteObject</code> is provided by all <code>bslma</code> allocators and by any object that implements the <code>bcema_Deleter</code> protocol. Thus, any of these objects can be used as a factory deleter. The purpose of this design is to allow <code>bslma</code> allocators and factories to be used seamlessly as deleters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The selection of which expression is used by <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> to destroy a shared object is based on how the deleter is passed to the shared pointer object: Deleters that are passed by <em>address</em> are assumed to be factory deleters, while those that are passed by <em>value</em> are assumed to be function-like. Note that if the wrong interface is used for a deleter, i.e., if a function-like deleter is passed by pointer, or a factory deleter is passed by value, and the expression used to delete the object is invalid, a compiler diagnostic will be emitted indicating the error. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following are examples of constructing shared pointers with the addresses of factory deleters: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_Factory factory;
  my_Type *myPtr1 = factory.createObject();
  shared_ptr&lt;my_Type&gt; mySharedPtr1(myPtr1, &amp;factory, 0);

  bdema_SequentialAllocator sa;
  my_Type *myPtr2 = <span class="keyword">new</span> (sa) my_Type(&amp;sa);
  shared_ptr&lt;my_Type&gt; mySharedPtr2(myPtr2, &amp;sa);
</pre></div><br/>
<br/>
 Note that the deleters are passed <em>by address</em> in the above examples. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following are examples of constructing shared pointers with function-like deleters: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_Type *getObject(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);

  my_Type *myPtr3 = getObject();
  shared_ptr&lt;my_Type&gt; mySharedPtr3(myPtr3, &amp;deleteObject);

  my_Type *myPtr4 = getObject();
  FunctionLikeDeleterObject deleter;
  shared_ptr&lt;my_Type&gt; mySharedPtr4(myPtr4, deleter, &amp;sa);
</pre></div><br/>
<br/>
 Note that <code>deleteObject</code> is also passed by address, but <code>deleter</code> is passed by value in the above examples. Function-like deleter objects (passed by value) are stored by value in the representation and therefore <em>must</em> be copy-constructible. Note that even though the deleter may be passed by reference, it is a copy (owned by the shared pointer representation) that is invoked and thus the <code>deleterInstance</code> is not required, nor assumed, to be non-modifiable. (For the example above, note that <code>operator()</code> is intentionally <em>not</em> defined <code>const</code>.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="aliasing"></a> <a class="anchor" id="description.aliasing"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Aliasing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> supports a powerful "aliasing" feature. That is, a shared pointer can be constructed to refer to a shared object of a certain type while the shared pointer representation it holds refers to a shared object of any (possibly different) type. All references are applied to the "aliased" shared object referred to by the representation and is used for reference counting. This "aliased" shared object is passed to the deleter upon destruction of the last instance of that shared pointer. Consider the following snippet of code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Event { <span class="comment">/* ... */</span> };
  <span class="keywordtype">void</span> getEvents(<a class="code" href="classbsl_1_1list.html">bsl::list&lt;Event&gt;</a> *list);

  <span class="keywordtype">void</span> enqueueEvents(bcec_Queue&lt;shared_ptr&lt;Event&gt; &gt; *queue)
  {
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;Event&gt;</a> eventList;
      getEvents(&amp;eventList);
      <span class="keywordflow">for</span> (<a class="code" href="classbsl_1_1List__Iterator.html">bsl::list&lt;Event&gt;::iterator</a> it = eventList.<a class="code" href="group__bslstl__list.html#ga5c31176fa2f214a7932d504200b37f9f">begin</a>();
           it != eventList.<a class="code" href="group__bslstl__list.html#gaaff91bdeee8bf00648c6f0ea63e89c5d">end</a>();
           ++it) {
          shared_ptr&lt;Event&gt; e;
          e.createInplace(0, *it);  <span class="comment">// Copy construct the event into a new</span>
                                    <span class="comment">// shared ptr.</span>
          queue-&gt;pushBack(e);
      }
  }
</pre></div><br/>
<br/>
 In the above example, <code>getEvents</code> loads into the provided <code><a class="el" href="classbsl_1_1list.html">bsl::list</a></code> a sequence of event objects. The <code>enqueueEvents</code> function constructs an empty list and calls <code>getEvents</code> to fill the list with <code>Event</code> objects. Once the event list is filled, each event item is pushed as a shared pointer (presumably because events are "expensive" to construct and may be referenced simultaneously from multiple threads) onto the provided queue. Since the individual event items are contained by value within the list, pointers to them cannot be passed if it cannot be guaranteed that they will not live beyond the lifetime of the list itself. Therefore, an expensive copy operation is required to create individually-managed instances of each of the list items. The <code>createInplace</code> operation is used to reduce the number of required allocations, but this might still be too expensive. Now consider the following alternate implementation of <code>enqueueEvents</code> using the <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> aliasing feature: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> enqueueEvents(bcec_Queue&lt;shared_ptr&lt;Event&gt; &gt; *queue)
  {
      shared_ptr&lt;bsl::list&lt;Event&gt; &gt; eventList;
      eventList.createInplace(0);  <span class="comment">// Construct a shared pointer</span>
                                   <span class="comment">// to the event list containing</span>
                                   <span class="comment">// all of the events.</span>
      getEvents(eventList.ptr());

      <span class="keywordflow">for</span> (<a class="code" href="classbsl_1_1List__Iterator.html">bsl::list&lt;Event&gt;::iterator</a> it = eventList-&gt;begin();
           it != eventList-&gt;end();
           ++it) {
          <span class="comment">// Push each event onto the queue as an alias of the &#39;eventList&#39;</span>
          <span class="comment">// shared pointer.  When all the alias references have been</span>
          <span class="comment">// released, the event list will be destroyed deleting all the</span>
          <span class="comment">// events at once.</span>

          queue-&gt;pushBack(shared_ptr&lt;Event&gt;(eventList, &amp;*it));
      }
  }
</pre></div><br/>
<br/>
 In the implementation above, we create a single shared pointer to the <code>Event</code> list, <code>eventList</code>, and use that to create <code>Event</code> shared pointers that are aliased to <code>eventList</code>. The lifetime of each <code>Event</code> object is then tied to the <code>eventList</code> and it will not be destroyed until the <code>eventList</code> is destroyed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="comparison_of_shared_pointers_and_conversion_to_bool"></a> <a class="anchor" id="description.comparison_of_shared_pointers_and_conversion_to_bool"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Comparison of Shared Pointers and Conversion to bool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component does <em>not</em> allow comparisons of shared pointers, although it does allow a conversion to an "unspecified bool type" (which is <em>not</em> <code>bool</code>) so as to retain the "comparison to 0" idiom: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a> nda;
  shared_ptr&lt;int&gt; sp1(<span class="keyword">new</span> (nda) <span class="keywordtype">int</span>(), &amp;nda);
  <span class="keywordflow">if</span> (sp1) {   <span class="comment">// OK</span>
      <span class="comment">// . . .</span>
  }
</pre></div><br/>
<br/>
 The following attempts to compare two shared pointers: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;double&gt; sp2(<span class="keyword">new</span> (nda) <span class="keywordtype">int</span>(), &amp;nda);
  <span class="keywordflow">if</span> (sp1 &lt; sp2) {  <span class="comment">// ERROR</span>
      <span class="comment">// . . .</span>
  }
</pre></div><br/>
<br/>
 will both produce compilation errors, as will: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1map.html">bsl::map&lt;shared_ptr&lt;int&gt;</a>, <span class="keywordtype">int</span>&gt; sharedPtrMap;  <span class="comment">// ERROR</span>
</pre></div><br/>
<br/>
 (To be precise, the declaration of the map will not trigger an error, but the instantiation of any method that uses <code>std::less</code> will.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In order to index a map by a shared pointer type, use the functor provided by the <code>shared_ptrLess</code> class, as in: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1map.html">bsl::map&lt;shared_ptr&lt;int&gt;</a>, int, shared_ptrLess&gt; sharedPtrMap;
                                                                        <span class="comment">// OK</span>
</pre></div><br/>
<br/>
 <code>shared_ptrLess</code> compares the pointer values referred to by the shared pointer keys in the map to sort the elements. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="type_casting"></a> <a class="anchor" id="description.type_casting"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Type Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object of a given type can be implicitly or explicitly cast to a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> of another type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="implicit_casting"></a> <a class="anchor" id="type_casting.implicit_casting"></a> <a class="anchor" id="description.type_casting.implicit_casting"></a> <a class="anchor" id="3.7.1"></a> </dd></dl>
<dl class="user"><dt><b>Implicit Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>As with native pointers, a shared pointer to a derived type can be directly assigned to a shared pointer to a base type. In other words, if the following statements are valid: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>A { <span class="keyword">virtual</span> <span class="keywordtype">void</span> foo(); };  <span class="comment">// polymorphic type</span>
  <span class="keyword">class </span>B : <span class="keyword">public</span> A {};
  B *bp = 0;
  A *ap = bp;
</pre></div><br/>
<br/>
 then the following statements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;B&gt; spb;
  shared_ptr&lt;A&gt; spa;
  spa = spb;
</pre></div><br/>
<br/>
 and: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;B&gt; spb;
  shared_ptr&lt;A&gt; spa(spb);
</pre></div><br/>
<br/>
 are also valid. Note that in all of the above cases, the destructor of <code>B</code> will be invoked when the object is destroyed even if <code>A</code> does not provide a virtual destructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="explicit_casting"></a> <a class="anchor" id="type_casting.explicit_casting"></a> <a class="anchor" id="description.type_casting.explicit_casting"></a> <a class="anchor" id="3.7.2"></a> </dd></dl>
<dl class="user"><dt><b>Explicit Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Through "aliasing", a shared pointer of any type can be explicitly cast to a shared pointer of any other type using any legal cast expression. For example, to statically cast a shared pointer to type <code>A</code> (<code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;A&gt;</code>) to a shared pointer to type <code>B</code> (<code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;B&gt;</code>), one can simply do the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;A&gt; spa;
  shared_ptr&lt;B&gt; spb(spa, static_cast&lt;B *&gt;(spa.ptr()));
</pre></div><br/>
<br/>
 or even the less safe C-style cast: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;A&gt; spa;
  shared_ptr&lt;B&gt; spb(spa, (B *)(spa.ptr()));
</pre></div><br/>
<br/>
 For convenience, several utility functions are provided to perform common C++ casts. Dynamic casts, static casts, and <code>const</code> casts are all provided. Explicit casting is supported through the <code><a class="el" href="structbslstl_1_1SharedPtrUtil.html">bslstl::SharedPtrUtil</a></code> utility. The following example demonstrates the dynamic casting of a shared pointer to type <code>A</code> (<code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;A&gt;</code>) to a shared pointer to type <code>B</code> (<code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;B&gt;</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a> nda;
  shared_ptr&lt;A&gt; sp1(<span class="keyword">new</span> (nda) A(), &amp;nda);
  shared_ptr&lt;B&gt; sp2 = bslstl::SharedPtrUtil::dynamicCast&lt;B&gt;(sp1);
  shared_ptr&lt;B&gt; sp3;
  <a class="code" href="structbslstl_1_1SharedPtrUtil.html#a7a422696c4adaaaaf54b519943563277">bslstl::SharedPtrUtil::dynamicCast</a>(&amp;sp3, sp1);
  shared_ptr&lt;B&gt; sp4;
  sp4 = bslstl::SharedPtrUtil::dynamicCast&lt;B&gt;(sp1);
</pre></div><br/>
<br/>
 To test if the cast succeeded, simply test if the target shared pointer refers to a non-null value (assuming the source was not null, of course): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (sp2) {
      <span class="comment">// The cast succeeded.</span>
  } <span class="keywordflow">else</span> {
      <span class="comment">// The cast failed.</span>
  }
</pre></div><br/>
<br/>
 As previously stated, the shared object will be destroyed correctly regardless of how it is cast. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="converting_to_and_from_bloomberglp~3A~3Abslma~3A~3Amanagedptr"></a> <a class="anchor" id="description.converting_to_and_from_bloomberglp~3A~3Abslma~3A~3Amanagedptr"></a> <a class="anchor" id="converting_to_and_from_bloomberglp"></a> <a class="anchor" id="description.converting_to_and_from_bloomberglp"></a> <a class="anchor" id="3.8"></a> </dd></dl>
<dl class="user"><dt><b>Converting to and from BloombergLP::bslma::ManagedPtr: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> can be converted to a <code>BloombergLP::bslma::ManagedPtr</code> while still retaining proper reference counting. When a shared pointer is converted to a <code>BloombergLP::bslma::ManagedPtr</code>, the number of references to the shared object is incremented. When the managed pointer is destroyed (if not transferred to another managed pointer first), the number of references will be decremented. If the number of references reaches zero, then the shared object will be destroyed. The <code>managedPtr</code> function can be used to create a managed pointer from a shared pointer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> also can be constructed from a <code>BloombergLP::bslma::ManagedPtr</code>. The resulting shared pointer takes over the management of the object and will use the deleter from the original <code>BloombergLP::bslma::ManagedPtr</code> to destroy the managed object when all the references to that shared object are released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="storing_a_shared_ptr_in_an_invokable_in_a_bdef_function_object"></a> <a class="anchor" id="description.storing_a_shared_ptr_in_an_invokable_in_a_bdef_function_object"></a> <a class="anchor" id="3.9"></a> </dd></dl>
<dl class="user"><dt><b>Storing a shared_ptr in an Invokable in a bdef_Function object: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition to the guarantees already made in the <code>bdef_function</code> component, <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> also guarantees that storing a shared pointer to an invokable object in a <code>bdef_Function</code> object will be "in-place", i.e., it will not trigger memory allocation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="c++_standard_compliance"></a> <a class="anchor" id="description.c++_standard_compliance"></a> <a class="anchor" id="3.10"></a> </dd></dl>
<dl class="user"><dt><b>C++ Standard Compliance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a (subset of a) standard-compliant implementation of <code>std::shared_ptr</code> (sections 2.2.3 of the final "Technical Report on C++
 Library Extensions" and 20.9.12.2 of the current "Final Committee Draft,
 Standard for Programming Language C++"). Support for <code>std::weak_ptr</code> is provided in the <code><a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a></code> component. Also, this component allows conversion or assignment from <code>std::auto_ptr</code> and provides most of the interface of <code>std::shared_ptr</code>. In addition, it does not collaborate with types that derive from <code>std::enable_shared_this</code>: using <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> with such types will result in (very destructive) undefined behavior. The only global free function supplied with this component is <code>swap</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As mentioned in the section "Comparison of Shared Pointers" above, using comparison operators <code>operator&lt;</code>, <code>operator&lt;=</code>, <code>operator&gt;</code>, and <code>operator&gt;=</code>, and the corresponding specializations for <code>std::less</code>, <code>std::less_equal</code>, <code>bsl::greater</code>, and <code>bsl::greater_equal</code> with shared pointers, will cause a compilation error. And there is a comparison functor in <code><a class="el" href="structbslstl_1_1SharedPtrUtil.html">bslstl::SharedPtrUtil</a></code> for use in place of <code>std::less</code> in <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code> and other standard associative containers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, this component supports allocators following the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol and not the C++ Standard Allocators (section 20.1.2). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>CAVEAT: This implementation follows the BDE conventions on passing 0 as a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> argument. A user who wishes to remain compliant with future C++ Standard specifications should not rely on this default allocator behavior. To remain compliant with the standard <code>std::shared_ptr</code>, future versions of this component may use the <code>::operator delete</code> to destroy the shared object if an allocator was not specified to the appropriate method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.11"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following examples demonstrate various features and uses of shared pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_usage"></a> <a class="anchor" id="usage.example_1~3A_basic_usage"></a> <a class="anchor" id="description.usage.example_1~3A_basic_usage"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.11.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example demonstrates the creation of a shared pointer. First, we declare the type of object that we wish to manage: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyUser {
      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_name;
      <span class="keywordtype">int</span>         d_id;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      MyUser(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = 0) : d_name(alloc), d_id(0) {}
      MyUser(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name, <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = 0)
      : d_name(name, alloc)
      , d_id(id)
      {
      }
      MyUser(<span class="keyword">const</span> MyUser&amp; original, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = 0)
      : d_name(original.d_name, alloc)
      , d_id(original.d_id)
      {
      }

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> setName(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name) { d_name = name; }
      <span class="keywordtype">void</span> setId(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) { d_id = id; }

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_name; }
      <span class="keywordtype">int</span> id()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_id; }
  };
</pre></div><br/>
<br/>
 The <code>createUser</code> utility function (below) creates a <code>MyUser</code> object using the provided allocator and returns a shared pointer to the newly-created object. Note that the shared pointer's internal representation will also be allocated using the same allocator. Also note that if <code>allocator</code> is 0, the currently-installed default allocator is used. <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;MyUser&gt; createUser(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>       name,
                                     <span class="keywordtype">int</span>               <span class="keywordtype">id</span>,
                                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      allocator = <a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>(allocator);
      MyUser *user = <span class="keyword">new</span> (*allocator) MyUser(name, <span class="keywordtype">id</span>, allocator);
      <span class="keywordflow">return</span> shared_ptr&lt;MyUser&gt;(user, allocator);
  }
</pre></div><br/>
<br/>
 Since the <code>createUser</code> function both allocates the object and creates the shared pointer, it can benefit from the in-place facilities to avoid an extra allocation. Again, note that the representation will also be allocated using the same allocator (see the section "Correct Usage of the
 Allocator Model" above). Also note that if <code>allocator</code> is 0, the currently-installed default allocator is used. <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;MyUser&gt; createUser2(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>       name,
                                      <span class="keywordtype">int</span>               <span class="keywordtype">id</span>,
                                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      shared_ptr&lt;MyUser&gt; user;
      user.createInplace(allocator, name, <span class="keywordtype">id</span>, allocator);
      <span class="keywordflow">return</span> user;
  }
</pre></div><br/>
<br/>
 Note that the shared pointer allocates both the reference count and the <code>MyUser</code> object in a single region of memory (which is the memory that will eventually be deallocated), but refers to the <code>MyUser</code> object only. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="using_custom_deleters"></a> <a class="anchor" id="usage.using_custom_deleters"></a> <a class="anchor" id="description.usage.using_custom_deleters"></a> <a class="anchor" id="3.11.2"></a> </dd></dl>
<dl class="user"><dt><b>Using Custom Deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following examples demonstrate the use of custom deleters with shared pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_nil_deleters"></a> <a class="anchor" id="usage.example_2~3A_nil_deleters"></a> <a class="anchor" id="description.usage.example_2~3A_nil_deleters"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.11.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Nil Deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are cases when an interface calls for an object to be passed as a shared pointer, but the object being passed is not owned by the caller (e.g., a pointer to a static variable). In these cases, it is possible to create a shared pointer specifying <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code> as the deleter. The deleter function provided by <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code> is a no-op and does not delete the object. The following example demonstrates the use of <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> using a <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code>. The code uses the <code>MyUser</code> class defined in <a href="group__bslstl__sharedptr.html#example_1" class="el">Example 1</a>. In this example, an asynchronous transaction manager is implemented. Transactions are enqueued into the transaction manager to be processed at some later time. The user associated with the transaction is passed as a shared pointer. Transactions can originate from the "system" or from "users". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We first declare the transaction manager and transaction info classes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyTransactionInfo {
      <span class="comment">// Transaction Info...</span>
  };

  <span class="keyword">class </span>MyTransactionManager {

      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">int</span> enqueueTransaction(shared_ptr&lt;MyUser&gt;  user,
                             <span class="keyword">const</span> MyTransactionInfo&amp; transaction);
    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> MyUser *systemUser(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> enqueueSystemTransaction(<span class="keyword">const</span> MyTransactionInfo&amp; transaction);

      <span class="keywordtype">int</span> enqueueUserTransaction(<span class="keyword">const</span> MyTransactionInfo&amp; transaction,
                                 shared_ptr&lt;MyUser&gt;  user);

  };
</pre></div><br/>
<br/>
 The <code>systemUser</code> class method returns the same <code>MyUser</code> object and should not be destroyed by its users: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyUser *MyTransactionManager::systemUser(
                                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *<span class="comment">/* basicAllocator */</span>)
  {
      <span class="keyword">static</span> MyUser *systemUserSingleton;
      <span class="keywordflow">if</span> (!systemUserSingleton) {
          <span class="comment">// instantiate singleton in a thread-safe manner passing</span>
          <span class="comment">// &#39;basicAllocator&#39;</span>

          <span class="comment">// . . .</span>
      }
      <span class="keywordflow">return</span> systemUserSingleton;
  }
</pre></div><br/>
<br/>
 For enqueuing user transactions, simply proxy the information to <code>enqueueTransaction</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyTransactionManager::enqueueUserTransaction(
                                  <span class="keyword">const</span> MyTransactionInfo&amp; transaction,
                                  shared_ptr&lt;MyUser&gt;  user)
  {
      <span class="keywordflow">return</span> enqueueTransaction(user, transaction);
  }
</pre></div><br/>
<br/>
 For system transactions, we must use the <code>MyUser</code> objected returned from the <code>systemUser</code> <code>static</code> method. Since we do not own the returned object, we cannot directly construct a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object for it: doing so would result in the singleton being destroyed when the last reference to the shared pointer is released. To solve this problem, we construct a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object for the system user using a nil deleter. When the last reference to the shared pointer is released, although the deleter will be invoked to destroy the object, it will do nothing. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> MyTransactionManager::enqueueSystemTransaction(
                                        <span class="keyword">const</span> MyTransactionInfo&amp; transaction)
  {
      shared_ptr&lt;MyUser&gt; user(systemUser(),
                                   <a class="code" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a>(),
                                   0);
      <span class="keywordflow">return</span> enqueueTransaction(user, transaction);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_custom_deleters"></a> <a class="anchor" id="example_2.example_3~3A_custom_deleters"></a> <a class="anchor" id="usage.example_2.example_3~3A_custom_deleters"></a> <a class="anchor" id="description.usage.example_2.example_3~3A_custom_deleters"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="example_2.example_3"></a> <a class="anchor" id="usage.example_2.example_3"></a> <a class="anchor" id="description.usage.example_2.example_3"></a> <a class="anchor" id="3.11.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Custom Deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The role of a "deleter" is to allow users to define a custom "cleanup" for a shared object. Although cleanup generally involves destroying the object, this need not be the case. The following example demonstrates the use of a custom deleter to construct "locked" pointers. First we declare a custom deleter that, when invoked, releases the specified mutex and signals the specified condition variable. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_MutexUnlockAndBroadcastDeleter {

      <span class="comment">// DATA</span>
      bcemt_Mutex     *d_mutex_p;  <span class="comment">// mutex to lock (held, not owned)</span>
      bcemt_Condition *d_cond_p;   <span class="comment">// condition variable used to broadcast</span>
                                   <span class="comment">// (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_MutexUnlockAndBroadcastDeleter(bcemt_Mutex     *mutex,
                                        bcemt_Condition *cond)
          <span class="comment">// Create this &#39;my_MutexUnlockAndBroadcastDeleter&#39; object.  Use</span>
          <span class="comment">// the specified &#39;cond&#39; to broadcast a signal and the specified</span>
          <span class="comment">// &#39;mutex&#39; to serialize access to &#39;cond&#39;.  The behavior is</span>
          <span class="comment">// undefined unless &#39;mutex&#39; is not 0 and &#39;cond&#39; is not 0.</span>
      : d_mutex_p(mutex)
      , d_cond_p(cond)
      {
          <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(mutex);
          <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(cond);

          d_mutex_p-&gt;lock();
      }

      my_MutexUnlockAndBroadcastDeleter(
                                 my_MutexUnlockAndBroadcastDeleter&amp; original)
      : d_mutex_p(original.d_mutex_p)
      , d_cond_p(original.d_cond_p)
      {
      }
</pre></div><br/>
<br/>
 Since this deleter does not actually delete anything, <code>void *</code> is used in the signature of <code>operator()</code>, allowing it to be used with any type of object. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> operator()(<span class="keywordtype">void</span> *)
      {
          d_cond_p-&gt;broadcast();
          d_mutex_p-&gt;unlock();
      }
  };
</pre></div><br/>
<br/>
 Next we declare a thread-safe queue <code>class</code>. The <code>class</code> uses a non-thread-safe <code><a class="el" href="classbsl_1_1deque.html">bsl::deque</a></code> to implement the queue. Thread-safe <code>push</code> and <code>pop</code> operations that push and pop individual items are provided. For callers that wish to gain direct access to the queue, the <code>queue</code> method returns a shared pointer to the queue using the <code>my_MutexUnlockAndBroadcastDeleter</code>. Callers can safely access the queue through the returned shared pointer. Once the last reference to the pointer is released, the mutex will be unlocked and the condition variable will be signaled to allow waiting threads to re-evaluate the state of the queue. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT_TYPE&gt;
  <span class="keyword">class </span>my_SafeQueue {

      <span class="comment">// DATA</span>
      bcemt_Mutex      d_mutex;
      bcemt_Condition  d_cond;
      <a class="code" href="classbsl_1_1deque.html">bsl::deque&lt;ELEMENT_TYPE&gt;</a> d_queue;

      <span class="comment">// . . .</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> push(<span class="keyword">const</span> ELEMENT_TYPE&amp; obj);

      ELEMENT_TYPE pop();

      shared_ptr&lt;bsl::deque&lt;ELEMENT_TYPE&gt; &gt; queue();
  };

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT_TYPE&gt;
  <span class="keywordtype">void</span> my_SafeQueue&lt;ELEMENT_TYPE&gt;::push(<span class="keyword">const</span> ELEMENT_TYPE&amp; obj)
  {
      bcemt_LockGuard&lt;bcemt_Mutex&gt; lock(&amp;d_mutex);
      d_queue.push_back(obj);
      d_cond.signal();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT_TYPE&gt;
  ELEMENT_TYPE my_SafeQueue&lt;ELEMENT_TYPE&gt;::pop()
  {
      bcemt_LockGuard&lt;bcemt_Mutex&gt; lock(&amp;d_mutex);
      <span class="keywordflow">while</span> (!d_queue.size()) {
         d_cond.wait(&amp;d_mutex);
      }
      ELEMENT_TYPE value(d_queue.front());
      d_queue.pop_front();
      <span class="keywordflow">return</span> value;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT_TYPE&gt;
  shared_ptr&lt;bsl::deque&lt;ELEMENT_TYPE&gt; &gt;
  my_SafeQueue&lt;ELEMENT_TYPE&gt;::queue()
  {
      <span class="keywordflow">return</span> shared_ptr&lt;bsl::deque&lt;ELEMENT_TYPE&gt; &gt;(
                         &amp;d_queue,
                         MyMutexUnlockAndBroadcastDeleter(&amp;d_mutex, &amp;d_cond),
                         0);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="implementation_hiding"></a> <a class="anchor" id="usage.implementation_hiding"></a> <a class="anchor" id="description.usage.implementation_hiding"></a> <a class="anchor" id="3.11.4"></a> </dd></dl>
<dl class="user"><dt><b>Implementation Hiding: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> refers to the parameterized type on which it is instantiated "in name only". This allows for the instantiation of shared pointers to incomplete or <code>void</code> types. This feature is useful for constructing interfaces where returning a pointer to a shared object is desirable, but in order to control access to the object its interface cannot be exposed. The following examples demonstrate two techniques for achieving this goal using a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_4~3A_hidden_interfaces"></a> <a class="anchor" id="usage.example_4~3A_hidden_interfaces"></a> <a class="anchor" id="description.usage.example_4~3A_hidden_interfaces"></a> <a class="anchor" id="example_4"></a> <a class="anchor" id="usage.example_4"></a> <a class="anchor" id="description.usage.example_4"></a> <a class="anchor" id="3.11.5"></a> </dd></dl>
<dl class="user"><dt><b>Example 4: Hidden Interfaces: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Example 4 demonstrates the use of incomplete types to hide the interface of a <code>my_Session</code> type. We begin by declaring the <code>my_SessionManager</code> <code>class</code>, which allocates and manages <code>my_Session</code> objects. The interface (<code>.h</code>) merely forward declares <code>my_Session</code>. The actual definition of the interface is in the implementation (<code>.cpp</code>) file. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We forward-declare <code>my_Session</code> to be used (in name only) in the definition of <code>my_SessionManager</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Session;
</pre></div><br/>
<br/>
 Next, we define the <code>my_SessionManager</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_SessionManager {

      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1map.html">bsl::map&lt;int, shared_ptr&lt;my_Session&gt;</a> &gt; HandleMap;

      <span class="comment">// DATA</span>
      bcemt_Mutex       d_mutex;
      HandleMap         d_handles;
      <span class="keywordtype">int</span>               d_nextSessionId;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;
</pre></div><br/>
<br/>
 It is useful to have a designated name for the <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> to <code>my_Session</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> shared_ptr&lt;my_Session&gt; my_Handle;
</pre></div><br/>
<br/>
 We need only a default constructor: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// CREATORS</span>
      my_SessionManager(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0);
</pre></div><br/>
<br/>
 The 3 methods that follow construct a new session object and return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> to it. Callers can transfer the pointer, but they cannot directly access the object's methods since they do not have access to its interface. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// MANIPULATORS</span>
      my_Handle openSession(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; sessionName);
      <span class="keywordtype">void</span> closeSession(my_Handle handle);

      <span class="comment">// ACCESSORS</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> getSessionName(my_Handle handle) <span class="keyword">const</span>;
  };
</pre></div><br/>
<br/>
 Now, in the implementation of the code, we can define and implement the <code>my_Session</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Session {

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_sessionName;
      <span class="keywordtype">int</span>         d_handleId;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_Session(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;  sessionName,
                 <span class="keywordtype">int</span>                 handleId,
                 <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *basicAllocator = 0);

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> handleId() <span class="keyword">const</span>;
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; sessionName() <span class="keyword">const</span>;
  };

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_Session::my_Session(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;  sessionName,
                         <span class="keywordtype">int</span>                 handleId,
                         <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *basicAllocator)
  : d_sessionName(sessionName, basicAllocator)
  , d_handleId(handleId)
  {
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_Session::handleId()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_handleId;
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; my_Session::sessionName()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_sessionName;
  }
</pre></div><br/>
<br/>
 The following shows the implementation of <code>my_SessionManager</code>. Note that the interface for <code>my_Session</code> is not known: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  my_SessionManager::my_SessionManager(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
  : d_nextSessionId(1)
  , d_allocator_p(bslma::Default::allocator(allocator))
  {
  }

  <span class="keyword">inline</span>
  my_SessionManager::my_Handle
  my_SessionManager::openSession(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; sessionName)
  {
      bcemt_LockGuard&lt;bcemt_Mutex&gt; lock(&amp;d_mutex);
      my_Handle session(<span class="keyword">new</span>(*d_allocator_p) my_Session(sessionName,
                                                       d_nextSessionId++,
                                                       d_allocator_p));
      d_handles[session-&gt;handleId()] = session;
      <span class="keywordflow">return</span> session;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_SessionManager::closeSession(my_Handle handle)
  {
      bcemt_LockGuard&lt;bcemt_Mutex&gt; lock(&amp;d_mutex);
      HandleMap::iterator it = d_handles.find(handle-&gt;handleId());
      <span class="keywordflow">if</span> (it != d_handles.end()) {
          d_handles.erase(it);
      }
  }

  <span class="keyword">inline</span>
  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> my_SessionManager::getSessionName(my_Handle handle)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> handle-&gt;sessionName();
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_5~3A_opaque_types"></a> <a class="anchor" id="usage.example_5~3A_opaque_types"></a> <a class="anchor" id="description.usage.example_5~3A_opaque_types"></a> <a class="anchor" id="example_5"></a> <a class="anchor" id="usage.example_5"></a> <a class="anchor" id="description.usage.example_5"></a> <a class="anchor" id="3.11.6"></a> </dd></dl>
<dl class="user"><dt><b>Example 5: Opaque Types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the above example, users could infer that <code>my_Handle</code> is a pointer to a <code>my_Session</code> but have no way to directly access it's methods since the interface is not exposed. In the following example, <code>my_SessionManager</code> is re-implemented to provide an even more opaque session handle. In this implementation, <code>my_Handle</code> is redefined using <code>void</code> providing no indication of its implementation. Note that using <code>void</code> will require casting in the implementation and, therefore, will be a little more expensive. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the interface, define <code>my_SessionManager</code> as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_SessionManager {

      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1map.html">bsl::map&lt;int, shared_ptr&lt;void&gt;</a> &gt; HandleMap;

      <span class="comment">// DATA</span>
      bcemt_Mutex       d_mutex;
      HandleMap         d_handles;
      <span class="keywordtype">int</span>               d_nextSessionId;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;
</pre></div><br/>
<br/>
 It is useful to have a name for the <code>void</code> <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> handle. <br/>
<br/>
<div class="fragment"><pre class="fragment">     <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> shared_ptr&lt;void&gt; my_Handle;

      <span class="comment">// CREATORS</span>
      my_SessionManager(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0);

      <span class="comment">// MANIPULATORS</span>
      my_Handle openSession(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; sessionName);
      <span class="keywordtype">void</span> closeSession(my_Handle handle);

      <span class="comment">// ACCESSORS</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> getSessionName(my_Handle handle) <span class="keyword">const</span>;
  };
</pre></div><br/>
<br/>
 Next we define the methods of <code>my_SessionManager</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_SessionManager::my_SessionManager(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
  : d_nextSessionId(1)
  , d_allocator_p(bslma::Default::allocator(allocator))
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  my_SessionManager::my_Handle
  my_SessionManager::openSession(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; sessionName)
  {
      bcemt_LockGuard&lt;bcemt_Mutex&gt; lock(&amp;d_mutex);
</pre></div><br/>
<br/>
 Notice that <code>my_Handle</code>, which is a shared pointer to <code>void</code>, can be transparently assigned to a shared pointer to a <code>my_Session</code> object. This is because the <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> interface allows shared pointers to types that can be cast to one another to be assigned directly. <br/>
<br/>
<div class="fragment"><pre class="fragment">      my_Handle session(<span class="keyword">new</span>(*d_allocator_p) my_Session(sessionName,
                                                       d_nextSessionId++,
                                                       d_allocator_p));
      shared_ptr&lt;my_Session&gt; myhandle =
                      bslstl::SharedPtrUtil::staticCast&lt;my_Session&gt;(session);
      d_handles[myhandle-&gt;handleId()] = session;
      <span class="keywordflow">return</span> session;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_SessionManager::closeSession(my_Handle handle)
  {
      bcemt_LockGuard&lt;bcemt_Mutex&gt; lock(&amp;d_mutex);
</pre></div><br/>
<br/>
 Perform a static cast from <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;void&gt;</code> to <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;my_Session&gt;</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      shared_ptr&lt;my_Session&gt; myhandle =
                       bslstl::SharedPtrUtil::staticCast&lt;my_Session&gt;(handle);
</pre></div><br/>
<br/>
 Test to make sure that the pointer is non-null before using <code>myhandle</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (!myhandle.ptr()) {
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }

      HandleMap::iterator it = d_handles.find(myhandle-&gt;handleId());
      <span class="keywordflow">if</span> (it != d_handles.end()) {
          d_handles.erase(it);
      }
  }

  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> my_SessionManager::getSessionName(my_Handle handle)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      shared_ptr&lt;my_Session&gt; myhandle =
                       bslstl::SharedPtrUtil::staticCast&lt;my_Session&gt;(handle);

      <span class="keywordflow">if</span> (!myhandle.ptr()) {
          <span class="keywordflow">return</span> <a class="code" href="group__bslstl__string.html#gab67de1ebe0184939129507efe5c86bb1">bsl::string</a>();
      } <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> myhandle-&gt;sessionName();
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>AND NOW WE POST A STRAIGHT COPY OF THE WEAK_PTR DOCUMENTATION THAT NEEDS TO BE PROPERLY INTEGRATED, INCLUDING A RENUMBERING OF THE USAGE EXAMPLES. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a mechanism, <code>bcema_WeakPtr</code>, used to create weak references to reference-counted shared (<code>bcema_SharedPtr</code>) objects. A weak reference provides conditional access to a shared object managed by a <code>bcema_SharedPtr</code>, but, unlike a shared (or "strong") reference, does not affect the shared object's lifetime. An object having even one shared reference to it will not be destroyed, but an object having only weak references would have been destroyed when the last shared reference was released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A weak pointer can be constructed from another weak pointer or a <code>bcema_SharedPtr</code>. To access the shared object referenced by a weak pointer clients must first obtain a shared pointer to that object using the <code>acquireSharedPtr</code> method. If the shared object has been destroyed (as indicated by the <code>expired</code> method), then <code>acquireSharedPtr</code> returns a shared pointer in the default constructed (empty) state. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread-Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section qualifies the thread-safety of <code>bcema_WeakPtr</code> objects themselves rather than the thread-safety of the objects being referenced. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to access or modify two distinct <code>bcema_WeakPtr</code> objects simultaneously, each from a separate thread, even if they reference the same shared object. It is safe to access a single <code>bcema_WeakPtr</code> object simultaneously from two or more threads, provided no other thread is simultaneously modifying the object. It is not safe to access or modify a <code>bcema_WeakPtr</code> object in one thread while another thread modifies the same object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to access, modify, copy, or delete a weak pointer in one thread, while other threads access or modify other weak pointers that reference the same object. However, there is no guarantee regarding the safety of accessing or modifying the object <em>referenced</em> by the weak pointer simultaneously from multiple threads (that depends on the thread-safety guarantees of the shared object itself). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread-safety.weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="description.thread-safety.weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="4.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Weak Pointers using "in-place" or Pooled Shared Pointer Representations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A weak pointer that is not in the empty state shares a common representation (used to refer to the shared object) with the shared (or other weak) pointer from which it was constructed, and holds this representation until it is either destroyed or reset. This common representation is not destroyed and deallocated (although the shared object itself may have been destroyed) until all weak references to that common representation have been released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to this behavior the memory footprint of shared objects that are constructed "in-place" in the shared pointer representation (refer to the component-level documentation of <code>bcema_sharedptr</code> for more information on shared pointers with "in-place" representations) is not deallocated until all weak references to that shared object are released. Note that a shared object is always destroyed when the last shared reference to it is released. Also note that the same behavior is applicable if the shared objects were obtained from a class that pools shared pointer representations (for example, <code>bcec_SharedObjectPool</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example suppose we have a class with a large memory footprint: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ClassWithLargeFootprint {
      <span class="comment">// This class has a large memory footprint.</span>

      <span class="comment">// TYPES</span>
      <span class="keyword">enum</span> { BUFFER_SIZE = 1024 };
          <span class="comment">// The size of the buffer owned by this &#39;class&#39;.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> d_buffer[BUFFER_SIZE];

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 We then create an "in-place" shared pointer to an object of <code>ClassWithLargeFootprint</code> using the <code>createInplace</code> method of <code>bcema_SharedPtr</code>. The <code>sp</code> shared pointer representation of <code>sp</code> will create a <code>ClassWithLargeFootprint</code> object "in-place": <br/>
<br/>
<div class="fragment"><pre class="fragment">  bcema_SharedPtr&lt;ClassWithLargeFootprint&gt; sp;
  sp.createInplace();
</pre></div><br/>
<br/>
 Next we construct a weak pointer from this (in-place) shared pointer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bcema_WeakPtr&lt;ClassWithLargeFootprint&gt; wp(sp);
</pre></div><br/>
<br/>
 Now releasing all shared references to the shared object (using the <code>reset</code> function) causes the object's destructor to be called, but the representation is not destroyed (and the object's footprint is not deallocated) until <code>wp</code> releases its weak reference: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sp.reset(); <span class="comment">// The object&#39;s footprint is not deallocated until all weak</span>
              <span class="comment">// references to it are released.</span>

  wp.reset(); <span class="comment">// The release of the *last* weak reference results in the</span>
              <span class="comment">// destruction and deallocation of the representation and the</span>
              <span class="comment">// object&#39;s footprint.</span>
</pre></div><br/>
<br/>
 If a shared object has a large footprint, and the client anticipates there will be weak references to it, then it may be advisable to create an out-of-place shared pointer representation, which destroys the shared object and deallocates its footprint when the last <em>shared</em> reference to it is released, regardless of whether there are any outstanding weak references to the same representation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="4.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following examples demonstrate various features and uses of weak pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="4.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example illustrates the basic syntax needed to create and use a <code>bcema_WeakPtr</code>. Suppose that we want to construct a weak pointer that refers to an <code>int</code> managed by a shared pointer. Next we define the shared pointer and assign a value to the shared <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bcema_SharedPtr&lt;int&gt; intPtr;
  intPtr.createInplace(<a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>());
  *intPtr = 10;
  assert(10 == *intPtr);
</pre></div><br/>
<br/>
 Next we construct a weak pointer to the <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bcema_WeakPtr&lt;int&gt; intWeakPtr(intPtr);
  assert(!intWeakPtr.expired());
</pre></div><br/>
<br/>
 <code>bcema_WeakPtr</code> does not provide direct access to the shared object being referenced. To access and manipulate the <code>int</code> from the weak pointer, we have to obtain a shared pointer from it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bcema_SharedPtr&lt;int&gt; intPtr2 = intWeakPtr.acquireSharedPtr();
  assert(intPtr2);
  assert(10 == *intPtr2);

  *intPtr2 = 20;
  assert(20 == *intPtr);
  assert(20 == *intPtr2);
</pre></div><br/>
<br/>
 We remove the weak reference to the shared <code>int</code> by calling the <code>reset</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  intWeakPtr.reset();
  assert(intWeakPtr.expired());
</pre></div><br/>
<br/>
 Note that resetting the weak pointer does not affect the shared pointers referencing the <code>int</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(20 == *intPtr);
  assert(20 == *intPtr2);
</pre></div><br/>
<br/>
 Now, we construct another weak pointer referencing the shared <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bcema_WeakPtr&lt;int&gt; intWeakPtr2(intPtr);
  assert(!intWeakPtr2.expired());
</pre></div><br/>
<br/>
 Finally <code>reset</code> all shared references to the <code>int</code>, which will cause the weak pointer to become "expired"; any subsequent attempt to obtain a shared pointer from the weak pointer will return a shared pointer in the default constructed (empty) state: <br/>
<br/>
<div class="fragment"><pre class="fragment">  intPtr.reset();
  intPtr2.reset();
  assert(intWeakPtr2.expired());
  assert(!intWeakPtr2.acquireSharedPtr());
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_breaking_cyclical_dependencies"></a> <a class="anchor" id="usage.example_2~3A_breaking_cyclical_dependencies"></a> <a class="anchor" id="description.usage.example_2~3A_breaking_cyclical_dependencies"></a> <a class="anchor" id="4.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Breaking Cyclical Dependencies: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Weak pointers are frequently used to break cyclical dependencies between objects that store references to each other via a shared pointer. Consider for example a simplified news alert system that sends news alerts to users based on keywords that they register for. The user information is stored in the <code>User</code> class and the details of the news alert are stored in the <code>Alert</code> class. The class definitions for <code>User</code> and <code>Alert</code> are provided below (with any code not relevant to this example elided): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Alert;

  <span class="keyword">class </span>User {
      <span class="comment">// This class stores the user information required for listening to</span>
      <span class="comment">// alerts.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::shared_ptr&lt;Alert&gt;</a> &gt; d_alerts;  <span class="comment">// alerts user is</span>
                                                      <span class="comment">// registered for</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addAlert(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;Alert&gt;</a>&amp; alertPtr)
      {
          <span class="comment">// Add the specified &#39;alertPtr&#39; to the list of alerts being</span>
          <span class="comment">// monitored by this user.</span>

          d_alerts.push_back(alertPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Now we define an alert class, <code>Alert</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Alert {
      <span class="comment">// This class stores the alert information required for sending</span>
      <span class="comment">// alerts.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::shared_ptr&lt;User&gt;</a> &gt; d_users;  <span class="comment">// users registered</span>
                                                    <span class="comment">// for this alert</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addUser(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;User&gt;</a>&amp; userPtr)
      {
          <span class="comment">// Add the specified &#39;userPtr&#39; to the list of users monitoring this</span>
          <span class="comment">// alert.</span>

          d_users.push_back(userPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Even though we have released <code>alertPtr</code> and <code>userPtr</code> there still exists a cyclic reference between the two objects, so none of the objects are destroyed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can break this cyclical dependency we define a modified alert class <code>ModifiedAlert</code> that stores a weak pointer to a <code>ModifiedUser</code> object. Below is the definition for the <code>ModifiedUser</code> class which is identical to the <code>User</code> class, the only difference being that it stores shared pointer to <code>ModifiedAlert</code>s instead of <code>Alert</code>s: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ModifiedAlert;

  <span class="keyword">class </span>ModifiedUser {
      <span class="comment">// This class stores the user information required for listening to</span>
      <span class="comment">// alerts.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::shared_ptr&lt;ModifiedAlert&gt;</a> &gt; d_alerts;<span class="comment">// alerts user is</span>
                                                            <span class="comment">// registered for</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addAlert(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ModifiedAlert&gt;</a>&amp; alertPtr)
      {
          <span class="comment">// Add the specified &#39;alertPtr&#39; to the list of alerts being</span>
          <span class="comment">// monitored by this user.</span>

          d_alerts.push_back(alertPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Now we define the <code>ModifiedAlert</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ModifiedAlert {
      <span class="comment">// This class stores the alert information required for sending</span>
      <span class="comment">// alerts.</span>
</pre></div><br/>
<br/>
 Note that the user is stored by a weak pointer instead of by a shared pointer: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::weak_ptr&lt;ModifiedUser&gt;</a> &gt; d_users;  <span class="comment">// users registered</span>
                                                          <span class="comment">// for this alert</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addUser(<span class="keyword">const</span> <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;ModifiedUser&gt;</a>&amp; userPtr)
      {
          <span class="comment">// Add the specified &#39;userPtr&#39; to the list of users monitoring this</span>
          <span class="comment">// alert.</span>

          d_users.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(userPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Usage example 3 - Caching example<ul>
<li>- - - - - - - - - - - - - - - - Suppose we want to implement a peer to peer file sharing system that allows users to search for files that match specific keywords. A simplistic version of such a system with code not relevant to the usage example elided would have the following parts: </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>a) A peer manager class that maintains a list of all connected peers and updates the list based on incoming peer requests and disconnecting peers. The following would be a simple interface for the Peer and PeerManager classes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Peer {
      <span class="comment">// This class stores all the relevant information for a peer.</span>

      <span class="comment">// ...</span>
  };

  <span class="keyword">class </span>PeerManager {
      <span class="comment">// This class acts as a manager of peers and adds and removes peers</span>
      <span class="comment">// based on peer requests and disconnections.</span>

      <span class="comment">// DATA</span>
</pre></div><br/>
<br/>
 The peer objects are stored by shared pointer to allow peers to be passed to search results and still allow their asynchronous destruction when peers disconnect. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsl_1_1map.html">bsl::map&lt;int, bsl::shared_ptr&lt;Peer&gt;</a> &gt; d_peers;

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 b) A peer cache class that stores a subset of the peers that are used for sending search requests. The cache may select peers based on their connection bandwidth, relevancy of previous search results, etc. For brevity the population and flushing of this cache is not shown: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>PeerCache {
      <span class="comment">// This class caches a subset of all peers that match certain criteria</span>
      <span class="comment">// including connection bandwidth, relevancy of previous search</span>
      <span class="comment">// results, etc.</span>
</pre></div><br/>
<br/>
 Note that the cached peers are stored as a weak pointer so as not to interfere with the cleanup of Peer objects by the PeerManager if a Peer goes down. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;bsl::weak_ptr&lt;Peer&gt;</a> &gt; d_cachedPeers;

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1list.html">bsl::list&lt;bsl::weak_ptr&lt;Peer&gt;</a> &gt;::const_iterator PeerConstIter;

      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      PeerConstIter begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_cachedPeers.<a class="code" href="group__bslstl__list.html#ga5c31176fa2f214a7932d504200b37f9f">begin</a>(); }
      PeerConstIter end()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> d_cachedPeers.<a class="code" href="group__bslstl__list.html#gaaff91bdeee8bf00648c6f0ea63e89c5d">end</a>(); }
  };
</pre></div><br/>
<br/>
 c) A search result class that stores a search result and encapsulates a peer with the file name stored by the peer that best matches the specified keywords: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>SearchResult {
      <span class="comment">// This class provides a search result and encapsulates a particular</span>
      <span class="comment">// peer and filename combination that matches a specified set of</span>
      <span class="comment">// keywords.</span>
</pre></div><br/>
<br/>
 The peer is stored as a weak pointer because when the user decides to select a particular file to download from this peer, the peer might have disconnected. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;Peer&gt;</a> d_peer;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>         d_filename;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      SearchResult(<span class="keyword">const</span> <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;Peer&gt;</a>&amp; peer,
                   <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;         filename)
      : d_peer(peer)
      , d_filename(filename)
      {
      }

      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;Peer&gt;</a>&amp; peer()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_peer; }
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; filename()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_filename; }
  };
</pre></div><br/>
<br/>
 d) A search function that takes a list of keywords and returns available results by searching the cached peers: <br/>
<br/>
<div class="fragment"><pre class="fragment">  ;

  <span class="keywordtype">void</span> search(<a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;SearchResult&gt;</a>       *<span class="comment">/* results */</span>,
              <span class="keyword">const</span> PeerCache&amp;                 peerCache,
              <span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp;  <span class="comment">/* keywords */</span>)
  {
      <span class="keywordflow">for</span> (PeerCache::PeerConstIter iter = peerCache.begin();
           iter != peerCache.end();
           ++iter) {
</pre></div><br/>
<br/>
 First we check if the peer is still connected by acquiring a shared pointer to the peer. If the acquire operation succeeds then we can send the peer a request to send back the file best matching the specified keywords: <br/>
<br/>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;Peer&gt;</a> peerSharedPtr = iter-&gt;acquireSharedPtr();
          <span class="keywordflow">if</span> (peerSharedPtr) {

              <span class="comment">// Search the peer for file best matching the specified</span>
              <span class="comment">// keywords and if a file is found add the returned</span>
              <span class="comment">// SearchResult object to result.</span>

              <span class="comment">// ...</span>
          }
      }
  }
</pre></div><br/>
<br/>
 e) A download function that downloads a file selected by the user: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> download(<span class="keyword">const</span> SearchResult&amp; result)
  {
      <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;Peer&gt;</a> peerSharedPtr = result.peer().acquireSharedPtr();
      <span class="keywordflow">if</span> (peerSharedPtr) {
          <span class="comment">// Download the result.filename() file from peer knowing that</span>
          <span class="comment">// the peer is still connected.</span>
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga61ba33bd2aeb0d92257c509d5871e5e2"></a><!-- doxytag: member="bsl::shared_ptr::element_type" ref="ga61ba33bd2aeb0d92257c509d5871e5e2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ELEMENT_TYPE <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::element_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga499733138e91edd57c5e1094a3a3ab57"></a><!-- doxytag: member="bsl::shared_ptr::ElementType" ref="ga499733138e91edd57c5e1094a3a3ab57" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ELEMENT_TYPE <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::ElementType<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab3b2afafcf0e37543aa0bf0e8c7803f5"></a><!-- doxytag: member="bsl::weak_ptr::element_type" ref="gab3b2afafcf0e37543aa0bf0e8c7803f5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ELEMENT_TYPE <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::element_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5d753b3327b24f518ab0d05f20a8e985"></a><!-- doxytag: member="bsl::weak_ptr::ElementType" ref="ga5d753b3327b24f518ab0d05f20a8e985" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ELEMENT_TYPE <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::ElementType<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad18ba3b1d12a9f2d1fdb0ef39acb2dc3"></a><!-- doxytag: member="bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::first_argument_type" ref="gad18ba3b1d12a9f2d1fdb0ef39acb2dc3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef shared_ptr&lt;ELEMENT_TYPE&gt; bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::first_argument_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9482ae2147e2729abd1ce870a9667b6a"></a><!-- doxytag: member="bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::second_argument_type" ref="ga9482ae2147e2729abd1ce870a9667b6a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef shared_ptr&lt;ELEMENT_TYPE&gt; bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::second_argument_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6992b48fcdcae895c9039a318f4796c2"></a><!-- doxytag: member="bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::first_argument_type" ref="ga6992b48fcdcae895c9039a318f4796c2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef weak_ptr&lt;ELEMENT_TYPE&gt; bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::first_argument_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga06d414bbe414681c2e68d25a25b0f824"></a><!-- doxytag: member="bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::second_argument_type" ref="ga06d414bbe414681c2e68d25a25b0f824" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef weak_ptr&lt;ELEMENT_TYPE&gt; bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::second_argument_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabeaf6a273e56efa86bf7f783d0fc2f01"></a><!-- doxytag: member="bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::argument_type" ref="gabeaf6a273e56efa86bf7f783d0fc2f01" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef shared_ptr&lt;ELEMENT_TYPE&gt; bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::argument_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7616cc4e8610c55e5e215c9d352a1e0c"></a><!-- doxytag: member="bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::result_type" ref="ga7616cc4e8610c55e5e215c9d352a1e0c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaca7d79d152d01a4c84f0abf8700d21ec"></a><!-- doxytag: member="bsl::shared_ptr::BSLMF_NESTED_TRAIT_DECLARATION" ref="gaca7d79d152d01a4c84f0abf8700d21ec" args="(shared_ptr, BloombergLP::bslmf::HasPointerSemantics)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslmf::HasPointerSemantics&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabcc0de1c75fa2a6bf722f90eb97f5877"></a><!-- doxytag: member="bsl::shared_ptr::BSLMF_NESTED_TRAIT_DECLARATION" ref="gabcc0de1c75fa2a6bf722f90eb97f5877" args="(shared_ptr, BloombergLP::bslmf::IsBitwiseMoveable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslmf::IsBitwiseMoveable&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga25bfad5e168d83249437014e7b6b8892"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga25bfad5e168d83249437014e7b6b8892" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5d2c2bd0c5dedf8e1198be362c0e0a82"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga5d2c2bd0c5dedf8e1198be362c0e0a82" args="(bsl::nullptr_t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create an empty shared pointer, i.e., a shared pointer with no representation, that does not refer to any object and has no deleter. </p>

</div>
</div>
<a class="anchor" id="ga841c0f3459e54c1bf2158eb56b285093"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga841c0f3459e54c1bf2158eb56b285093" args="(COMPATIBLE_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages a modifiable object of (template parameter) type <code>COMPATIBLE_TYPE</code> and refers to <code>(ELEMENT_TYPE *)ptr</code>. The currently installed default allocator is used to allocate and deallocate the internal representation of the shared pointer and to destroy the shared object when all references have been released. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. If <code>ptr</code> is 0, an empty shared pointer is created and no memory is allocated. Note that as mentioned in the "CAVEAT" in the "C++ Standard Compliance" section of the component-level documentation, to comply with C++ standard specifications, future implementations of <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> may destroy the shared object using <code>::operator delete</code>. </p>

</div>
</div>
<a class="anchor" id="gab7e1c63bc0f6cdf8a18745b0c52139ea"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gab7e1c63bc0f6cdf8a18745b0c52139ea" args="(COMPATIBLE_TYPE *ptr, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages a modifiable object of (template parameter) type <code>COMPATIBLE_TYPE</code> and refers to <code>(ELEMENT_TYPE *)ptr</code>. If <code>basicAllocator</code> is not 0 the specified <code>basicAllocator</code> used to allocate and deallocate the internal representation of the shared pointer and to destroy the shared object when all references have been released, otherwise the currently installed default allocator is used. If 'COMPATIBLE_TYPE *' is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. If <code>ptr</code> is 0, an empty shared pointer is created and <code>basicAllocator</code> is ignored. Note that as mentioned in the "CAVEAT" in the "C++ Standard
         Compliance" section of the component-level documentation, to comply with C++ standard specifications, future implementations of <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> may destroy the shared object using <code>::operator delete</code> if an allocator is not specified. Also note that if <code>basicAllocator</code> is a pointer to a class derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, the compiler will actually select the following (more general) constructor that has the same behavior: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> COMPATIBLE_TYPE, <span class="keyword">class</span> DELETER&gt;
          <a class="code" href="group__bslstl__sharedptr.html#ga25bfad5e168d83249437014e7b6b8892">shared_ptr</a>(COMPATIBLE_TYPE *ptr, DELETER *<span class="keyword">const</span>&amp;  dispatch);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga2a2e4bbff3006535d3173733b9f8ae2e"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga2a2e4bbff3006535d3173733b9f8ae2e" args="(ELEMENT_TYPE *ptr, BloombergLP::bslma::SharedPtrRep *rep)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::SharedPtrRep *&nbsp;</td>
          <td class="paramname"> <em>rep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer taking ownership of the specified <code>rep</code> and referring to the modifiable object at the specified <code>ptr</code> address. If <code>ptr</code> is 0, an empty shared pointer is created. Note that this method <em>DOES</em> <em>NOT</em> increment the number of references to <code>rep</code>. Note that if <code>rep</code> is a pointer to a class derived from <code>BloombergLP::bslma::SharedPtrRep</code>, the compiler will actually select the following (more general) constructor that has the same behavior: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> COMPATIBLE_TYPE, <span class="keyword">class</span> DELETER&gt;
          <a class="code" href="group__bslstl__sharedptr.html#ga25bfad5e168d83249437014e7b6b8892">shared_ptr</a>(COMPATIBLE_TYPE *ptr, DELETER *<span class="keyword">const</span>&amp;  dispatch);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga2db442bb3e385f4935f2e779f73631cd"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga2db442bb3e385f4935f2e779f73631cd" args="(COMPATIBLE_TYPE *ptr, DELETER *const &amp;deleter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DELETER *const &amp;&nbsp;</td>
          <td class="paramname"> <em>deleter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages a modifiable object the (template parameter) type <code>COMPATIBLE_TYPE</code> and refers to <code>(ELEMENT_TYPE *)ptr</code>, using the specified <code>deleter</code> to delete the shared object when all references have been released and the currently installed default allocator to allocate and deallocate the internal representation of the shared pointer, unless <code>DELETER</code> is a class derived from either <code>bslma::allocator</code> or <code>BloombergLP::bslma::SharedPtrRep</code>; if <code>DELETER</code> is a class derived from <code>bslma::allocator</code> create a shared pointer as if calling the constructor: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> COMPATIBLE_TYPE&gt;
          <a class="code" href="group__bslstl__sharedptr.html#ga25bfad5e168d83249437014e7b6b8892">shared_ptr</a>(COMPATIBLE_TYPE               *ptr,
                     BloombergLP::bslma::Allocator *basicAllocator);
</pre></div><p><br/>
<br/>
 If <code>DELETER</code> is a class derived from <code>BloombergLP::bslma::SharedPtrRep</code> create a shared pointer as if calling the constructor: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <a class="code" href="group__bslstl__sharedptr.html#ga25bfad5e168d83249437014e7b6b8892">shared_ptr</a>(ELEMENT_TYPE                     *ptr,
                     BloombergLP::bslma::SharedPtrRep *<a class="code" href="group__bslstl__sharedptr.html#gaa2c9e02ec8be7cb54746f8a41b0b5c12">rep</a>);
</pre></div><p><br/>
<br/>
 If <code>DELETER</code> does not derive from either <code>bslma::allocator</code> or <code>BloombergLP::bslma::SharedPtrRep</code>, then <code>deleter</code> is assumed to be a pointer to a factory object that exposes a member function that can be invoked as <code>deleteObject(ptr)</code> that will be called to destroy the object at the <code>ptr</code> address (i.e., <code>deleter-&gt;deleteObject(ptr)</code> will be called to delete the shared object). (See the "Deleters" section in the component-level documentation.) If 'COMPATIBLE_TYPE *' is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. Also note that if <code>ptr</code> is 0, an empty shared pointer is created and <code>deleter</code> is ignored. </p>

</div>
</div>
<a class="anchor" id="gad777109e95969ee05342235b11034b71"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gad777109e95969ee05342235b11034b71" args="(COMPATIBLE_TYPE *ptr, const DELETER &amp;deleter, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DELETER &amp;&nbsp;</td>
          <td class="paramname"> <em>deleter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages a modifiable object of (template parameter) type <code>COMPATIBLE_TYPE</code> and refers to <code>(ELEMENT_TYPE *)ptr</code>, using the specified <code>deleter</code> to delete the shared object when all references have been released and the specified <code>basicAllocator</code> to allocate and deallocate the internal representation of the shared pointer. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If <code>DELETER</code> is a reference type, then <code>deleter</code> is assumed to be a function-like deleter that may be invoked to destroy the object referred to by a single argument of type <code>COMPATIBLE_TYPE *</code> (i.e., <code>deleter(ptr)</code> will be called to destroy the shared object). (See the "Deleters" section in the component- level documentation.) If 'COMPATIBLE_TYPE *' is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. Also note that if <code>ptr</code> is 0, an empty shared pointer is created and <code>deleter</code> and <code>basicAllocator</code> are ignored. </p>

</div>
</div>
<a class="anchor" id="gaf12a5d7a0361ed3bde88f59deaba07e4"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gaf12a5d7a0361ed3bde88f59deaba07e4" args="(nullptr_t nullPointerLiteral, const DELETER &amp;deleter, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class DELETER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>nullPointerLiteral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DELETER &amp;&nbsp;</td>
          <td class="paramname"> <em>deleter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty shared pointer. Note that for conformance with the C++ Standard specification for <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code>, a future version of this component may reference count the deleter, and uses the specified <code>basicAllocator</code> to create the storage area for the reference counts and a copy of the specified <code>deleter</code>. </p>

</div>
</div>
<a class="anchor" id="gaadfe208676a03d4f1a718ac73b9f02e5"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gaadfe208676a03d4f1a718ac73b9f02e5" args="(nullptr_t nullPointerLiteral, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>nullPointerLiteral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty shared pointer, i.e., a shared pointer with no representation, that does not refer to any object and has no deleter. </p>

</div>
</div>
<a class="anchor" id="gad32ea0635de6a74d765ff432e7b6567e"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gad32ea0635de6a74d765ff432e7b6567e" args="(BloombergLP::bslma::ManagedPtr&lt; COMPATIBLE_TYPE &gt; managedPtr, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::ManagedPtr&lt; COMPATIBLE_TYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>managedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga54a369c9151825ea5e7fd6f6fa173845"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga54a369c9151825ea5e7fd6f6fa173845" args="(std::auto_ptr&lt; COMPATIBLE_TYPE &gt; &amp;autoPtr, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">std::auto_ptr&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>autoPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa9b51141c8cfd23be3242d3176663ed1"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gaa9b51141c8cfd23be3242d3176663ed1" args="(std::auto_ptr_ref&lt; ELEMENT_TYPE &gt; autoRef, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">std::auto_ptr_ref&lt; ELEMENT_TYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>autoRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that takes over the management of the modifiable object previously managed by the specified <code>autoPtr</code> to the (template parameter) type <code>COMPATIBLE_TYPE</code>, and that refers to <code>(ELEMENT_TYPE *)autoPtr.get()</code>. The global <code>::operator delete</code> will be used to destroy the shared object when all references have been released. Optionally specify an <code>basicAllocator</code> used to allocate and deallocate the internal representation of the shared pointer. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="ga12461f1c2a32564f2e6aed992f147811"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga12461f1c2a32564f2e6aed992f147811" args="(const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages the same modifiable object (if any) as the specified <code>source</code> shared pointer to the (template parameter) type <code>ANY_TYPE</code>, and that refers to the modifiable object at the specified <code>object</code> address. The resulting shared pointer is known as an "alias" of <code>source</code>. Note that typically the objects referred to by <code>source</code> and <code>object</code> have identical lifetimes (e.g., one might be a part of the other) so that the deleter for <code>source</code> will destroy them both, but they do not necessarily have the same type. Also note that if either <code>source</code> is empty or <code>object</code> is null, then an empty shared pointer is created. </p>

</div>
</div>
<a class="anchor" id="ga52fd5aa2c3c730f07461871d120d2030"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga52fd5aa2c3c730f07461871d120d2030" args="(const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages the same modifiable object (if any) as the specified <code>other</code> shared pointer to the (template parameter) type <code>COMPATIBLE_TYPE</code>, using the same deleter as <code>other</code> to destroy the shared object, and that refers to <code>(ELEMENT_TYPE*)other.ptr()</code>. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. Note that if <code>other</code> is empty, then an empty shared pointer is created. </p>

</div>
</div>
<a class="anchor" id="gae1ba18a40fd81b46b1a579a0500164f2"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gae1ba18a40fd81b46b1a579a0500164f2" args="(const shared_ptr &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that refers to and manages the same object (if any) as the specified <code>original</code> shared pointer, using the same deleter as <code>original</code> to destroy the shared object. Note that if <code>original</code> is empty, then an empty shared pointer is created. </p>

</div>
</div>
<a class="anchor" id="ga00a7faf4ca60527b1506d9f90696d904"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga00a7faf4ca60527b1506d9f90696d904" args="(const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that refers to and manages the same object as the specified <code>ptr</code> if <code>false == ptr.expired()</code>, otherwise create a shared pointer in the empty state. Note that the referenced and managed objects may be different, if <code>ptr</code> was created from a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> in an aliasing state. </p>

</div>
</div>
<a class="anchor" id="gaec035331c8d985691fd7c5929173259a"></a><!-- doxytag: member="bsl::shared_ptr::~shared_ptr" ref="gaec035331c8d985691fd7c5929173259a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::~shared_ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this shared pointer. If this shared pointer refers to a (possibly shared) object, then release the reference to that object, and destroy the shared object using its associated deleter if this shared pointer is the last reference to that object. </p>

</div>
</div>
<a class="anchor" id="ga1888243089d89d2d68487862ebe43eb8"></a><!-- doxytag: member="bsl::shared_ptr::operator=" ref="ga1888243089d89d2d68487862ebe43eb8" args="(const shared_ptr &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&amp; <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this shared pointer refer to and manage the same modifiable object as the specified <code>rhs</code> shared pointer and using the same deleter as <code>rhs</code>, and return a reference to this modifiable shared pointer. If this shared pointer is already managing a (possibly shared) object, then release the shared reference to that object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Note that if <code>rhs</code> is empty, then this shared pointer will also be empty after the assignment. Also note that if <code>*this</code> is the same object as <code>rhs</code>, then this method has no effect. </p>

</div>
</div>
<a class="anchor" id="ga40dddf94f309f6c0cfbe24d83a175f4c"></a><!-- doxytag: member="bsl::shared_ptr::operator=" ref="ga40dddf94f309f6c0cfbe24d83a175f4c" args="(const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&amp; <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this shared pointer refer to and manage the same modifiable object as the specified <code>rhs</code> shared pointer to the (template parameter) type <code>COMPATIBLE_TYPE</code>, using the same deleter as <code>rhs</code> and referring to <code>(ELEMENT_TYPE *)rhs.ptr()</code>, and return a reference to this modifiable shared pointer. If this shared pointer is already managing a (possibly shared) object, then release the shared reference to that object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Note that if <code>rhs</code> is empty, then this shared pointer will also be empty after the assignment. </p>

</div>
</div>
<a class="anchor" id="ga8d417935c309096fbd01300a0cbd16d4"></a><!-- doxytag: member="bsl::shared_ptr::operator=" ref="ga8d417935c309096fbd01300a0cbd16d4" args="(std::auto_ptr&lt; COMPATIBLE_TYPE &gt; rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&amp; <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::auto_ptr&lt; COMPATIBLE_TYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfer ownership to this shared pointer of the modifiable object managed by the <code>rhs</code> auto pointer to the (template parameter) type <code>COMPATIBLE_TYPE</code>, using the <code>delete</code> operator to destroy the shared object when the last reference is released, and make this shared pointer refer to <code>(ELEMENT_TYPE *)rhs.get()</code>. If this shared pointer is already managing a (possibly shared) object, then release the reference to that shared object, and destroy it using it associated deleter if this shared pointer held the last shared reference to that object. Note that if <code>rhs</code> is null, then this shared pointer will also be empty after the assignment. </p>

</div>
</div>
<a class="anchor" id="ga1ac38efc4b5f79af4345a0ac95062fea"></a><!-- doxytag: member="bsl::shared_ptr::load" ref="ga1ac38efc4b5f79af4345a0ac95062fea" args="(COMPATIBLE_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::load </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the modifiable object of the parameterized <code>COMPATIBLE_TYPE</code> at the specified <code>ptr</code> address and refer to <code>(ELEMENT_TYPE *)ptr</code>. If this shared pointer is already managing a (possibly shared) object, then release the shared reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. The shared object held by <code>ptr</code> will be destroyed, when the last shared reference is released, by calling <code>delete ptr</code>. The currently installed default allocator is used to allocate and deallocate the internal representation of this shared pointer. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. Note that if <code>0 == ptr</code>, then this shared pointer will be reset to the empty state. </p>

</div>
</div>
<a class="anchor" id="ga25eab96a84917d2630d842f8701367fc"></a><!-- doxytag: member="bsl::shared_ptr::load" ref="ga25eab96a84917d2630d842f8701367fc" args="(COMPATIBLE_TYPE *ptr, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::load </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the modifiable object of the (template parameter) type <code>COMPATIBLE_TYPE</code> at the specified <code>ptr</code> address and refer to <code>(ELEMENT_TYPE *)ptr</code>. If this shared pointer is already managing a (possibly shared) object, then release the shared reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Optionally specify an <code>basicAllocator</code> used to allocate and deallocate the internal representation of this shared pointer and to destroy the shared object when all references have been released. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. Note that if <code>0 == ptr</code>, then this shared pointer will be reset to the empty state and <code>basicAllocator</code> will be ignored. </p>

</div>
</div>
<a class="anchor" id="ga41ad7b8e77821c8bfdf6a2f8c33703d5"></a><!-- doxytag: member="bsl::shared_ptr::load" ref="ga41ad7b8e77821c8bfdf6a2f8c33703d5" args="(COMPATIBLE_TYPE *ptr, const DELETER &amp;deleter, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::load </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DELETER &amp;&nbsp;</td>
          <td class="paramname"> <em>deleter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the modifiable object of the (template parameter) type <code>COMPATIBLE_TYPE</code> at the specified <code>ptr</code> address and to refer to <code>(ELEMENT_TYPE *)ptr</code>, using the specified <code>deleter</code> to delete the shared object when all references have been released and the specified <code>basicAllocator</code> to allocate and deallocate the internal representation of the shared pointer. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If this shared pointer is already managing a (possibly shared) object, then release the shared reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. If <code>DELETER</code> is a reference type, then <code>deleter</code> is assumed to be a function-like deleter that may be invoked to destroy the object referred to by a single argument of type <code>COMPATIBLE_TYPE *</code> (i.e., <code>deleter(ptr)</code> will be called to destroy the shared object). If <code>DELETER</code> is a pointer type, then <code>deleter</code> is assumed to be a pointer to a factory object that exposes a member function that can be invoked as <code>deleteObject(ptr)</code> that will be called to destroy the object at the <code>ptr</code> address (i.e., <code>deleter-&gt;deleteObject(ptr)</code> will be called to delete the shared object). (See the "Deleters" section in the component-level documentation.) If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. Note that, for factory deleters, the specified <code>deleter</code> must remain valid until all references to <code>ptr</code> have been released. Also note that if <code>ptr</code> is 0, then this shared pointer is reset to the empty state and both <code>deleter</code> and <code>basicAllocator</code> are ignored. Also note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          *<span class="keyword">this</span> = shared_ptr&lt;ELEMENT_TYPE&gt;(ptr, deleter, allocator);
</pre></div><p><br/>
<br/>
 and that, for the same reasons as explained in the constructor, the third <code>basicAllocator</code> argument is not optional. </p>

</div>
</div>
<a class="anchor" id="ga37f640bcf2343ba65ee81e87a794e35f"></a><!-- doxytag: member="bsl::shared_ptr::reset" ref="ga37f640bcf2343ba65ee81e87a794e35f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this shared pointer to the empty state. If this shared pointer is managing a (possibly shared) object, then release the reference to the shared object, calling the deleter to destroy the shared object if this pointer is the last reference. </p>

</div>
</div>
<a class="anchor" id="ga1a88d1f07d3287acb0a33871f005c6be"></a><!-- doxytag: member="bsl::shared_ptr::reset" ref="ga1a88d1f07d3287acb0a33871f005c6be" args="(COMPATIBLE_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the modifiable object of the (template parameter) type <code>COMPATIBLE_TYPE</code> at the specified <code>ptr</code> address and to refer to <code>(ELEMENT_TYPE *)ptr</code>. If this shared pointer is already managing a (possibly shared) object, then release the reference to the shared object, calling the deleter to destroy the shared object if this pointer is the last reference. The currently installed default allocator is used to allocate the internal representation of this shared pointer and to destroy the shared object when all references have been released. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. Note that if <code>ptr</code> is 0, then this shared pointer will be reset to the empty state. Note that the behavior of this method is the same as <code>load(ptr)</code>. </p>

</div>
</div>
<a class="anchor" id="ga12ad3c548d4fd47803dbb53c84c83524"></a><!-- doxytag: member="bsl::shared_ptr::reset" ref="ga12ad3c548d4fd47803dbb53c84c83524" args="(COMPATIBLE_TYPE *ptr, const DELETER &amp;deleter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DELETER &amp;&nbsp;</td>
          <td class="paramname"> <em>deleter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the modifiable object of the (template parameter) type <code>COMPATIBLE_TYPE</code> at the specified <code>ptr</code> address and refer to <code>(ELEMENT_TYPE *)ptr</code>, using the specified <code>deleter</code> to delete the shared object when all references have been released. If this shared pointer is already managing a (possibly shared) object, then release the reference to the shared object, calling the deleter to destroy the shared object if this pointer is the last reference. If <code>DELETER</code> is a reference type, then <code>deleter</code> is assumed to be a function-like deleter that may be invoked to destroy the object referred to by a single argument of type <code>COMPATIBLE_TYPE *</code> (i.e., <code>deleter(ptr)</code> will be called to destroy the shared object). If <code>DELETER</code> is a pointer type, then <code>deleter</code> is assumed to be a pointer to a factory object that exposes a member function that can be invoked as <code>deleteObject(ptr)</code> that will be called to destroy the object at the <code>ptr</code> address (i.e., <code>deleter-&gt;deleteObject(ptr)</code> will be called to delete the shared object). (See the "Deleters" section in the component-level documentation.) The currently installed default allocator is used to allocate the internal representation of this shared pointer and to destroy the shared object when all references have been released. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code> then a compiler diagnostic will be emitted indicating the error. Note that, for factory deleters, <code>deleter</code> must remain valid until all references to <code>ptr</code> have been released. Also note that if <code>ptr</code> is 0, then this shared pointer will be reset to the empty state and <code>deleter</code> is ignored. The behavior of this method is the same as <code>load(ptr, deleter, (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *)0)</code>. </p>

</div>
</div>
<a class="anchor" id="ga880253329316183fae55d7670bf02cd5"></a><!-- doxytag: member="bsl::shared_ptr::reset" ref="ga880253329316183fae55d7670bf02cd5" args="(const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the same modifiable object (if any) as the specified <code>source</code> shared pointer to the (template parameter) type <code>ANY_TYPE</code>, and refer to the modifiable object at the specified <code>ptr</code> address (i.e., make this shared pointer an "alias" of <code>source</code>). If this shared pointer is already managing a (possibly shared) object, then release the reference to the shared object, calling the deleter to destroy the shared object if this pointer is the last reference. Note that typically the objects referred to by <code>source</code> and <code>ptr</code> have identical lifetimes (e.g., one might be a part of the other) so that the deleter for <code>source</code> will destroy them both, but do not necessarily have the same type. Also note that if either <code>source</code> is unset or <code>ptr</code> is null, then this shared pointer will be reset to the empty state. Also note that the behavior of this method is the same as <code>loadAlias(source, ptr)</code>. </p>

</div>
</div>
<a class="anchor" id="ga6e070cf988e142180441f65b18780a60"></a><!-- doxytag: member="bsl::shared_ptr::clear" ref="ga6e070cf988e142180441f65b18780a60" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this shared pointer to the empty state. If this shared pointer is managing a (possibly shared) object, then release the reference to the shared object, calling the deleter to destroy the shared object if this pointer is the last reference. Note that the behavior of this method is the same as <code>reset()</code>.</p>
<p>DEPRECATED: Use <code>reset</code> instead. </p>

</div>
</div>
<a class="anchor" id="ga710218b15aeac3ab96e1269038a5aa21"></a><!-- doxytag: member="bsl::shared_ptr::loadAlias" ref="ga710218b15aeac3ab96e1269038a5aa21" args="(const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::loadAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the same modifiable object (if any) as the specified <code>source</code> shared pointer to the (template parameter) type <code>ANY_TYPE</code>, and refer to the modifiable object at the specified <code>object</code> address (i.e., make this shared pointer an "alias" of <code>source</code>). If this shared pointer is already managing a (possibly shared) object, then release the shared reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Note that typically the objects referred to by <code>source</code> and <code>object</code> have identical lifetimes (e.g., one might be a part of the other) so that the deleter for <code>source</code> will destroy them both, but they do not necessarily have the same type. Note that if either <code>source</code> is unset or <code>object</code> is null, then this shared pointer will be reset to the empty state. Also note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          *<span class="keyword">this</span> = shared_ptr&lt;ELEMENT_TYPE&gt;(source, object);
</pre></div><p><br/>
<br/>
 Further note that the behavior of this method is the same as <code>reset(source, object)</code>. </p>

</div>
</div>
<a class="anchor" id="gaafc3dbf236739df5e017f082b64db6ea"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="gaafc3dbf236739df5e017f082b64db6ea" args="(BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create "in-place" in a large enough contiguous memory region both an internal representation for this shared pointer and a default-constructed object of <code>ELEMENT_TYPE</code>, and make this shared pointer refer to the newly-created <code>ELEMENT_TYPE</code> object. Optionally specify an <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If an exception is thrown during allocation or construction of the <code>ELEMENT_TYPE</code> object, this shared pointer will be unchanged. Otherwise, if this shared pointer is already managing a (possibly shared) object, then release the shared reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Note that the allocator argument is <em>not</em> passed to the constructor for <code>ELEMENT_TYPE</code>. To construct an in-place <code>ELEMENT_TYPE</code> with an allocator, use one of the other variants of <code>createInplace</code> below. </p>

</div>
</div>
<a class="anchor" id="ga03b9c9c63a4f1edccfb12a1a1075f72e"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga03b9c9c63a4f1edccfb12a1a1075f72e" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga39246fe1a4523a81686c59232495a3f5"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga39246fe1a4523a81686c59232495a3f5" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab3fc58be99de52434c7974e3d6fa795e"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="gab3fc58be99de52434c7974e3d6fa795e" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga652422a023fdaa27313f11d5d0ce384c"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga652422a023fdaa27313f11d5d0ce384c" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga55af65860795eb30bad02fb83508d5e2"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga55af65860795eb30bad02fb83508d5e2" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9260b9f283836bd34814564f475759e3"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga9260b9f283836bd34814564f475759e3" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga02d1f3eb9a6c35471edb1ac1979b2da0"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga02d1f3eb9a6c35471edb1ac1979b2da0" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae3066aae4de276e4327ba8d94a09f130"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="gae3066aae4de276e4327ba8d94a09f130" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga640c4b75bf8a9ac0fb2af1604605a833"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga640c4b75bf8a9ac0fb2af1604605a833" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6565009e5d3855e7dc86f62de741b928"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga6565009e5d3855e7dc86f62de741b928" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa80b3327e687a5abf2c479986507d1aa"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="gaa80b3327e687a5abf2c479986507d1aa" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga64401cd05e867290147dabf55dfbf3b1"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga64401cd05e867290147dabf55dfbf3b1" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga51e62667dc0fa364f94d7d70d34f424b"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga51e62667dc0fa364f94d7d70d34f424b" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf998e53f52f90d11c49a564bdbf5ae61"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="gaf998e53f52f90d11c49a564bdbf5ae61" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A14 &amp;&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create "in-place" in a large enough contiguous memory region, using the specified <code>basicAllocator</code> to supply memory, both an internal representation for this shared pointer and an object of <code>ELEMENT_TYPE</code> using the <code>ELEMENT_TYPE</code> constructor that takes the specified arguments <code>a1</code> up to <code>aN</code> where <code>N</code> (at most 14) is the number of arguments passed to this method, and make this shared pointer refer to the newly-created <code>ELEMENT_TYPE</code> object. If an exception is thrown during the construction of the <code>ELEMENT_TYPE</code> object, this shared pointer will be unchanged. Otherwise, if this shared pointer is already managing a (possibly shared) object, then release the shared reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Note that the allocator argument is <em>not</em> implicitly passed to the constructor for <code>ELEMENT_TYPE</code>. To construct an object of <code>ELEMENT_TYPE</code> with an allocator, pass the allocator as one of the arguments (typically the last argument). </p>

</div>
</div>
<a class="anchor" id="ga54f46f5bb220e063bd7c097b8302a838"></a><!-- doxytag: member="bsl::shared_ptr::release" ref="ga54f46f5bb220e063bd7c097b8302a838" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;ELEMENT_TYPE *, BloombergLP::bslma::SharedPtrRep *&gt; <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the pair consisting of the addresses of the modifiable <code>ELEMENT_TYPE</code> object referred to, and the representation shared by, this shared pointer, and reset this shared pointer to the empty state with no effect on the representation. The reference counter is not modified nor is the shared object deleted; if the reference count of this representation is greater than one, then it is not safe to release the representation (thereby destroying the shared object), but it is always safe to create another shared pointer with this representation using the constructor with the signature 'shared_ptr(ELEMENT_TYPE *ptr, BloombergLP::bslma::SharedPtrRep *rep)'. Also note that this function returns a pair of null pointers if this shared pointer is empty. </p>

</div>
</div>
<a class="anchor" id="gaa54386ccdd73e52de6e463a6a86eb5b8"></a><!-- doxytag: member="bsl::shared_ptr::swap" ref="gaa54386ccdd73e52de6e463a6a86eb5b8" args="(shared_ptr&lt; ELEMENT_TYPE &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the states of this shared pointer and the specified <code>other</code> shared pointer such that each will refer to the object formerly referred to by the other and each will manage the object formerly referred to by the other. </p>

</div>
</div>
<a class="anchor" id="ga31292c33e0410049a25c59c0c4b74049"></a><!-- doxytag: member="bsl::shared_ptr::operator BoolType" ref="ga31292c33e0410049a25c59c0c4b74049" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator BoolType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a value of an "unspecified bool" type that evaluates to <code>false</code> if this shared pointer is in the empty state, and <code>true</code> otherwise. Note that this conversion operator allows a shared pointer to be used within a conditional context (e.g., within an <code>if</code> or <code>while</code> statement), but does <em>not</em> allow shared pointers to be compared (e.g., via <code>&lt;</code> or <code>&gt;</code>). </p>

</div>
</div>
<a class="anchor" id="gac951c0325b8179829b715d8e9e48c595"></a><!-- doxytag: member="bsl::shared_ptr::operator[]" ref="gac951c0325b8179829b715d8e9e48c595" args="(ptrdiff_t index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">add_lvalue_reference&lt;ELEMENT_TYPE&gt;::type <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable object at the specified <code>index</code> offset in object referred to by this shared pointer. The behavior is undefined unless this shared pointer is not empty, <code>ELEMENT_TYPE</code> is not <code>void</code> (a compiler error will be generated if this operator is instantiated within the <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;void&gt;</code> class), and this shared pointer refers to an array of <code>ELEMENT_TYPE</code> objects. Note that this is logically equivalent to <code>*(ptr() + index)</code>. </p>

</div>
</div>
<a class="anchor" id="ga7561cfb064b73fc506712a0bf4b4f6d1"></a><!-- doxytag: member="bsl::shared_ptr::operator*" ref="ga7561cfb064b73fc506712a0bf4b4f6d1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">add_lvalue_reference&lt;ELEMENT_TYPE&gt;::type <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable object referred to by this shared pointer. The behavior is undefined unless this shared pointer is not empty, and <code>ELEMENT_TYPE</code> is not <code>void</code> (a compiler error will be generated if this operator is instantiated within the <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;void&gt;</code> class). </p>

</div>
</div>
<a class="anchor" id="gaf0b9e0d68f8775c9f64c4df92d0f0d9b"></a><!-- doxytag: member="bsl::shared_ptr::operator&#45;&gt;" ref="gaf0b9e0d68f8775c9f64c4df92d0f0d9b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ELEMENT_TYPE* <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the modifiable object referred to by this shared pointer, or 0 if this shared pointer is empty. Note that applying this operator conventionally (e.g., to invoke a method) to an empty shared pointer will result in undefined behavior. </p>

</div>
</div>
<a class="anchor" id="gaa2c9e02ec8be7cb54746f8a41b0b5c12"></a><!-- doxytag: member="bsl::shared_ptr::rep" ref="gaa2c9e02ec8be7cb54746f8a41b0b5c12" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BloombergLP::bslma::SharedPtrRep* <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::rep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the modifiable <code>BloombergLP::bslma::SharedPtrRep</code> object used by this shared pointer, or 0 if this shared pointer is empty. </p>

</div>
</div>
<a class="anchor" id="gacf1fa65139ac6e757e041353be18897e"></a><!-- doxytag: member="bsl::shared_ptr::managedPtr" ref="gacf1fa65139ac6e757e041353be18897e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BloombergLP::bslma::ManagedPtr&lt;ELEMENT_TYPE&gt; <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::managedPtr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a managed pointer that refers to the same object as this shared pointer and which has a deleter that decrements the reference count for the shared object. </p>

</div>
</div>
<a class="anchor" id="ga48f002a13755bd11276a297079d8254e"></a><!-- doxytag: member="bsl::shared_ptr::get" ref="ga48f002a13755bd11276a297079d8254e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ELEMENT_TYPE* <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the modifiable object referred to by this shared pointer, or 0 if this shared pointer is empty. </p>

</div>
</div>
<a class="anchor" id="gac888622df34e855572e95f569686308c"></a><!-- doxytag: member="bsl::shared_ptr::owner_before" ref="gac888622df34e855572e95f569686308c" args="(const shared_ptr&lt; ANY_TYPE &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga02e27d5b5b2bd9654791f92988bad1ea"></a><!-- doxytag: member="bsl::shared_ptr::owner_before" ref="ga02e27d5b5b2bd9654791f92988bad1ea" args="(const weak_ptr&lt; ANY_TYPE &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the <code>BloombergLP::bslma::SharedPtrRep</code> object used by this shared pointer is ordered before the address of the <code>BloombergLP::bslma::SharedPtrRep</code> object used by the specified <code>other</code> under the total ordering supplied by <code>std::less&lt;BloombergLP::bslma::SharedPtrRep *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga71ce3c0494bfb53b944cfad471f458cc"></a><!-- doxytag: member="bsl::shared_ptr::unique" ref="ga71ce3c0494bfb53b944cfad471f458cc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this shared pointer does not share ownership of the object it refers to with any other shared pointer, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga577317da7b2aa99e58309cc7db1941de"></a><!-- doxytag: member="bsl::shared_ptr::use_count" ref="ga577317da7b2aa99e58309cc7db1941de" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the number of shared pointers (including this one) that share ownership of the object referred to by this shared pointer. </p>

</div>
</div>
<a class="anchor" id="gaffc20461dd32631b36b527f5e10adf48"></a><!-- doxytag: member="bsl::shared_ptr::numReferences" ref="gaffc20461dd32631b36b527f5e10adf48" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::numReferences </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the number of shared pointers (including this one) that share ownership of the object referred to by this shared pointer. Note that the behavior of this function is the same as <code>use_count</code>. </p>

</div>
</div>
<a class="anchor" id="gab307824fde26db221e749450e1cef713"></a><!-- doxytag: member="bsl::shared_ptr::ptr" ref="gab307824fde26db221e749450e1cef713" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ELEMENT_TYPE* <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the modifiable object referred to by this shared pointer, or 0 if this shared pointer is empty. Note that the behavior of this function is the same as <code>get</code>. </p>

</div>
</div>
<a class="anchor" id="gab53cc9a650d033a3674425de336b5c2b"></a><!-- doxytag: member="bsl::weak_ptr::BSLALG_DECLARE_NESTED_TRAITS" ref="gab53cc9a650d033a3674425de336b5c2b" args="(weak_ptr, BloombergLP::bslalg::TypeTraitBitwiseMoveable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslalg::TypeTraitBitwiseMoveable&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9940e0e924ecfb7a502c2be1507dfd87"></a><!-- doxytag: member="bsl::weak_ptr::weak_ptr" ref="ga9940e0e924ecfb7a502c2be1507dfd87" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::weak_ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a weak pointer in the empty state, i.e., a weak pointer having no representation that does not refer to any object. </p>

</div>
</div>
<a class="anchor" id="ga2a17d36d821e10ad16262d7f87a97555"></a><!-- doxytag: member="bsl::weak_ptr::weak_ptr" ref="ga2a17d36d821e10ad16262d7f87a97555" args="(const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::weak_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a weak pointer that refers to the same object (if any) as the specified <code>original</code> weak pointer, and increment the number of weak references to that object (if any). Note that if <code>original</code> is in the empty state, this weak pointer will be initialized to the empty state. </p>

</div>
</div>
<a class="anchor" id="gad7dac6852f146dbef51807a77d3f5cc4"></a><!-- doxytag: member="bsl::weak_ptr::weak_ptr" ref="gad7dac6852f146dbef51807a77d3f5cc4" args="(const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::weak_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: </p>

</div>
</div>
<a class="anchor" id="gae3bcfbc12277b8ccce95c264e758b0cb"></a><!-- doxytag: member="bsl::weak_ptr::weak_ptr" ref="gae3bcfbc12277b8ccce95c264e758b0cb" args="(const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::weak_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create a weak pointer that refers to the same object (if any) as the specified <code>other</code> (shared or weak) pointer of the parameterized <code>COMPATIBLE_TYPE</code>, and increment the number of weak references to that object (if any). If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>TYPE *</code>, then a compiler diagnostic will be emitted. Note that if <code>other</code> is in the empty state, this weak pointer will be initialized to the empty state. </p>

</div>
</div>
<a class="anchor" id="ga83c5b6a7e59b4b83fd92eb55dd94d13c"></a><!-- doxytag: member="bsl::weak_ptr::~weak_ptr" ref="ga83c5b6a7e59b4b83fd92eb55dd94d13c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::~weak_ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this weak pointer object. If this weak pointer refers to a (possibly shared) object, release the weak reference to that object. </p>

</div>
</div>
<a class="anchor" id="gae6c7e632d8987a466915157a32f4e6c5"></a><!-- doxytag: member="bsl::weak_ptr::operator=" ref="gae6c7e632d8987a466915157a32f4e6c5" args="(const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">weak_ptr&lt;ELEMENT_TYPE&gt;&amp; <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this weak pointer refer to the same object (if any) as the specified <code>rhs</code> weak pointer. Decrement the number of weak references to the object to which this weak pointer currently refers (if any), and increment the number of weak references to the object referred to by <code>rhs</code> (if any). Return a reference to this modifiable weak pointer. Note that if <code>rhs</code> is in the empty state, this weak pointer will be set to the empty state. </p>

</div>
</div>
<a class="anchor" id="gac8efdd1f795cb9be3badb432fe6c34ef"></a><!-- doxytag: member="bsl::weak_ptr::operator=" ref="gac8efdd1f795cb9be3badb432fe6c34ef" args="(const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">weak_ptr&lt;ELEMENT_TYPE&gt;&amp; <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga05faca26d2b73604656d4c409555cfa7"></a><!-- doxytag: member="bsl::weak_ptr::operator=" ref="ga05faca26d2b73604656d4c409555cfa7" args="(const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">weak_ptr&lt;ELEMENT_TYPE&gt;&amp; <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this weak pointer refer to the same object (if any) as the specified <code>rhs</code> (shared or weak) pointer to the parameterized <code>COMPATIBLE_TYPE</code>. Decrement the number of weak references to the object to which this weak pointer currently refers (if any), and increment the number of weak references to the object referred to by <code>rhs</code> (if any). Return a reference to this modifiable weak pointer. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>TYPE *</code>, then a compiler diagnostic will be emitted. Note that if <code>rhs</code> is in the empty state, this weak pointer will be set to the empty state. </p>

</div>
</div>
<a class="anchor" id="gaa78169359c056e9f1e460428cda0ec0d"></a><!-- doxytag: member="bsl::weak_ptr::reset" ref="gaa78169359c056e9f1e460428cda0ec0d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this weak pointer to the empty state. If this weak pointer refers to a (possibly shared) object, then decrement the number of weak references to that object. </p>

</div>
</div>
<a class="anchor" id="ga54ee587ceb82f9e93065157fbb41e8c3"></a><!-- doxytag: member="bsl::weak_ptr::swap" ref="ga54ee587ceb82f9e93065157fbb41e8c3" args="(weak_ptr&lt; ELEMENT_TYPE &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the states of this weak pointer and the specified <code>other</code> weak pointer such that each will refer to the object (if any) and representation formerly referred to by the other. </p>

</div>
</div>
<a class="anchor" id="gaa75a9c8ed01c2a85f198fc83af4feee1"></a><!-- doxytag: member="bsl::weak_ptr::expired" ref="gaa75a9c8ed01c2a85f198fc83af4feee1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::expired </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this weak pointer is in the empty state or the object that it originally referenced has been destroyed, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga34104a654a94454a482db63125d71221"></a><!-- doxytag: member="bsl::weak_ptr::lock" ref="ga34104a654a94454a482db63125d71221" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::lock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a shared pointer to the object referred to by this weak pointer if <code>false == expired()</code>, and a shared pointer in the empty state otherwise. Note that the behavior of this method is the same as that of <code>acquireSharedPtr</code>. </p>

</div>
</div>
<a class="anchor" id="ga9a2064e628262e110c375aeb57183324"></a><!-- doxytag: member="bsl::weak_ptr::owner_before" ref="ga9a2064e628262e110c375aeb57183324" args="(const shared_ptr&lt; ANY_TYPE &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga404af02b5e8e178639b74bc2eb0c43f5"></a><!-- doxytag: member="bsl::weak_ptr::owner_before" ref="ga404af02b5e8e178639b74bc2eb0c43f5" args="(const weak_ptr&lt; ANY_TYPE &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this weak pointer can be ordered before the specified <code>other</code> (shared or weak) pointer, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gac873ee69042167ce8d257e2a682a83dd"></a><!-- doxytag: member="bsl::weak_ptr::rep" ref="gac873ee69042167ce8d257e2a682a83dd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BloombergLP::bslma::SharedPtrRep* <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::rep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the modifiable <code>BloombergLP::bslma::SharedPtrRep</code> object held by this weak pointer, or 0 if this weak pointer is in the empty state. </p>

</div>
</div>
<a class="anchor" id="ga99089c0e74da9d1aa08b8e273948953d"></a><!-- doxytag: member="bsl::weak_ptr::use_count" ref="ga99089c0e74da9d1aa08b8e273948953d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the current number of shared pointers that share ownership of the object referred to by this weak pointer, or 0 if this weak pointer is in the empty state. Note that the behavior of this method is the same as that of <code>numReferences</code>. </p>

</div>
</div>
<a class="anchor" id="gaeb92560e5d8c45b7a24f98b7fcabcb33"></a><!-- doxytag: member="bsl::weak_ptr::acquireSharedPtr" ref="gaeb92560e5d8c45b7a24f98b7fcabcb33" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::acquireSharedPtr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a shared pointer to the object referred to by this weak pointer if <code>false == expired()</code>, and a shared pointer in the empty state otherwise. Note that the behavior of this method is the same as that of <code>lock</code>. </p>

</div>
</div>
<a class="anchor" id="ga85d8ae9bc109530b35e8264fd2e28b27"></a><!-- doxytag: member="bsl::weak_ptr::numReferences" ref="ga85d8ae9bc109530b35e8264fd2e28b27" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; LHS_TYPE, RHS_TYPE &gt;::numReferences </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the current number of shared pointers that share ownership of the object referred to by this weak pointer, or 0 if this weak pointer is in the empty state. Note that the behavior of this method is the same as that of <code>use_count</code>. </p>

</div>
</div>
<a class="anchor" id="ga69302cc359a55777cf7b2fdf1bc68733"></a><!-- doxytag: member="bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less" ref="ga69302cc359a55777cf7b2fdf1bc68733" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an <code>owner_less</code> object. </p>

</div>
</div>
<a class="anchor" id="ga6a6b3096a48bbb4ffb32e252f7000210"></a><!-- doxytag: member="bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less" ref="ga6a6b3096a48bbb4ffb32e252f7000210" args="(const owner_less &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less </td>
          <td>(</td>
          <td class="paramtype">const owner_less&lt; <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an <code>owner_less</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation will have no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga2d82db2872d23d64adc96bae2cdc1334"></a><!-- doxytag: member="bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::~owner_less" ref="ga2d82db2872d23d64adc96bae2cdc1334" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::~owner_less </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="gaa1c6ef296eea1a400edeccd9bbbf7112"></a><!-- doxytag: member="bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator=" ref="gaa1c6ef296eea1a400edeccd9bbbf7112" args="(const owner_less &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">owner_less&amp; bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const owner_less&lt; <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>owner_less</code> is an empty (stateless) type, this operation will have no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga9d485fbe334df7d34ae859bbba235ba8"></a><!-- doxytag: member="bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()" ref="ga9d485fbe334df7d34ae859bbba235ba8" args="(const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga98b17ce9979a4c4fd1b844e2f0ba255d"></a><!-- doxytag: member="bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()" ref="ga98b17ce9979a4c4fd1b844e2f0ba255d" args="(const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3e7af2d8e7c74ed24cbc226007c52c04"></a><!-- doxytag: member="bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()" ref="ga3e7af2d8e7c74ed24cbc226007c52c04" args="(const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4629e6da6ca7c4ead4fc636319152dd9"></a><!-- doxytag: member="bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less" ref="ga4629e6da6ca7c4ead4fc636319152dd9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an <code>owner_less</code> object. </p>

</div>
</div>
<a class="anchor" id="ga4d84a321ab410a3b0ef0dee34d2bb9ac"></a><!-- doxytag: member="bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less" ref="ga4d84a321ab410a3b0ef0dee34d2bb9ac" args="(const owner_less &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::owner_less </td>
          <td>(</td>
          <td class="paramtype">const owner_less&lt; <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an <code>owner_less</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation will have no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga6de2a85fec1f3effa0113f9d855a0bd9"></a><!-- doxytag: member="bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::~owner_less" ref="ga6de2a85fec1f3effa0113f9d855a0bd9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::~owner_less </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga344b738470792c82bc59431461a22b1b"></a><!-- doxytag: member="bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator=" ref="ga344b738470792c82bc59431461a22b1b" args="(const owner_less &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">owner_less&amp; bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const owner_less&lt; <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>owner_less</code> is an empty (stateless) type, this operation will have no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga02364b92faffdeba5f2680412e92dc79"></a><!-- doxytag: member="bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()" ref="ga02364b92faffdeba5f2680412e92dc79" args="(const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaced4de8eeaa0af6c4d766e679a83b7bb"></a><!-- doxytag: member="bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()" ref="gaced4de8eeaa0af6c4d766e679a83b7bb" args="(const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6eebdb7fff30f13ba6852f52622aee2e"></a><!-- doxytag: member="bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()" ref="ga6eebdb7fff30f13ba6852f52622aee2e" args="(const weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4f5045e9116c7afd014c1a6b0b41b5df"></a><!-- doxytag: member="bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::hash" ref="ga4f5045e9116c7afd014c1a6b0b41b5df" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="gafa521e9dd34d7759aa9dbc726499045f"></a><!-- doxytag: member="bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::hash" ref="gafa521e9dd34d7759aa9dbc726499045f" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const hash&lt; <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation will have no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga5d280e2986743f6ed16022c658fd911b"></a><!-- doxytag: member="bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::~hash" ref="ga5d280e2986743f6ed16022c658fd911b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="gae31bcc4016306c89295802b85d460490"></a><!-- doxytag: member="bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator=" ref="gae31bcc4016306c89295802b85d460490" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const hash&lt; <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation will have no observable effect. </p>

</div>
</div>
<a class="anchor" id="gad689cb8f390fb7628ad531a3a11e1420"></a><!-- doxytag: member="bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator()" ref="gad689cb8f390fb7628ad531a3a11e1420" args="(const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t bsl::hash&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. Two <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> objects will have the same hash value if they point to the same object, whether or not they share ownership of the same object. Likewise, two shared pointers that share ownership of the same object may have different hash values if they do not both alias the same pointer. </p>

</div>
</div>
<a class="anchor" id="ga1c1c2704b92642dd439cdad97a848d57"></a><!-- doxytag: member="bsl::operator==" ref="ga1c1c2704b92642dd439cdad97a848d57" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3a77beaa9951f55de2c793f025d576c4"></a><!-- doxytag: member="bsl::operator!=" ref="ga3a77beaa9951f55de2c793f025d576c4" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga66ad66d30f8224d17b9a095394af53a3"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga66ad66d30f8224d17b9a095394af53a3" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga18eb1b3e0476913d7ba6ba1af5f1bde0"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga18eb1b3e0476913d7ba6ba1af5f1bde0" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf7d2404f8ddbbf36bbf27fe3fb8685a7"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gaf7d2404f8ddbbf36bbf27fe3fb8685a7" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae407f6ed76abc4c51b61472c966c28fc"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gae407f6ed76abc4c51b61472c966c28fc" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga02586f71629626fe00132cefebf9d0f6"></a><!-- doxytag: member="bsl::operator==" ref="ga02586f71629626fe00132cefebf9d0f6" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6ebbfc95461e707c1219dcfd8d5eb65c"></a><!-- doxytag: member="bsl::operator==" ref="ga6ebbfc95461e707c1219dcfd8d5eb65c" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf6de5b2e8b27c39f51c873993d71f9ad"></a><!-- doxytag: member="bsl::operator!=" ref="gaf6de5b2e8b27c39f51c873993d71f9ad" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae1eab178a468625aa5836216595b076c"></a><!-- doxytag: member="bsl::operator!=" ref="gae1eab178a468625aa5836216595b076c" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf4c4bb456f48f1842cb63357527e9644"></a><!-- doxytag: member="bsl::operator&lt;" ref="gaf4c4bb456f48f1842cb63357527e9644" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga88c588f14653fec148e0f293794505a4"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga88c588f14653fec148e0f293794505a4" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2fcb633c59eda20af4715e688bf0dbee"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga2fcb633c59eda20af4715e688bf0dbee" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga013b0c9607f5b710d6e54a95137560ed"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga013b0c9607f5b710d6e54a95137560ed" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8b013ca7ef46710259e40234cfcc735a"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga8b013ca7ef46710259e40234cfcc735a" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaeb88e103f0bc7111f829207a03644bcb"></a><!-- doxytag: member="bsl::operator&gt;" ref="gaeb88e103f0bc7111f829207a03644bcb" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac55976d83a9c4bb361e6d9acdb221405"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gac55976d83a9c4bb361e6d9acdb221405" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad53c3f8eaccc4210b0d6aa129870e5f8"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gad53c3f8eaccc4210b0d6aa129870e5f8" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3c14f6b0f548e336c44341124f278434"></a><!-- doxytag: member="bsl::operator&lt;&lt;" ref="ga3c14f6b0f548e336c44341124f278434" args="(std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;stream, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp; bsl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga050d5c3fbf77c1ddc00d3e18c07cebc8"></a><!-- doxytag: member="bsl::swap" ref="ga050d5c3fbf77c1ddc00d3e18c07cebc8" args="(shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga903f6e4e7b2befd616936456786efa34"></a><!-- doxytag: member="bsl::const_pointer_cast" ref="ga903f6e4e7b2befd616936456786efa34" args="(const shared_ptr&lt; FROM_TYPE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;TO_TYPE&gt; bsl::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; FROM_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa4dded295fd97099aa32efb1d6e2a054"></a><!-- doxytag: member="bsl::dynamic_pointer_cast" ref="gaa4dded295fd97099aa32efb1d6e2a054" args="(const shared_ptr&lt; FROM_TYPE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;TO_TYPE&gt; bsl::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; FROM_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga22893acbe6dca3b4184b1b5f92891c09"></a><!-- doxytag: member="bsl::static_pointer_cast" ref="ga22893acbe6dca3b4184b1b5f92891c09" args="(const shared_ptr&lt; FROM_TYPE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;TO_TYPE&gt; bsl::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; FROM_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad7f43c35a15e87ad6e3f859c47f135f4"></a><!-- doxytag: member="bsl::swap" ref="gad7f43c35a15e87ad6e3f859c47f135f4" args="(weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">weak_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weak_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa1e0c5e3e5a6041d830b7909dfe00bbd"></a><!-- doxytag: member="bslstl::SharedPtrUtil::staticCast" ref="gaa1e0c5e3e5a6041d830b7909dfe00bbd" args="(const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;TARGET&gt; bslstl::SharedPtrUtil::staticCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;TARGET&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the parameterized <code>SOURCE</code> type, and referring to <code>static_cast&lt;TARGET *&gt;(source.ptr())</code>. Note that if <code>source</code> cannot be statically cast to <code>TARGET *</code>, then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="gafcce9eb23f8b3a7c494351c7cf9246f7"></a><!-- doxytag: member="bslstl::SharedPtrUtil::constCast" ref="gafcce9eb23f8b3a7c494351c7cf9246f7" args="(const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;TARGET&gt; bslstl::SharedPtrUtil::constCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;TARGET&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the parameterized <code>SOURCE</code> type, and referring to <code>const_cast&lt;TARGET *&gt;(source.ptr())</code>. Note that if <code>source</code> cannot be <code>const</code>-cast to <code>TARGET *</code>, then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="ga69f6feecf72eebbdb5154d80b313cea6"></a><!-- doxytag: member="bslstl::SharedPtrUtil::dynamicCast" ref="ga69f6feecf72eebbdb5154d80b313cea6" args="(bsl::shared_ptr&lt; TARGET &gt; *target, const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslstl::SharedPtrUtil::dynamicCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>target</code> shared pointer an alias of the specified <code>source</code> shared pointer referring to <code>dynamic_cast&lt;TARGET *&gt;(source.ptr())</code>. The previous <code>target</code> shared pointer is destroyed (destroying the shared object if <code>target</code> holds the last reference to this object). If <code>source</code> cannot be dynamically cast to <code>TARGET *</code>, <code>target</code> will be reset to the empty state. </p>

</div>
</div>
<a class="anchor" id="gaf025d8bc5b749fb04ae5d983e9fb605f"></a><!-- doxytag: member="bslstl::SharedPtrUtil::staticCast" ref="gaf025d8bc5b749fb04ae5d983e9fb605f" args="(bsl::shared_ptr&lt; TARGET &gt; *target, const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslstl::SharedPtrUtil::staticCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>target</code> shared pointer an alias of the specified <code>source</code> shared pointer referring to <code>static_cast&lt;TARGET *&gt;(source.ptr())</code>. The previous <code>target</code> shared pointer is destroyed (destroying the shared object if <code>target</code> holds the last reference to this object). Note that if <code>source</code> cannot be statically cast to <code>TARGET *</code>, then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="gaa7c3c7f1ae148cf6352b0fa6708a4aff"></a><!-- doxytag: member="bslstl::SharedPtrUtil::constCast" ref="gaa7c3c7f1ae148cf6352b0fa6708a4aff" args="(bsl::shared_ptr&lt; TARGET &gt; *target, const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslstl::SharedPtrUtil::constCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>target</code> shared pointer an alias of the specified <code>source</code> shared pointer referring to <code>const_cast&lt;TARGET *&gt;(source.ptr())</code>. The previous <code>target</code> shared pointer is destroyed (destroying the shared object if <code>target</code> holds the last reference to this object). Note that if <code>source</code> cannot be statically cast to <code>TARGET *</code>, then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="ga08e81fb21b279dfe9d5d1c18e7e8eb13"></a><!-- doxytag: member="bslstl::SharedPtrUtil::createInplaceUninitializedBuffer" ref="ga08e81fb21b279dfe9d5d1c18e7e8eb13" args="(bsl::size_t bufferSize, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;char&gt; bslstl::SharedPtrUtil::createInplaceUninitializedBuffer </td>
          <td>(</td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a shared pointer with an in-place representation to a newly-created uninitialized buffer of the specified <code>bufferSize</code> (in bytes). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="ga9a4da829475f0cf1809fc6ef555ffe06"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga9a4da829475f0cf1809fc6ef555ffe06" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class shared_ptr<code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga73fb185cab8b7bb5f231491bb497071c"></a><!-- doxytag: member="bsl::weak_ptr::weak_ptr" ref="ga73fb185cab8b7bb5f231491bb497071c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE, class RHS_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class weak_ptr<code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Apr 7 2014 20:26:35 for BDE Release 2.20 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
