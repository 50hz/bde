<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BSL 2.19 OSS: bslstl_string Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_string<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a standard-compliant <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> class template.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01basic__string_3_01CHAR__TYPE_00_01CHAR__TRAITS_00_01ALLOCATOR_01_4_01_4.html">bsl::hash&lt; basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga126b87a50a82be88e9132b4c32bf4a3f">BSLSTL_CHAR_TRAITS</a>&nbsp;&nbsp;&nbsp;CHAR_TRAITS</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga18e4e2f60cb115683d0ecde9ee087981">BSLSTL_INSERT_RETURN_TYPE</a>&nbsp;&nbsp;&nbsp;typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::iterator</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CHAR_TRAITS::char_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf975fd039e41c7e772d392872496b82f">bsl::basic_string::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gac39ab7e8873845c0b12c1a81b7293d80">bsl::basic_string::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">bsl::basic_string::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaaaaf7ca1bfdac673b4e38e75f87b9098">bsl::basic_string::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga82e5bc8d9dfd8dbca6b982d0e2ff30c3">bsl::basic_string::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga2326616f652478f89571fe7bf8169e36">bsl::basic_string::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga2148c96ab93d1821f8d93d013a385f47">bsl::basic_string::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga7bcefeea4235523662dfc939280390ac">bsl::basic_string::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CHAR_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga821d2877e9e7ce1a92705ba4e1eea65b">bsl::basic_string::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const CHAR_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">bsl::basic_string::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga0222d501ce939e1ea6577bd757683c05">bsl::basic_string::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gadb446f8b83a7f1ebe053e7cb6726e4ed">bsl::basic_string::const_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef basic_string&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab67de1ebe0184939129507efe5c86bb1">bsl::string</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef basic_string&lt; wchar_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab3b4e0ebb1e917062e2cc0a71d69fa81">bsl::wstring</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga9878e9f0e10750669118fa4929fbdd29">bsl::String_Imp::ConfigurableParameters</a> { <a class="el" href="group__bslstl__string.html#gga9878e9f0e10750669118fa4929fbdd29a20d9b2a976ecad64c5e6a04e45bcaabc">bsl::String_Imp::BASIC_STRING_DEALLOCATE_IN_CLEAR</a> =  false, 
<a class="el" href="group__bslstl__string.html#gga9878e9f0e10750669118fa4929fbdd29a5007d36656baaef1224ceef93b5fe316">bsl::String_Imp::BASIC_STRING_HONOR_SHRINK_REQUEST</a> =  false
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga8d692e0cd17d3913d3f8ff50a3804686">bsl::String_Imp::BSLMF_ASSERT</a> (SHORT_BUFFER_BYTES &gt;=sizeof(CHAR_TYPE *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga2e99c691174f68e648604c5e10c889fa">bsl::String_Imp::BSLMF_NESTED_TRAIT_DECLARATION</a> (String_Imp, BloombergLP::bslmf::IsBitwiseMoveable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static SIZE_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga748343a56e50e73b56fc93c366cd69fb">bsl::String_Imp::computeNewCapacity</a> (SIZE_TYPE newLength, SIZE_TYPE oldCapacity, SIZE_TYPE maxSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga34064a87dbc43f22b1185cbbd037650f">bsl::String_Imp::String_Imp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga310ddffe25de004bc5ca13dc3aeaf7ae">bsl::String_Imp::String_Imp</a> (SIZE_TYPE length, SIZE_TYPE capacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1196fdf7fe5cdc34c2e0ef2d7ac810a1">bsl::String_Imp::String_Imp</a> (const String_Imp &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga922f8fc2997ddd5c4aafe2a8e73511e1">bsl::String_Imp::~String_Imp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String_Imp &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab60fccb24e62d362663c00ed6285b3ea">bsl::String_Imp::operator=</a> (const String_Imp &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa84e137b4df18defbd422bd14b7afb8e">bsl::String_Imp::swap</a> (String_Imp &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gad45a4779242e1126b7c28f5c9f38ddc9">bsl::String_Imp::resetFields</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CHAR_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp::dataPtr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga5e8fe3a4824803307fd12d99dbdb75aa">bsl::String_Imp::isShortString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const CHAR_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa81be1d0acf68dad7a0f5697c733ba35">bsl::String_Imp::dataPtr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga343e1760f5cc0f569f29383ba12ec447">bsl::basic_string::basic_string</a> (const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga66be81efef3b9a52a338d0fbc5f6e43d">bsl::basic_string::basic_string</a> (const basic_string &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf579ac0f9f4b1fba90d39f4e59f75fdf">bsl::basic_string::basic_string</a> (const basic_string &amp;original, const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga2a3738276c0c5e2787aca7789578166d">bsl::basic_string::basic_string</a> (const basic_string &amp;original, size_type position, size_type numChars=npos, const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab4cd3e32bd8907070e471876d9d598c9">bsl::basic_string::basic_string</a> (const CHAR_TYPE *characterString, const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga8306dfbd75056c067903feda53620bb9">bsl::basic_string::basic_string</a> (const CHAR_TYPE *characterString, size_type numChars, const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacf04572711a638c2241ca90e264f82e7">bsl::basic_string::basic_string</a> (size_type numChars, CHAR_TYPE character, const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga0a26067f8db06d88c95d8096cd1610d9">bsl::basic_string::basic_string</a> (INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gac73de5145e3939f4090dbc01ddcc58db">bsl::basic_string::basic_string</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;original, const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga5021d7c0b4f2ce5501b7aea6a38eda56">bsl::basic_string::basic_string</a> (const BloombergLP::bslstl::StringRefData&lt; CHAR_TYPE &gt; &amp;strRef, const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf8d5e8dde4a2ba49ab5975c2390370f2">bsl::basic_string::~basic_string</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa730887a6af5ec76524fe2c74a5d8d46">bsl::basic_string::operator=</a> (const basic_string &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4cc4f92261516e59d09d7722de4f10ce">bsl::basic_string::operator=</a> (const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf3392f11a56a8918b7aa5c4ae72101d9">bsl::basic_string::operator=</a> (CHAR_TYPE character)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga25b862783d3d32a02bff9aa4c9e1a4c4">bsl::basic_string::resize</a> (size_type newLength, CHAR_TYPE character)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga7cc4a9c33d8d7ce75014f4a550dcce91">bsl::basic_string::resize</a> (size_type newLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga89c1eba9a0af6cc49856833210509d4e">bsl::basic_string::reserve</a> (size_type newCapacity=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1bade383cf64eed66f1c43ae0aa450a5">bsl::basic_string::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga40fba499341341e223a15734121e65ee">bsl::basic_string::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga7e104ce3808ca8d5098737acae36dbfd">bsl::basic_string::rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4e2cc41b80c0de97a63d1acd676226c2">bsl::basic_string::rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1a5d4f6852a29ce65d258aca6d4e51e1">bsl::basic_string::operator[]</a> (size_type position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa1d2382eeb4b366a2368b43272a8d6e5">bsl::basic_string::at</a> (size_type position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga5cd6424f238c70dcf17508ae6efcd509">bsl::basic_string::front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga692652ff0c2a02fef66d07686d9cdb4c">bsl::basic_string::back</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gad9c0939db2b84b4f3d7cbe8d8cd0cd3b">bsl::basic_string::operator native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae5474c475c04b22679ab156237cd32ea">bsl::basic_string::operator+=</a> (const basic_string &amp;string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga79206f1245792c72a41c505f1fdfe585">bsl::basic_string::operator+=</a> (const CHAR_TYPE *string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1a20bd0dbe3e432566b4f4e2433e7477">bsl::basic_string::operator+=</a> (CHAR_TYPE character)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga9c2fb86b756802242f98cedc716073b1">bsl::basic_string::append</a> (const basic_string &amp;string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga2877072ce0e85eeccf15a256ff2e0f8a">bsl::basic_string::append</a> (const basic_string &amp;string, size_type position, size_type numChars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gac4401f5fc7543287231822293541ca32">bsl::basic_string::append</a> (const CHAR_TYPE *characterString, size_type numChars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gabbd064cbe91220e783bff077a58e6b69">bsl::basic_string::append</a> (const CHAR_TYPE *characterString)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga5fb62eb01697df2031aade78fc57221f">bsl::basic_string::append</a> (size_type numChars, CHAR_TYPE character)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga7034cef2e187d81f2a2265e3a49d9322">bsl::basic_string::append</a> (INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string::push_back</a> (CHAR_TYPE character)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string::assign</a> (const basic_string &amp;string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga45ddf77dd0fed965fca1d3eb7fdf2fbd">bsl::basic_string::assign</a> (const basic_string &amp;string, size_type position, size_type numChars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga442cb787dcea2342b5cbea6a1069df93">bsl::basic_string::assign</a> (const CHAR_TYPE *characterString)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab413ee9414d64d52c66eb5fca73ceb96">bsl::basic_string::assign</a> (const CHAR_TYPE *characterString, size_type numChars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaaf4e1014bf852bd9356729fc5fca4774">bsl::basic_string::assign</a> (size_type numChars, CHAR_TYPE character)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga141714d133832d9980540c42a0cd3276">bsl::basic_string::assign</a> (INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gac412644d4308344b0081691ec48e8442">bsl::basic_string::insert</a> (size_type position, const basic_string &amp;string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaae3683b45fb349560b817c5c0e7fbb90">bsl::basic_string::insert</a> (size_type outPosition, const basic_string &amp;string, size_type position, size_type numChars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa28c69689f4914cccb4865e31a696837">bsl::basic_string::insert</a> (size_type position, const CHAR_TYPE *characterString, size_type numChars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga61ae12c70a02028d7f4559fa6471cf92">bsl::basic_string::insert</a> (size_type position, const CHAR_TYPE *characterString)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga39dabb29dfa3b05bfff5a1a52f6db92a">bsl::basic_string::insert</a> (size_type position, size_type numChars, CHAR_TYPE character)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga55b93e2994f6491ba60783db444e1e41">bsl::basic_string::insert</a> (const_iterator position, CHAR_TYPE character)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaec0a015838285fa679f695b27dfd7d1e">bsl::basic_string::insert</a> (const_iterator position, size_type numChars, CHAR_TYPE character)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga729e8703bab227d076ea8aeb6b045284">bsl::basic_string::insert</a> (const_iterator position, INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gafc5850be8c60d15b6a8d46efa5db876f">bsl::basic_string::erase</a> (size_type position=0, size_type numChars=npos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga431be6461541b53f711211b84a472c2a">bsl::basic_string::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gad3e452b31e49cd577ad59bff046d57a7">bsl::basic_string::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab7139f8e4a967c1865e0e1f76397351a">bsl::basic_string::pop_back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaad28d25eb7340fc1e001ca844ad38d2a">bsl::basic_string::replace</a> (size_type outPosition, size_type outNumChars, const basic_string &amp;string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gafa2bb7396a3abfdb5b8c3d0f5827dc66">bsl::basic_string::replace</a> (size_type outPosition, size_type outNumChars, const basic_string &amp;string, size_type position, size_type numChars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga9e268bdc36e87462e7cd95981dc790f2">bsl::basic_string::replace</a> (size_type outPosition, size_type outNumChars, const CHAR_TYPE *characterString, size_type numChars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga525b75f9dff0e082007200f2a7a529ce">bsl::basic_string::replace</a> (size_type outPosition, size_type outNumChars, const CHAR_TYPE *characterString)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga35333503fd5bc38d53cd9a1b054b738a">bsl::basic_string::replace</a> (size_type outPosition, size_type outNumChars, size_type numChars, CHAR_TYPE character)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3831eb00bad69c251ffc910cb3031a08">bsl::basic_string::replace</a> (const_iterator first, const_iterator last, const basic_string &amp;string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga30dca582bee14c63a511c3f999da77aa">bsl::basic_string::replace</a> (const_iterator first, const_iterator last, const CHAR_TYPE *characterString, size_type numChars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gac09d3519c58209d4bfaf93a4df2f87cb">bsl::basic_string::replace</a> (const_iterator first, const_iterator last, const CHAR_TYPE *characterString)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga7cc25bf6bfda6433ecb222909f66668a">bsl::basic_string::replace</a> (const_iterator first, const_iterator last, size_type numChars, CHAR_TYPE character)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa86721920ac4841d31577fdd99da4c4b">bsl::basic_string::replace</a> (const_iterator first, const_iterator last, INPUT_ITER stringFirst, INPUT_ITER stringLast)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga50ed91781391463b48216ff581aed48e">bsl::basic_string::swap</a> (basic_string &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga932e659d1de161e0721173e62f08d33c">bsl::basic_string::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gabf8c61395a4b50d036f5d06f0069c711">bsl::basic_string::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga9e47132aac1af1b16b2dd5ea0a2a8094">bsl::basic_string::rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gafb69c6060bfdebc5babd9a193c9be1ca">bsl::basic_string::crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gad8188c17e28370c22cae20ec8c7366db">bsl::basic_string::rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3d5d6af3ad603d4924da19364a6d5568">bsl::basic_string::crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string::length</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string::max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacdde3b4bec7a70408f92732ca3a62d23">bsl::basic_string::capacity</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">bsl::basic_string::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga223a2d900ca1f665967dfd9097826ae5">bsl::basic_string::operator[]</a> (size_type position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga5c6520944972cc1dff291a1e8413f5fb">bsl::basic_string::at</a> (size_type position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaef3786be047d65bfbe24d8497c939539">bsl::basic_string::front</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga8b8784741aacc2b4c6a0b0192264d14d">bsl::basic_string::back</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaeb2d4cf4d56a290b3091777b6cb66fc8">bsl::basic_string::copy</a> (CHAR_TYPE *characterString, size_type numChars, size_type position=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae44d262d49cf758642925805e08529ab">bsl::basic_string::c_str</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string::data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga21e221082c6b08eaa6f3f8b4a003666e">bsl::basic_string::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga7fe8ba1674bd8c0d454432836e58827a">bsl::basic_string::find</a> (const basic_string &amp;string, size_type position=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaff7c4f8fad18f3b6527f658ad762d5fb">bsl::basic_string::find</a> (const CHAR_TYPE *string, size_type position, size_type numChars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa70729dab1eab63a9e01e4629336001d">bsl::basic_string::find</a> (const CHAR_TYPE *string, size_type position=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga972a9aebff34a9b457d34361675cef1c">bsl::basic_string::find</a> (CHAR_TYPE character, size_type position=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab516a89e7e0625d7f7aeab02fa1711b4">bsl::basic_string::rfind</a> (const basic_string &amp;string, size_type position=npos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga376e9ece84c406f66191bbfd073b2e79">bsl::basic_string::rfind</a> (const CHAR_TYPE *characterString, size_type position, size_type numChars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaccb57c87fff3fe2f5d7ca7f6a59988c4">bsl::basic_string::rfind</a> (const CHAR_TYPE *characterString, size_type position=npos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga374222c5804a9217c8244fbee9bdf0fc">bsl::basic_string::rfind</a> (CHAR_TYPE character, size_type position=npos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga484c8d8ec7792356c9b119cbbf6f9a33">bsl::basic_string::find_first_of</a> (const basic_string &amp;string, size_type position=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gad3af44284b0c6c0fbcea8399bdd9bc30">bsl::basic_string::find_first_of</a> (const CHAR_TYPE *characterString, size_type position, size_type numChars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga87d0a73be0adc3ada5fa388d5fcbb22f">bsl::basic_string::find_first_of</a> (const CHAR_TYPE *characterString, size_type position=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gad7dd5685652a9f79e61ce12709b9bb39">bsl::basic_string::find_first_of</a> (CHAR_TYPE character, size_type position=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaaa66e07dac22a503d66e7bbb927b25df">bsl::basic_string::find_last_of</a> (const basic_string &amp;string, size_type position=npos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga31cd337585f032f46838338fd54bfc2f">bsl::basic_string::find_last_of</a> (const CHAR_TYPE *characterString, size_type position, size_type numChars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga218262e4d72325abfca70a904b83474b">bsl::basic_string::find_last_of</a> (const CHAR_TYPE *characterString, size_type position=npos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga295e81f61cf16fb47bb4d705ff16d5c5">bsl::basic_string::find_last_of</a> (CHAR_TYPE character, size_type position=npos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacdf727ecef642d9ae15340a3bbd22ed3">bsl::basic_string::find_first_not_of</a> (const basic_string &amp;string, size_type position=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacc2e62f92f7c65435d5cf5903faeeb7b">bsl::basic_string::find_first_not_of</a> (const CHAR_TYPE *characterString, size_type position, size_type numChars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga99c459c692089c2a4b527a56b74af81e">bsl::basic_string::find_first_not_of</a> (const CHAR_TYPE *characterString, size_type position=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga8c40cc014ae42f4867eb1063c98b1667">bsl::basic_string::find_first_not_of</a> (CHAR_TYPE character, size_type position=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacab02499b7e85d3cf0193f95e32c6c6a">bsl::basic_string::find_last_not_of</a> (const basic_string &amp;string, size_type position=npos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4aeabc89e32958ce595fdcafe86fdb69">bsl::basic_string::find_last_not_of</a> (const CHAR_TYPE *characterString, size_type position, size_type numChars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga6ed8bc6a496659c06f9b0830dbbd6016">bsl::basic_string::find_last_not_of</a> (const CHAR_TYPE *characterString, size_type position=npos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaea3ef5bb4eaffb56b86714704f008f04">bsl::basic_string::find_last_not_of</a> (CHAR_TYPE character, size_type position=npos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">basic_string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga99adb606a144a71521e23cc75f2e309c">bsl::basic_string::substr</a> (size_type position=0, size_type numChars=npos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga525e68250a8bd6aa966f41bc4a087439">bsl::basic_string::compare</a> (const basic_string &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacb0ed7da149152e171cb89437088c785">bsl::basic_string::compare</a> (size_type position, size_type numChars, const basic_string &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga69f9d735d435ca4bb34c5a7f8b4b4811">bsl::basic_string::compare</a> (size_type lhsPosition, size_type lhsNumChars, const basic_string &amp;other, size_type otherPosition, size_type otherNumChars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaee87dd79a67b213cace4c14044ada1e6">bsl::basic_string::compare</a> (const CHAR_TYPE *other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga84e589319926c3572317f3ce9f40bcbf">bsl::basic_string::compare</a> (size_type lhsPosition, size_type lhsNumChars, const CHAR_TYPE *other, size_type otherNumChars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga6c2fb24e6cbc3e3a54f9dd975a0fab34">bsl::basic_string::compare</a> (size_type lhsPosition, size_type lhsNumChars, const CHAR_TYPE *other) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga018249bd88b8a5cabef70d879d83f4e2">bsl::operator==</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga174c18650388ebbfaf65903622e8d411">bsl::operator==</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaeea3e40017b0b91afde35924cacd0236">bsl::operator==</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae4236ec7ed54aad1d2ab459c07272686">bsl::operator==</a> (const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga94f4f2fcc02cea9d859bc6fc590c37ce">bsl::operator==</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4a515bec807795fc9c397df08143ece3">bsl::operator!=</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf2fe09d66ed45e7186d3662d19098ee1">bsl::operator!=</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf17352aafac44a780c4527aff83cbd3d">bsl::operator!=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga53ac23905daba69217f6395b18a18c48">bsl::operator!=</a> (const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga099e3847d670070b532e1656f6949c6f">bsl::operator!=</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3c67cfa96cea8409daeb261194224055">bsl::operator&lt;</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga31d7c587dc965a9d5bacf1c7804e8419">bsl::operator&lt;</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga9b607b0f429d7d06fdb1ea217e029624">bsl::operator&lt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga53520ad4579b0e7ebe3a330ea3aef1a6">bsl::operator&lt;</a> (const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf6dc55ce3ecacb8f1ee81c6d19f77a05">bsl::operator&lt;</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacda2be81859ae7036eedca64e4231345">bsl::operator&gt;</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga88796fccdc9069c252a2f2da21b42a38">bsl::operator&gt;</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga2970f100d7b208f34a4422d55683f661">bsl::operator&gt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf9104abf11faaf9942d7ffd2b8de967a">bsl::operator&gt;</a> (const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga577e4a2c400b379888b612dd6cb99e7f">bsl::operator&gt;</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaccc781f81a2995d86f0343dc53b91029">bsl::operator&lt;=</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa0808c8a264435c0e68d22105dafdf4c">bsl::operator&lt;=</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga09517e1c94cbeb09c0f7726db39a4cba">bsl::operator&lt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa248cb81f7d2915d3bc73db7dc8347a2">bsl::operator&lt;=</a> (const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga88654fdf68b7f294544efe5f5137e24c">bsl::operator&lt;=</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga64a1cad020be5478c3bcda0e2f1d492c">bsl::operator&gt;=</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4824e50e3103d3fcaf2c967d611c9bf2">bsl::operator&gt;=</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gafd58b60d5dfbc0dce3b941af777ddaf3">bsl::operator&gt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1e50fd9fe50da05263c7474dc28274af">bsl::operator&gt;=</a> (const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga41cc8642f854de72b026f8c0de3df3e8">bsl::operator&gt;=</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga7002308bb0f4bda8f778835534b42c77">bsl::operator+</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOC2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae8d80734fc3cc567b156eb41cd1ef2f9">bsl::operator+</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOC1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga23ab81de15e0a819eabd833d4e772cce">bsl::operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaec70661d55ff3e072f49adf62a79089a">bsl::operator+</a> (const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae5d2808b6aedbe18b59d79f836bd6d81">bsl::operator+</a> (CHAR_TYPE lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae571b4cf326a6c1e456bd254b6c3828f">bsl::operator+</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacffc0ca7ec91947c737e86c00ae095e0">bsl::operator+</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, CHAR_TYPE rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga651fb2835be5936337f1ced5d2d23167">bsl::operator&lt;&lt;</a> (std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;os, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga389ca2ea44531dc5577498403eee4aa1">bsl::operator&gt;&gt;</a> (std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa85645c85b7e6553fc597a2fa2ddf31d">bsl::swap</a> (basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga65b2dba7122e31d8454685fb771f6063">bsl::getline</a> (std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str, CHAR_TYPE delim)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1ca512eae66e91d9165a0d5486f49520">bsl::getline</a> (std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga466018873ba5698c6e628a7a53a2b6bd">bsl::hashBasicString</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1ab59c0071935cd8bb0ad6036b167505">bsl::hashBasicString</a> (const string &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gac97967f09e38712f663c652eb381a548">bsl::hash&lt; basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &gt;::operator()</a> (const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4b3fce5dc0cd144fbc681a1858813f82">bsl::bslstl_string_fill</a> (std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;os, std::basic_streambuf&lt; CHAR_TYPE, CHAR_TRAITS &gt; *buf, size_t n)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" >CHAR_TYPE *&nbsp;&nbsp;&nbsp;<a class="el" href="group__bslstl__string.html#gae4efd14b4282e2102bbee73841ae5f2f">bsl::String_Imp::d_start_p</a></td></tr>
<tr><td class="memItemLeft" >union {</td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;BloombergLP::bsls::AlignedBuffer<br class="typebreak"/>
&lt; SHORT_BUFFER_BYTES, <br class="typebreak"/>
BloombergLP::bsls::AlignmentFromType<br class="typebreak"/>
&lt; CHAR_TYPE &gt;::VALUE &gt;&nbsp;&nbsp;&nbsp;<a class="el" href="classbsl_1_1String__Imp.html#ac60aef3548b24f52f27e21ef7d6d0d52">d_short</a></td></tr>
<tr><td class="memItemLeft" >&nbsp;&nbsp;&nbsp;CHAR_TYPE *&nbsp;&nbsp;&nbsp;<a class="el" href="group__bslstl__string.html#gae4efd14b4282e2102bbee73841ae5f2f">bsl::String_Imp::d_start_p</a></td></tr>
<tr><td class="memItemLeft" valign="top">};&nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SIZE_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp::d_length</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SIZE_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaaae930e07f058fc30aa7bc8af3cf9f81">bsl::String_Imp::d_capacity</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string::npos</a> = ~size_type(0)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Memory Allocation</a> <ul>
<li>
<a href="#3.1.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Lexicographical Comparisons</a> </li>
<li>
<a href="#3.3">Operations</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Basic Syntax</a> </li>
<li>
<a href="#3.4.2">Example 2: <code>string</code> as a data member</a> </li>
<li>
<a href="#3.4.3">Example 3: A stream text replacement filter</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a standard-compliant <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> class template. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a> </td><td>C++ standard compliant <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> implementation  </td></tr>
<tr>
<td>bsl::string </td><td><code>typedef</code> for <code><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;char&gt;</code>  </td></tr>
<tr>
<td>bsl::wstring </td><td><code>typedef</code> for <code><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;wchar&gt;</code>  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ISO C++ Standard, Section 21 [strings] </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code>, implementing standard containers, <code>std::string</code> and <code>std::wstring</code>, that hold a sequence of characters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of characters) and the sequence of characters that the string contains. The <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> <code>class</code> is parameterized by the character type, <code>CHAR_TYPE</code>, that character type's traits, <code>CHAR_TRAITS</code>, and an allocator, <code>ALLOCATOR</code>. The traits for each character type provide functions that assign, compare, and copy a sequence of those characters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> meets the requirements of a sequential container with random access iterators as specified in the [basic.string] section of the C++ standard [21.4]. The <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> implemented here adheres to the C++11 standard, except that it does not have interfaces that take rvalue references or <code>initializer_lists</code>, the <code>shrink_to_fit</code> method, functions that support numeric conversions, such as <code>stoi</code>, <code>to_string</code>, and <code>to_wstring</code>, and template specializations <code>std::u16string</code> and <code>std::u32string</code>. Note that excluded C++11 features are those that require (or are greatly simplified by) C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as a <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code>s <code>ALLOCATOR</code> template parameter determines how that <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> will allocate memory. The <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> template supports allocators meeting the requirements of the C++11 standard, in addition it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the (template parameter) type <code>ALLOCATOR</code> of an <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> instantiation is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it will be used to supply memory for the <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> throughout its lifetime; otherwise, the <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> will use the default allocator installed at the time of the <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code>'s construction (see <code>bslma_default</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="lexicographical_comparisons"></a> <a class="anchor" id="description.lexicographical_comparisons"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Lexicographical Comparisons: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Two <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code>s <code>lhs</code> and <code>rhs</code> are lexicographically compared by first determining <code>N</code>, the smaller of the lengths of <code>lhs</code> and <code>rhs</code>, and comparing characters at each position between 0 and <code>N - 1</code>, using <code>CHAR_TRAITS::lt</code> in lexicographical fashion. If <code>CHAR_TRAITS::lt</code> determines that strings are non-equal (smaller or larger), then this is the result. Otherwise, the lengths of the strings are compared and the shorter string is declared the smaller. Lexicographical comparison returns equality only when both strings have the same length and the same character value in each respective position. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;V&#39;</span>              - the <span class="stringliteral">&#39;CHAR_TYPE&#39;</span> <span class="keyword">template</span> parameter type of the
                     <span class="stringliteral">&#39;basic_string&#39;</span>
  <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>         - two distinct objects of type <span class="stringliteral">&#39;basic_string&lt;V&gt;&#39;</span>
  <span class="charliteral">&#39;k&#39;</span>              - an integral number
  <span class="stringliteral">&#39;al&#39;</span>             - an STL-style memory allocator
  <span class="stringliteral">&#39;i1&#39;</span>, <span class="stringliteral">&#39;i2&#39;</span>       - two iterators defining a sequence of <span class="stringliteral">&#39;CHAR_TYPE&#39;</span>
                     characters
  <span class="charliteral">&#39;v&#39;</span>              - an <span class="keywordtype">object</span> of type <span class="charliteral">&#39;V&#39;</span>
  <span class="stringliteral">&#39;p1&#39;</span>, <span class="stringliteral">&#39;p2&#39;</span>       - two iterators belonging to <span class="charliteral">&#39;a&#39;</span>
  distance(i1,i2)  - the number of values in the range [i1, i2)

  +-----------------------------------------+-------------------------------+
  | Operation                               | Complexity                    |
  |=========================================+===============================|
  | basic_string&lt;V&gt; a (<span class="keywordflow">default</span> construction)| O[1]                          |
  | basic_string&lt;V&gt; a(al)                   |                               |
  |-----------------------------------------+-------------------------------|
  | basic_string&lt;V&gt; a(b) (copy construction)| O[n]                          |
  | basic_string&lt;V&gt; a(b, al)                |                               |
  |-----------------------------------------+-------------------------------|
  | basic_string&lt;V&gt; a(k)                    | O[n]                          |
  | basic_string&lt;V&gt; a(k, al)                |                               |
  |-----------------------------------------+-------------------------------|
  | basic_string&lt;V&gt; a(i1, i2)               | O[distance(i1,i2)]            |
  | basic_string&lt;V&gt; a(i1, i2, al)           |                               |
  |-----------------------------------------+-------------------------------|
  | a.~basic_string&lt;V&gt;()  (destruction)     | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.assign(k, v)                          | O[k]                          |
  |-----------------------------------------+-------------------------------|
  | a.assign(i1, i2)                        | O[distance(i1,i2)]            |
  |-----------------------------------------+-------------------------------|
  | get_allocator()                         | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.begin(), a.end(),                     | O[1]                          |
  | a.cbegin(), a.cend(),                   |                               |
  | a.rbegin(), a.rend(),                   |                               |
  | a.crbegin(), a.crend()                  |                               |
  |-----------------------------------------+-------------------------------|
  | a.size()                                | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.max_size()                            | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.resize(k)                             | O[k]                          |
  | a.resize(k, v)                          |                               |
  |-----------------------------------------+-------------------------------|
  | a.empty()                               | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.reserve(k)                            | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a[k]                                    | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.at(k)                                 | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.front()                               | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.back()                                | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.push_back()                           | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.pop_back()                            | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.insert(p1, v)                         | O[1 + distance(p1, a.end())]  |
  |-----------------------------------------+-------------------------------|
  | a.insert(p1, k, v)                      | O[k + distance(p1, a.end())]  |
  |-----------------------------------------+-------------------------------|
  | a.insert(p1, i1, i2)                    | O[distance(i1, i2)            |
  |                                         |      + distance(p1, a.end())] |
  |-----------------------------------------+-------------------------------|
  | a.erase(p1)                             | O[1 + distance(p1, a.end())]  |
  |-----------------------------------------+-------------------------------|
  | a.erase(p1, p2)                         | O[1 + distance(p1, a.end())]  |
  |-----------------------------------------+-------------------------------|
  | a.<a class="code" href="group__bslstl__pair.html#ga7c1cf552d0d745d92dfaa76dd8ba4576">swap</a>(b), <a class="code" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a>(a,b)                    | O[1] <span class="keywordflow">if</span> <span class="charliteral">&#39;a&#39;</span> and <span class="charliteral">&#39;b&#39;</span> use the   |
  |                                         | same allocator, O[n + m]      |
  |                                         | otherwise                     |
  |-----------------------------------------+-------------------------------|
  | a.clear()                               | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a = b;           (assignment)           | O[n]                          |
  |-----------------------------------------+-------------------------------|
  | a == b, a != b                          | O[n]                          |
  |-----------------------------------------+-------------------------------|
  | a &lt; b, a &lt;= b, a &gt; b, a &gt;= b            | O[n]                          |
  +-----------------------------------------+-------------------------------+
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_syntax"></a> <a class="anchor" id="usage.example_1~3A_basic_syntax"></a> <a class="anchor" id="description.usage.example_1~3A_basic_syntax"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Syntax: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will show how to create and use the <code>string</code> typedef. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we will default-construct a <code>string</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> s;
  assert(s.<a class="code" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">empty</a>());
  assert(0  == s.<a class="code" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">size</a>());
  assert(<span class="stringliteral">&quot;&quot;</span> == s);
</pre></div><br/>
<br/>
 Then, we will construct a <code>string</code> object from a string literal: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> t = <span class="stringliteral">&quot;Hello World&quot;</span>;
  assert(!t.<a class="code" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">empty</a>());
  assert(11 == t.<a class="code" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">size</a>());
  assert(<span class="stringliteral">&quot;Hello World&quot;</span> == t);
</pre></div><br/>
<br/>
 Next, we will clear the contents of <code>t</code> and assign it a couple of values: first from a string literal; and second from another <code>string</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  t.<a class="code" href="group__bslstl__string.html#ga1bade383cf64eed66f1c43ae0aa450a5">clear</a>();
  assert(t.<a class="code" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">empty</a>());
  assert(<span class="stringliteral">&quot;&quot;</span> == t);

  t = <span class="stringliteral">&quot;Good Morning&quot;</span>;
  assert(!t.<a class="code" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">empty</a>());
  assert(<span class="stringliteral">&quot;Good Morning&quot;</span> == t);

  t = s;
  assert(t.<a class="code" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">empty</a>());
  assert(<span class="stringliteral">&quot;&quot;</span> == t);
  assert(t == s);
</pre></div><br/>
<br/>
 Then, we will create three <code>string</code> objects: the first representing a street name, the second a state, and the third a zipcode. We will then concatenate them into a single address <code>string</code> and print the contents of that <code>string</code> on standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> street  = <span class="stringliteral">&quot;731 Lexington Avenue&quot;</span>;
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> state   = <span class="stringliteral">&quot;NY&quot;</span>;
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> zipcode = <span class="stringliteral">&quot;10022&quot;</span>;

  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> fullAddress = street + <span class="stringliteral">&quot; &quot;</span> + state + <span class="stringliteral">&quot; &quot;</span> + zipcode;

  bsl::cout &lt;&lt; fullAddress &lt;&lt; bsl::endl;
</pre></div><br/>
<br/>
 The above print statement should produce a single line of output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  731 Lexington Avenue NY 10022
</pre></div><br/>
<br/>
 Then, we search the contents of <code>address</code> (using the <code>find</code> function) to determine if it lies on a specified street: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> streetName = <span class="stringliteral">&quot;Lexington&quot;</span>;

  <span class="keywordflow">if</span> (<a class="code" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::string::npos</a> != fullAddress.<a class="code" href="group__bslstl__string.html#ga7fe8ba1674bd8c0d454432836e58827a">find</a>(streetName, 0)) {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;The address &quot;</span> &lt;&lt; fullAddress &lt;&lt; <span class="stringliteral">&quot; is located on &quot;</span>
                &lt;&lt; streetName &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; bsl::endl;
  }
</pre></div><br/>
<br/>
 Next, we show how to get a reference providing modifiable access to the null-terminated string literal stored by a <code>string</code> object using the <code>c_str</code> function. Note that the returned string literal can be passed to various standard functions expecting a null-terminated string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>  v = <span class="stringliteral">&quot;Another string&quot;</span>;
  <span class="keyword">const</span> <span class="keywordtype">char</span>        *cs = v.<a class="code" href="group__bslstl__string.html#gae44d262d49cf758642925805e08529ab">c_str</a>();
  assert(bsl::strlen(cs) == v.<a class="code" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">size</a>());
</pre></div><br/>
<br/>
 Then, we construct two <code>string</code> objects, <code>x</code> and <code>y</code>, using a user-specified allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> allocator1, allocator2;

  <span class="keyword">const</span> <span class="keywordtype">char</span> *SHORT_STRING = <span class="stringliteral">&quot;A small string&quot;</span>;
  <span class="keyword">const</span> <span class="keywordtype">char</span> *LONG_STRING  = <span class="stringliteral">&quot;This long string would definitely cause &quot;</span>
                             <span class="stringliteral">&quot;memory to be allocated on creation&quot;</span>;

  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> x(SHORT_STRING, &amp;allocator1);
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> y(LONG_STRING,  &amp;allocator2);

  assert(SHORT_STRING == x);
  assert(LONG_STRING  == y);
</pre></div><br/>
<br/>
 Notice that, no memory was allocated from the allocator for object <code>x</code> because of the short-string optimization used in the <code>string</code> type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, we can track memory usage of <code>x</code> and <code>y</code> using <code>allocator1</code> and <code>allocator2</code> and check that memory was allocated only by <code>allocator2</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == allocator1.<a class="code" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse</a>());
  assert(1 == allocator2.<a class="code" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse</a>());
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_string_as_a_data_member"></a> <a class="anchor" id="usage.example_2~3A_string_as_a_data_member"></a> <a class="anchor" id="description.usage.example_2~3A_string_as_a_data_member"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: string as a data member: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The most common use of <code>string</code> objects are as data members in user-defined classes. In this example, we will show how <code>string</code> objects can be used as data members. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we begin to define a <code>class</code>, <code>Employee</code>, that represents the data corresponding to an employee of a company: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Employee {
      <span class="comment">// This simply constrained (value-semantic) attribute class represents</span>
      <span class="comment">// the information about an employee.  An employee&#39;s first and last</span>
      <span class="comment">// name are represented as &#39;string&#39; objects and their employee</span>
      <span class="comment">// identification number is represented by an &#39;int&#39;.  Note that the</span>
      <span class="comment">// class invariants are identically the constraints on the individual</span>
      <span class="comment">// attributes.</span>
      <span class="comment">//</span>
      <span class="comment">// This class:</span>
      <span class="comment">//: o supports a complete set of *value-semantic* operations</span>
      <span class="comment">//:   o except for &#39;bslx&#39; serialization</span>
      <span class="comment">//: o is *exception-neutral* (agnostic)</span>
      <span class="comment">//: o is *alias-safe*</span>
      <span class="comment">//: o is &#39;const&#39; *thread-safe*</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_firstName;       <span class="comment">// first name</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_lastName;        <span class="comment">// last name</span>
      <span class="keywordtype">int</span>         d_id;              <span class="comment">// identification number</span>
</pre></div><br/>
<br/>
 Next, we define the creators for this class: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      Employee(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;Employee&#39; object having the (default) attribute</span>
          <span class="comment">// values:</span>
          <span class="comment">//..</span>
          <span class="comment">//  firstName() == &quot;&quot;</span>
          <span class="comment">//  lastName()  == &quot;&quot;</span>
          <span class="comment">//  id()        == 0</span>
          <span class="comment">//..</span>
          <span class="comment">// Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default</span>
          <span class="comment">// allocator is used.</span>

      Employee(<span class="keyword">const</span> <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&amp;  firstName,
               <span class="keyword">const</span> <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&amp;  lastName,
               <span class="keywordtype">int</span>                       <span class="keywordtype">id</span>,
               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>         *basicAllocator = 0);
          <span class="comment">// Create a &#39;Employee&#39; object having the specified &#39;firstName&#39;,</span>
          <span class="comment">// &#39;lastName&#39;, and &#39;id&#39;&#39; attribute values.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      Employee(<span class="keyword">const</span> Employee&amp;   original,
               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;Employee&#39; object having the same value as the</span>
          <span class="comment">// specified &#39;original&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

          <span class="comment">// Destroy this object.</span>
</pre></div><br/>
<br/>
 Notice that all constructors of the <code>Employee</code> class are optionally provided an allocator that is then passed through to the <code>string</code> data members of <code>Employee</code>. This allows the user to control how memory is allocated by <code>Employee</code> objects. Also note that the type of the <code>firstName</code> and <code>lastName</code> arguments of the value constructor is <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>. The <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> allows specifying a <code>string</code> or a <code>const char *</code> to represent a string value. For the sake of brevity its implementation is not explored here. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, declare the remaining methods of the class: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// MANIPULATORS</span>
      Employee&amp; operator=(<span class="keyword">const</span> Employee&amp; rhs);
          <span class="comment">// Assign to this object the value of the specified &#39;rhs&#39; object,</span>
          <span class="comment">// and return a reference providing modifiable access to this</span>
          <span class="comment">// object.</span>

      <span class="keywordtype">void</span> setFirstName(<span class="keyword">const</span> <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&amp; value);
          <span class="comment">// Set the &#39;firstName&#39; attribute of this object to the specified</span>
          <span class="comment">// &#39;value&#39;.</span>

      <span class="keywordtype">void</span> setLastName(<span class="keyword">const</span> <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&amp; value);
          <span class="comment">// Set the &#39;lastName&#39; attribute of this object to the specified</span>
          <span class="comment">// &#39;value&#39;.</span>

      <span class="keywordtype">void</span> setId(<span class="keywordtype">int</span> value);
          <span class="comment">// Set the &#39;id&#39; attribute of this object to the specified &#39;value&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; firstName() <span class="keyword">const</span>;
          <span class="comment">// Return a reference providing non-modifiable access to the</span>
          <span class="comment">// &#39;firstName&#39; attribute of this object.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; lastName() <span class="keyword">const</span>;
          <span class="comment">// Return a reference providing non-modifiable access to the</span>
          <span class="comment">// &#39;lastName&#39; attribute of this object.</span>

      <span class="keywordtype">int</span> id() <span class="keyword">const</span>;
          <span class="comment">// Return the value of the &#39;id&#39; attribute of this object.</span>
  };
</pre></div><br/>
<br/>
 Next, we declare the free operators for <code>Employee</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> Employee&amp; lhs, <span class="keyword">const</span> Employee&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same</span>
      <span class="comment">// value, and &#39;false&#39; otherwise.  Two &#39;Employee&#39; objects have the</span>
      <span class="comment">// same value if all of their corresponding values of their</span>
      <span class="comment">// &#39;firstName&#39;, &#39;lastName&#39;, and &#39;id&#39; attributes are the same.</span>

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> Employee&amp; lhs, <span class="keyword">const</span> Employee&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two &#39;Employee&#39; objects do</span>
      <span class="comment">// not have the same value if any of the corresponding values of their</span>
      <span class="comment">// &#39;firstName&#39;, &#39;lastName&#39;, or &#39;id&#39; attributes are not the same.</span>
</pre></div><br/>
<br/>
 Then, we implement the various methods of the <code>Employee</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  Employee::Employee(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_firstName(basicAllocator)
  , d_lastName(basicAllocator)
  , d_id(0)
  {
  }

  <span class="keyword">inline</span>
  Employee::Employee(<span class="keyword">const</span> <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&amp;  firstName,
                     <span class="keyword">const</span> <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&amp;  lastName,
                     <span class="keywordtype">int</span>                       <span class="keywordtype">id</span>,
                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>         *basicAllocator)
  : d_firstName(firstName.begin(), firstName.end(), basicAllocator)
  , d_lastName(lastName.begin(), lastName.end(), basicAllocator)
  , d_id(id)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(!firstName.<a class="code" href="classbslstl_1_1StringRefImp.html#a25d7089cf4040c8e0c52c37ed035de38">isEmpty</a>());
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(!lastName.<a class="code" href="classbslstl_1_1StringRefImp.html#a25d7089cf4040c8e0c52c37ed035de38">isEmpty</a>());
  }

  <span class="keyword">inline</span>
  Employee::Employee(<span class="keyword">const</span> Employee&amp;   original,
                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_firstName(original.d_firstName, basicAllocator)
  , d_lastName(original.d_lastName, basicAllocator)
  , d_id(original.d_id)
  {
  }
</pre></div><br/>
<br/>
 Notice that the <code>basicAllocator</code> parameter can simply be passed as an argument to the constructor of <code>bsl::string</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now, we implement the remaining manipulators of the <code>Employee</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  Employee&amp; Employee::operator=(<span class="keyword">const</span> Employee&amp; rhs)
  {
      d_firstName = rhs.d_firstName;
      d_lastName  = rhs.d_lastName;
      d_id        = rhs.d_id;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> Employee::setFirstName(<span class="keyword">const</span> <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&amp; value)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(!value.<a class="code" href="classbslstl_1_1StringRefImp.html#a25d7089cf4040c8e0c52c37ed035de38">isEmpty</a>());

      d_firstName.assign(value.<a class="code" href="classbslstl_1_1StringRefImp.html#a3edc3a7145921428485d2b400edc8e0f">begin</a>(), value.<a class="code" href="classbslstl_1_1StringRefImp.html#adeb6bfb5198edb141869f5417aff27a7">end</a>());
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> Employee::setLastName(<span class="keyword">const</span> <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&amp; value)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(!value.<a class="code" href="classbslstl_1_1StringRefImp.html#a25d7089cf4040c8e0c52c37ed035de38">isEmpty</a>());

      d_lastName.assign(value.<a class="code" href="classbslstl_1_1StringRefImp.html#a3edc3a7145921428485d2b400edc8e0f">begin</a>(), value.<a class="code" href="classbslstl_1_1StringRefImp.html#adeb6bfb5198edb141869f5417aff27a7">end</a>());
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> Employee::setId(<span class="keywordtype">int</span> value)
  {
      d_id = value;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; Employee::firstName()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_firstName;
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; Employee::lastName()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_lastName;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> Employee::id()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_id;
  }
</pre></div><br/>
<br/>
 Finally, we implement the free operators for <code>Employee</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> Employee&amp; lhs, <span class="keyword">const</span> Employee&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.firstName() == rhs.firstName()
          &amp;&amp; lhs.lastName()  == rhs.lastName()
          &amp;&amp; lhs.id()        == rhs.id();
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> Employee&amp; lhs, <span class="keyword">const</span> Employee&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.firstName() != rhs.firstName()
          || lhs.lastName()  != rhs.lastName()
          || lhs.id()        != rhs.id();
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_a_stream_text_replacement_filter"></a> <a class="anchor" id="usage.example_3~3A_a_stream_text_replacement_filter"></a> <a class="anchor" id="description.usage.example_3~3A_a_stream_text_replacement_filter"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.4.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: A stream text replacement filter: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will utilize the <code>string</code> type and its associated utility functions to define a function that reads data from an input stream, replaces all occurrences of a specified text fragment with another text fragment, and writes the resulting text to an output stream. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the signature of the function, <code>replace</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> replace(bsl::ostream&amp;      outputStream,
               bsl::istream&amp;      inputStream,
               <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; oldString,
               <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; newString)
      <span class="comment">// Read data from the specified &#39;inputStream&#39; and replace all</span>
      <span class="comment">// occurrences of the text contained in the specified &#39;oldString&#39; in</span>
      <span class="comment">// the stream with the text contained in the specified &#39;newString&#39;.</span>
      <span class="comment">// Write the modified data to the specified &#39;outputStream&#39;.</span>
</pre></div><br/>
<br/>
 Then, we provide the implementation for <code>replace</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      <span class="keyword">const</span> <span class="keywordtype">int</span>   oldStringSize = oldString.<a class="code" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">size</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span>   newStringSize = newString.<a class="code" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">size</a>();
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> line;

      <a class="code" href="group__bslstl__string.html#ga65b2dba7122e31d8454685fb771f6063">bsl::getline</a>(inputStream, line);
</pre></div><br/>
<br/>
 Notice that we can use the <code>getline</code> free function defined in this component to read a single line of data from an input stream into a <code>bsl::string</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (!inputStream) {
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">do</span> {
</pre></div><br/>
<br/>
 Next, we use the <code>find</code> function to search the contents of <code>line</code> for characters matching the contents of <code>oldString</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">int</span> pos = line.<a class="code" href="group__bslstl__string.html#ga7fe8ba1674bd8c0d454432836e58827a">find</a>(oldString);
          <span class="keywordflow">while</span> (<a class="code" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::string::npos</a> != pos) {
</pre></div><br/>
<br/>
 Now, we use the <code>replace</code> method to modify the contents of <code>line</code> matching <code>oldString</code> to <code>newString</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">              line.<a class="code" href="group__bslstl__string.html#gaad28d25eb7340fc1e001ca844ad38d2a">replace</a>(pos, oldStringSize, newString);
              pos = line.<a class="code" href="group__bslstl__string.html#ga7fe8ba1674bd8c0d454432836e58827a">find</a>(oldString, pos + newStringSize);
</pre></div><br/>
<br/>
 Notice that we provide <code>find</code> with the starting position from which to start searching. <br/>
<br/>
<div class="fragment"><pre class="fragment">          }
</pre></div><br/>
<br/>
 Finally, we write the updated contents of <code>line</code> to the output stream: <br/>
<br/>
<div class="fragment"><pre class="fragment">          outputStream &lt;&lt; line;

          <a class="code" href="group__bslstl__string.html#ga65b2dba7122e31d8454685fb771f6063">bsl::getline</a>(inputStream, line);
      } <span class="keywordflow">while</span> (inputStream);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga126b87a50a82be88e9132b4c32bf4a3f"></a><!-- doxytag: member="bslstl_string.h::BSLSTL_CHAR_TRAITS" ref="ga126b87a50a82be88e9132b4c32bf4a3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLSTL_CHAR_TRAITS&nbsp;&nbsp;&nbsp;CHAR_TRAITS</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga18e4e2f60cb115683d0ecde9ee087981"></a><!-- doxytag: member="bslstl_string.h::BSLSTL_INSERT_RETURN_TYPE" ref="ga18e4e2f60cb115683d0ecde9ee087981" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLSTL_INSERT_RETURN_TYPE&nbsp;&nbsp;&nbsp;typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::iterator</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaf975fd039e41c7e772d392872496b82f"></a><!-- doxytag: member="bsl::basic_string::value_type" ref="gaf975fd039e41c7e772d392872496b82f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef CHAR_TRAITS::char_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac39ab7e8873845c0b12c1a81b7293d80"></a><!-- doxytag: member="bsl::basic_string::allocator_type" ref="gac39ab7e8873845c0b12c1a81b7293d80" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae80612f2bd647c7b123866246775c502"></a><!-- doxytag: member="bsl::basic_string::size_type" ref="gae80612f2bd647c7b123866246775c502" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaaaaf7ca1bfdac673b4e38e75f87b9098"></a><!-- doxytag: member="bsl::basic_string::difference_type" ref="gaaaaf7ca1bfdac673b4e38e75f87b9098" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::difference_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga82e5bc8d9dfd8dbca6b982d0e2ff30c3"></a><!-- doxytag: member="bsl::basic_string::reference" ref="ga82e5bc8d9dfd8dbca6b982d0e2ff30c3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::reference <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2326616f652478f89571fe7bf8169e36"></a><!-- doxytag: member="bsl::basic_string::const_reference" ref="ga2326616f652478f89571fe7bf8169e36" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::const_reference <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2148c96ab93d1821f8d93d013a385f47"></a><!-- doxytag: member="bsl::basic_string::pointer" ref="ga2148c96ab93d1821f8d93d013a385f47" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::pointer <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7bcefeea4235523662dfc939280390ac"></a><!-- doxytag: member="bsl::basic_string::const_pointer" ref="ga7bcefeea4235523662dfc939280390ac" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::const_pointer <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga821d2877e9e7ce1a92705ba4e1eea65b"></a><!-- doxytag: member="bsl::basic_string::iterator" ref="ga821d2877e9e7ce1a92705ba4e1eea65b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef CHAR_TYPE* <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad4457314bf933929ad631ec608a4af36"></a><!-- doxytag: member="bsl::basic_string::const_iterator" ref="gad4457314bf933929ad631ec608a4af36" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const CHAR_TYPE* <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0222d501ce939e1ea6577bd757683c05"></a><!-- doxytag: member="bsl::basic_string::reverse_iterator" ref="ga0222d501ce939e1ea6577bd757683c05" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;iterator&gt; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadb446f8b83a7f1ebe053e7cb6726e4ed"></a><!-- doxytag: member="bsl::basic_string::const_reverse_iterator" ref="gadb446f8b83a7f1ebe053e7cb6726e4ed" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;const_iterator&gt; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab67de1ebe0184939129507efe5c86bb1"></a><!-- doxytag: member="bsl::string" ref="gab67de1ebe0184939129507efe5c86bb1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef basic_string&lt;char&gt; <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab3b4e0ebb1e917062e2cc0a71d69fa81"></a><!-- doxytag: member="bsl::wstring" ref="gab3b4e0ebb1e917062e2cc0a71d69fa81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef basic_string&lt;wchar_t&gt; <a class="el" href="classbsl_1_1basic__string.html">bsl::wstring</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga9878e9f0e10750669118fa4929fbdd29"></a><!-- doxytag: member="bsl::String_Imp::ConfigurableParameters" ref="ga9878e9f0e10750669118fa4929fbdd29" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__bslstl__string.html#ga9878e9f0e10750669118fa4929fbdd29">bsl::String_Imp::ConfigurableParameters</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These configurable parameters define various aspects of the string behavior when it's not strictly defined by the Standard. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga9878e9f0e10750669118fa4929fbdd29a20d9b2a976ecad64c5e6a04e45bcaabc"></a><!-- doxytag: member="BASIC_STRING_DEALLOCATE_IN_CLEAR" ref="gga9878e9f0e10750669118fa4929fbdd29a20d9b2a976ecad64c5e6a04e45bcaabc" args="" -->BASIC_STRING_DEALLOCATE_IN_CLEAR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9878e9f0e10750669118fa4929fbdd29a5007d36656baaef1224ceef93b5fe316"></a><!-- doxytag: member="BASIC_STRING_HONOR_SHRINK_REQUEST" ref="gga9878e9f0e10750669118fa4929fbdd29a5007d36656baaef1224ceef93b5fe316" args="" -->BASIC_STRING_HONOR_SHRINK_REQUEST</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8d692e0cd17d3913d3f8ff50a3804686"></a><!-- doxytag: member="bsl::String_Imp::BSLMF_ASSERT" ref="ga8d692e0cd17d3913d3f8ff50a3804686" args="(SHORT_BUFFER_BYTES &gt;=sizeof(CHAR_TYPE *))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::BSLMF_ASSERT </td>
          <td>(</td>
          <td class="paramtype">SHORT_BUFFER_BYTES &gt;=&nbsp;</td>
          <td class="paramname"> <em>sizeof</em>CHAR_TYPE *</td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2e99c691174f68e648604c5e10c889fa"></a><!-- doxytag: member="bsl::String_Imp::BSLMF_NESTED_TRAIT_DECLARATION" ref="ga2e99c691174f68e648604c5e10c889fa" args="(String_Imp, BloombergLP::bslmf::IsBitwiseMoveable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1String__Imp.html">String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslmf::IsBitwiseMoveable&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>CHAR_TYPE</code> is required to be a POD as per the Standard, which makes <code>CHAR_TYPE</code> bitwise-moveable, so <code><a class="el" href="classbsl_1_1String__Imp.html">String_Imp</a></code> is also bitwise-moveable. </p>

</div>
</div>
<a class="anchor" id="ga748343a56e50e73b56fc93c366cd69fb"></a><!-- doxytag: member="bsl::String_Imp::computeNewCapacity" ref="ga748343a56e50e73b56fc93c366cd69fb" args="(SIZE_TYPE newLength, SIZE_TYPE oldCapacity, SIZE_TYPE maxSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SIZE_TYPE <a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::computeNewCapacity </td>
          <td>(</td>
          <td class="paramtype">SIZE_TYPE&nbsp;</td>
          <td class="paramname"> <em>newLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SIZE_TYPE&nbsp;</td>
          <td class="paramname"> <em>oldCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SIZE_TYPE&nbsp;</td>
          <td class="paramname"> <em>maxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute and return the capacity required for a string having the specified <code>newLength</code> and using the specified <code>oldCapacity</code> to exercise an exponential capacity growth necessary to ensure the amortized linear complexity of <code>push_back</code> and other operations and ensuring that the new capacity does not exceed the specified <code>maxSize</code>. Note that the behavior is undefined unless <code>newLength &gt; oldCapacity</code>, <code>newLength &lt; maxSize</code>, and <code>oldCapacity &lt; maxSize</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga34064a87dbc43f22b1185cbbd037650f"></a><!-- doxytag: member="bsl::String_Imp::String_Imp" ref="ga34064a87dbc43f22b1185cbbd037650f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename SIZE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::String_Imp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbsl_1_1String__Imp.html">String_Imp</a></code> object having (default) attribute values except that the <code>d_capacity</code> attribute is initialized with <code>SHORT_BUFFER_CAPACITY</code>. </p>

</div>
</div>
<a class="anchor" id="ga310ddffe25de004bc5ca13dc3aeaf7ae"></a><!-- doxytag: member="bsl::String_Imp::String_Imp" ref="ga310ddffe25de004bc5ca13dc3aeaf7ae" args="(SIZE_TYPE length, SIZE_TYPE capacity)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::String_Imp </td>
          <td>(</td>
          <td class="paramtype">SIZE_TYPE&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SIZE_TYPE&nbsp;</td>
          <td class="paramname"> <em>capacity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbsl_1_1String__Imp.html">String_Imp</a></code> object and initialize the <code>d_length</code> and <code>d_capacity</code> attributes with the specified <code>length</code> and specified <code>capacity</code>, respectively. If <code>capacity</code> is less then <code>SHORT_BUFFER_CAPACITY</code> then d_capacity is set to <code>SHORT_BUFFER_CAPACITY</code>. The value of the <code>d_short</code> and <code>d_start_p</code> fields are left uninitialized. <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> is required to assign either d_short or d_start_p to a proper value before using any methods of this class. </p>

</div>
</div>
<a class="anchor" id="ga1196fdf7fe5cdc34c2e0ef2d7ac810a1"></a><!-- doxytag: member="bsl::String_Imp::String_Imp" ref="ga1196fdf7fe5cdc34c2e0ef2d7ac810a1" args="(const String_Imp &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::String_Imp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1String__Imp.html">String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbsl_1_1String__Imp.html">String_Imp</a></code> object having the same value as the specified <code>original</code> object. Note that this copy constructor is generated by the compiler. </p>

</div>
</div>
<a class="anchor" id="ga922f8fc2997ddd5c4aafe2a8e73511e1"></a><!-- doxytag: member="bsl::String_Imp::~String_Imp" ref="ga922f8fc2997ddd5c4aafe2a8e73511e1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::~String_Imp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. Note that this destructor is generated by the compiler. </p>

</div>
</div>
<a class="anchor" id="gab60fccb24e62d362663c00ed6285b3ea"></a><!-- doxytag: member="bsl::String_Imp::operator=" ref="gab60fccb24e62d362663c00ed6285b3ea" args="(const String_Imp &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">String_Imp&amp; <a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1String__Imp.html">String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that this assignment operator is generated by the compiler. </p>

</div>
</div>
<a class="anchor" id="gaa84e137b4df18defbd422bd14b7afb8e"></a><!-- doxytag: member="bsl::String_Imp::swap" ref="gaa84e137b4df18defbd422bd14b7afb8e" args="(String_Imp &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename SIZE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1String__Imp.html">String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the value of this object with the value of the specified <code>other</code> object. This method provides the no-throw exception-safety guarantee. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaae930e07f058fc30aa7bc8af3cf9f81">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_capacity</a>, <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_length</a>, <a class="el" href="group__bslstl__string.html#gae4efd14b4282e2102bbee73841ae5f2f">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_start_p</a>, and <a class="el" href="group__bslstl__string.html#ga5e8fe3a4824803307fd12d99dbdb75aa">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::isShortString()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga50ed91781391463b48216ff581aed48e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="gad45a4779242e1126b7c28f5c9f38ddc9"></a><!-- doxytag: member="bsl::String_Imp::resetFields" ref="gad45a4779242e1126b7c28f5c9f38ddc9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename SIZE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::resetFields </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset all fields of this object to their default-constructed state. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaae930e07f058fc30aa7bc8af3cf9f81">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_capacity</a>, <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_length</a>, and <a class="el" href="group__bslstl__string.html#gae4efd14b4282e2102bbee73841ae5f2f">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_start_p</a>.</p>

</div>
</div>
<a class="anchor" id="gac7e983fc7ad932e4b6d80bea7c2611f0"></a><!-- doxytag: member="bsl::String_Imp::dataPtr" ref="gac7e983fc7ad932e4b6d80bea7c2611f0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename SIZE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CHAR_TYPE * <a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::dataPtr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an address providing modifiable access to the NULL-terminated C-string stored by this string object. Note that the returned address can point to either the internal short string buffer or the externally allocated memory depending on the type of the string defined by the return value of <code>isShortString</code>. </p>

<p>References <a class="el" href="classbsl_1_1String__Imp.html#ac60aef3548b24f52f27e21ef7d6d0d52">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_short</a>, <a class="el" href="group__bslstl__string.html#gae4efd14b4282e2102bbee73841ae5f2f">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_start_p</a>, and <a class="el" href="group__bslstl__string.html#ga5e8fe3a4824803307fd12d99dbdb75aa">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::isShortString()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga69f9d735d435ca4bb34c5a7f8b4b4811">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e8fe3a4824803307fd12d99dbdb75aa"></a><!-- doxytag: member="bsl::String_Imp::isShortString" ref="ga5e8fe3a4824803307fd12d99dbdb75aa" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename SIZE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::isShortString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this object contains a short string and the string data is stored in the short string buffer, and <code>false</code> if the object contains a long string (and the short string buffer contains a pointer to the string data allocated externally). </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaae930e07f058fc30aa7bc8af3cf9f81">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_capacity</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::dataPtr()</a>, and <a class="el" href="group__bslstl__string.html#gaa84e137b4df18defbd422bd14b7afb8e">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa81be1d0acf68dad7a0f5697c733ba35"></a><!-- doxytag: member="bsl::String_Imp::dataPtr" ref="gaa81be1d0acf68dad7a0f5697c733ba35" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename SIZE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CHAR_TYPE * <a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::dataPtr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an address providing non-modifiable access to the NULL-terminated C-string stored by this string object. Note that the returned address can point to either the internal short string buffer or the externally allocated memory depending on the type of the string defined by the return value of <code>isShortString</code>. </p>

<p>References <a class="el" href="classbsl_1_1String__Imp.html#ac60aef3548b24f52f27e21ef7d6d0d52">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_short</a>, <a class="el" href="group__bslstl__string.html#gae4efd14b4282e2102bbee73841ae5f2f">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_start_p</a>, and <a class="el" href="group__bslstl__string.html#ga5e8fe3a4824803307fd12d99dbdb75aa">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::isShortString()</a>.</p>

</div>
</div>
<a class="anchor" id="ga343e1760f5cc0f569f29383ba12ec447"></a><!-- doxytag: member="bsl::basic_string::basic_string" ref="ga343e1760f5cc0f569f29383ba12ec447" args="(const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty string. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not specified, a default-constructed allocator is used. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, and <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga141714d133832d9980540c42a0cd3276">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>.</p>

</div>
</div>
<a class="anchor" id="ga66be81efef3b9a52a338d0fbc5f6e43d"></a><!-- doxytag: member="bsl::basic_string::basic_string" ref="ga66be81efef3b9a52a338d0fbc5f6e43d" args="(const basic_string &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga5e8fe3a4824803307fd12d99dbdb75aa">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::isShortString()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf579ac0f9f4b1fba90d39f4e59f75fdf"></a><!-- doxytag: member="bsl::basic_string::basic_string" ref="gaf579ac0f9f4b1fba90d39f4e59f75fdf" args="(const basic_string &amp;original, const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a string that has the same value as the specified <code>original</code> string. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not specified, then a default-constructed allocator is used. Note that it is important to have two copy constructors instead of a single: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <a class="code" href="group__bslstl__string.html#ga343e1760f5cc0f569f29383ba12ec447">basic_string</a>(<span class="keyword">const</span> <a class="code" href="group__bslstl__string.html#ga343e1760f5cc0f569f29383ba12ec447">basic_string</a>&amp; original,
                       <span class="keyword">const</span> ALLCOATOR&amp;    allocator = ALLOCATOR());
</pre></div><p><br/>
<br/>
 When the copy constructor with the default allocator is used, xlC10 get confused and refuses to use the return value optimization, which then causes extra allocations when returning by value in <code>operator+</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga5e8fe3a4824803307fd12d99dbdb75aa">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::isShortString()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2a3738276c0c5e2787aca7789578166d"></a><!-- doxytag: member="bsl::basic_string::basic_string" ref="ga2a3738276c0c5e2787aca7789578166d" args="(const basic_string &amp;original, size_type position, size_type numChars=npos, const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a string that has the same value as the substring of the optionally specified <code>numChars</code> length starting at the specified <code>position</code> in the specified <code>original</code> string. If <code>numChars</code> equals <code>npos</code>, then the remaining length of the string is used (i.e., <code>numChars</code> is set to <code>original.length() - position</code>). Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not specified, a default-constructed allocator is used. Throw <code>out_of_range</code> if <code>position &gt; original.length()</code> or <code>numChars != npos</code> and <code>position + numChars &lt; original.length()</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>.</p>

</div>
</div>
<a class="anchor" id="gab4cd3e32bd8907070e471876d9d598c9"></a><!-- doxytag: member="bsl::basic_string::basic_string" ref="gab4cd3e32bd8907070e471876d9d598c9" args="(const CHAR_TYPE *characterString, const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, and <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga8306dfbd75056c067903feda53620bb9"></a><!-- doxytag: member="bsl::basic_string::basic_string" ref="ga8306dfbd75056c067903feda53620bb9" args="(const CHAR_TYPE *characterString, size_type numChars, const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a string that has the same value as the substring of the optionally specified <code>numChars</code> length starting at the specified <code>position</code> in the specified <code>characterString</code>. If <code>numChars</code> is not specified, <code>CHAR_TRAITS::length(characterString)</code> is used. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not specified, a default-constructed allocator is used. Throw <code>out_of_range</code> if <code>numChars &gt;= npos</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, and <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="gacf04572711a638c2241ca90e264f82e7"></a><!-- doxytag: member="bsl::basic_string::basic_string" ref="gacf04572711a638c2241ca90e264f82e7" args="(size_type numChars, CHAR_TYPE character, const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a string of the specified <code>numChars</code> length whose every position contains the specified <code>character</code>. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not specified, a default-constructed allocator is used. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a26067f8db06d88c95d8096cd1610d9"></a><!-- doxytag: member="bsl::basic_string::basic_string" ref="ga0a26067f8db06d88c95d8096cd1610d9" args="(INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a string from the characters in the range starting at the specified <code>first</code> and ending at the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not specified, a default-constructed allocator is used. The behavior is undefined unless <code>[first, last)</code> is a valid iterator range. </p>

</div>
</div>
<a class="anchor" id="gac73de5145e3939f4090dbc01ddcc58db"></a><!-- doxytag: member="bsl::basic_string::basic_string" ref="gac73de5145e3939f4090dbc01ddcc58db" args="(const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;original, const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a string that has the same value as the specified <code>original</code> string, where the type <code>original</code> is the string type native to the compiler's library, instantiated with the same character type and traits type, but not necessarily the same allocator type. The resulting string will contain the same sequence of characters as <code>original</code>. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not specified, then a default-constructed allocator is used. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5021d7c0b4f2ce5501b7aea6a38eda56"></a><!-- doxytag: member="bsl::basic_string::basic_string" ref="ga5021d7c0b4f2ce5501b7aea6a38eda56" args="(const BloombergLP::bslstl::StringRefData&lt; CHAR_TYPE &gt; &amp;strRef, const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const BloombergLP::bslstl::StringRefData&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>strRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a string that has the same value as the specified <code>strRef</code> string. The resulting string will contain the same sequence of characters as <code>strRef</code>. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not specified, then a default-constructed allocator is used. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8d5e8dde4a2ba49ab5975c2390370f2"></a><!-- doxytag: member="bsl::basic_string::~basic_string" ref="gaf8d5e8dde4a2ba49ab5975c2390370f2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::~basic_string </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this string object. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>, <a class="el" href="group__bslstl__string.html#gacdde3b4bec7a70408f92732ca3a62d23">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::capacity()</a>, <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

</div>
</div>
<a class="anchor" id="gaa730887a6af5ec76524fe2c74a5d8d46"></a><!-- doxytag: member="bsl::basic_string::operator=" ref="gaa730887a6af5ec76524fe2c74a5d8d46" args="(const basic_string &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this string the value of the specified <code>rhs</code> string, and return a reference providing modifiable access to this object. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, and <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

</div>
</div>
<a class="anchor" id="ga4cc4f92261516e59d09d7722de4f10ce"></a><!-- doxytag: member="bsl::basic_string::operator=" ref="ga4cc4f92261516e59d09d7722de4f10ce" args="(const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this string the value of the specified <code>rhs</code> string, and return a reference providing modifiable access to this object. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, and <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="gaf3392f11a56a8918b7aa5c4ae72101d9"></a><!-- doxytag: member="bsl::basic_string::operator=" ref="gaf3392f11a56a8918b7aa5c4ae72101d9" args="(CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this string the value of the string of length one consisting of the specified <code>character</code>, and return a reference providing modifiable access to this object. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>.</p>

</div>
</div>
<a class="anchor" id="ga25b862783d3d32a02bff9aa4c9e1a4c4"></a><!-- doxytag: member="bsl::basic_string::resize" ref="ga25b862783d3d32a02bff9aa4c9e1a4c4" args="(size_type newLength, CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the length of this string to the specified <code>newLength</code>, erasing characters at the end if <code>newLength &lt; length()</code> or appending the appropriate number of copies of the specified <code>character</code> at the end if <code>length() &lt; newLength</code>. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7cc4a9c33d8d7ce75014f4a550dcce91"></a><!-- doxytag: member="bsl::basic_string::resize" ref="ga7cc4a9c33d8d7ce75014f4a550dcce91" args="(size_type newLength)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the length of this string to the specified <code>newLength</code>, erasing characters at the end if <code>newLength &lt; length()</code> or appending the appropriate number of copies of the specified <code>character</code> at the end if <code>length() &lt; newLength</code>. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga89c1eba9a0af6cc49856833210509d4e"></a><!-- doxytag: member="bsl::basic_string::reserve" ref="ga89c1eba9a0af6cc49856833210509d4e" args="(size_type newCapacity=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newCapacity</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the capacity of this string to the specified <code>newCapacity</code>. Note that the capacity of a string is the maximum length it can accommodate without reallocation. The actual storage allocated may be higher. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga7002308bb0f4bda8f778835534b42c77">bsl::operator+()</a>, and <a class="el" href="group__bslstl__string.html#ga389ca2ea44531dc5577498403eee4aa1">bsl::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1bade383cf64eed66f1c43ae0aa450a5"></a><!-- doxytag: member="bsl::basic_string::clear" ref="ga1bade383cf64eed66f1c43ae0aa450a5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this string to an empty value. Note that the capacity may change (or not if <code>BASIC_STRING_DEALLOCATE_IN_CLEAR</code> is <code>false</code>). Note that the Standard doesn't allow to reduce capacity on <code>clear</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#gga9878e9f0e10750669118fa4929fbdd29a20d9b2a976ecad64c5e6a04e45bcaabc">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::BASIC_STRING_DEALLOCATE_IN_CLEAR</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga65b2dba7122e31d8454685fb771f6063">bsl::getline()</a>, and <a class="el" href="group__bslstl__string.html#ga389ca2ea44531dc5577498403eee4aa1">bsl::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaedf4e0c4484a05f260fda8f45aa6887"></a><!-- doxytag: member="bsl::basic_string::begin" ref="gaaedf4e0c4484a05f260fda8f45aa6887" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator referring to the first character in this modifiable string (or the past-the-end iterator if this string is empty). </p>

<p>References <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#gaa1d2382eeb4b366a2368b43272a8d6e5">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::at()</a>, <a class="el" href="group__bslstl__string.html#ga692652ff0c2a02fef66d07686d9cdb4c">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::back()</a>, <a class="el" href="group__bslstl__string.html#ga343e1760f5cc0f569f29383ba12ec447">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string()</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, <a class="el" href="group__bslstl__string.html#ga3d5d6af3ad603d4924da19364a6d5568">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::crend()</a>, <a class="el" href="group__bslstl__string.html#ga40fba499341341e223a15734121e65ee">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::end()</a>, <a class="el" href="group__bslstl__string.html#gafc5850be8c60d15b6a8d46efa5db876f">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::erase()</a>, <a class="el" href="group__bslstl__string.html#ga5cd6424f238c70dcf17508ae6efcd509">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::front()</a>, <a class="el" href="group__bslstl__string.html#ga55b93e2994f6491ba60783db444e1e41">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>, <a class="el" href="group__bslstl__string.html#ga1a5d4f6852a29ce65d258aca6d4e51e1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator[]()</a>, <a class="el" href="group__bslstl__string.html#gab7139f8e4a967c1865e0e1f76397351a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::pop_back()</a>, <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>, <a class="el" href="group__bslstl__string.html#ga4e2cc41b80c0de97a63d1acd676226c2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rend()</a>, and <a class="el" href="group__bslstl__stringbuf.html#gafe021b05a126b3d4532c9587f6d9f4eb">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::str()</a>.</p>

</div>
</div>
<a class="anchor" id="ga40fba499341341e223a15734121e65ee"></a><!-- doxytag: member="bsl::basic_string::end" ref="ga40fba499341341e223a15734121e65ee" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this modifiable string. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, and <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga8b8784741aacc2b4c6a0b0192264d14d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::back()</a>, <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>, <a class="el" href="group__bslstl__string.html#gafb69c6060bfdebc5babd9a193c9be1ca">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::crbegin()</a>, and <a class="el" href="group__bslstl__string.html#ga7e104ce3808ca8d5098737acae36dbfd">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rbegin()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e104ce3808ca8d5098737acae36dbfd"></a><!-- doxytag: member="bsl::basic_string::rbegin" ref="ga7e104ce3808ca8d5098737acae36dbfd" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reverse_iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator referring to the last character in this modifiable string (or the past-the-end reverse iterator if this string is empty). </p>

<p>References <a class="el" href="group__bslstl__string.html#ga40fba499341341e223a15734121e65ee">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::end()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e2cc41b80c0de97a63d1acd676226c2"></a><!-- doxytag: member="bsl::basic_string::rend" ref="ga4e2cc41b80c0de97a63d1acd676226c2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reverse_iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this modifiable string. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1a5d4f6852a29ce65d258aca6d4e51e1"></a><!-- doxytag: member="bsl::basic_string::operator[]" ref="ga1a5d4f6852a29ce65d258aca6d4e51e1" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reference <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the character at the specified <code>position</code> in this string if <code>position &lt; length()</code>, or a reference providing non-modifiable access to the null-terminating character if <code>position == length()</code>. The behavior is undefined unless <code>position &lt;= length()</code>, and, in the case of <code>position == length()</code>, the null-terminating character is not modified through the returned reference. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa1d2382eeb4b366a2368b43272a8d6e5"></a><!-- doxytag: member="bsl::basic_string::at" ref="gaa1d2382eeb4b366a2368b43272a8d6e5" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reference <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the character at the specified <code>position</code> in this string. Throw <code>out_of_range</code> if <code>position &gt;= length()</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5cd6424f238c70dcf17508ae6efcd509"></a><!-- doxytag: member="bsl::basic_string::front" ref="ga5cd6424f238c70dcf17508ae6efcd509" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reference <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the character at the first position in this string. The behavior is undefined if this string is empty. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::empty()</a>.</p>

</div>
</div>
<a class="anchor" id="ga692652ff0c2a02fef66d07686d9cdb4c"></a><!-- doxytag: member="bsl::basic_string::back" ref="ga692652ff0c2a02fef66d07686d9cdb4c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reference <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the character at the last position in this string. The behavior is undefined if this string is empty. Note that the last position is <code>length() - 1</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::empty()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="gad9c0939db2b84b4f3d7cbe8d8cd0cd3b"></a><!-- doxytag: member="bsl::basic_string::operator native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt;" ref="gad9c0939db2b84b4f3d7cbe8d8cd0cd3b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert this object to a string type native to the compiler's library, instantiated with the same character type and traits type, but not necessarily the same allocator type. The return string will contain the same sequence of characters as <code>orig</code> and will have a default-constructed allocator. Note that this conversion operator can be invoked implicitly (e.g., during argument passing). </p>

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="gae5474c475c04b22679ab156237cd32ea"></a><!-- doxytag: member="bsl::basic_string::operator+=" ref="gae5474c475c04b22679ab156237cd32ea" args="(const basic_string &amp;string)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga9c2fb86b756802242f98cedc716073b1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>.</p>

</div>
</div>
<a class="anchor" id="ga79206f1245792c72a41c505f1fdfe585"></a><!-- doxytag: member="bsl::basic_string::operator+=" ref="ga79206f1245792c72a41c505f1fdfe585" args="(const CHAR_TYPE *string)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>string</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>string</code> at the end of this string, and return a reference providing modifiable access to this string. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga9c2fb86b756802242f98cedc716073b1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, and <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga1a20bd0dbe3e432566b4f4e2433e7477"></a><!-- doxytag: member="bsl::basic_string::operator+=" ref="ga1a20bd0dbe3e432566b4f4e2433e7477" args="(CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>character</code> at the end of this string, and return a reference providing modifiable access to this string. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c2fb86b756802242f98cedc716073b1"></a><!-- doxytag: member="bsl::basic_string::append" ref="ga9c2fb86b756802242f98cedc716073b1" args="(const basic_string &amp;string)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#gabbd064cbe91220e783bff077a58e6b69">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, <a class="el" href="group__bslstl__string.html#gae8d80734fc3cc567b156eb41cd1ef2f9">bsl::operator+()</a>, <a class="el" href="group__bslstl__string.html#gae5474c475c04b22679ab156237cd32ea">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator+=()</a>, and <a class="el" href="group__bslstl__stringbuf.html#ga135b1efa7fe5b6022b56f16e8a89b1fd">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::xsputn()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2877072ce0e85eeccf15a256ff2e0f8a"></a><!-- doxytag: member="bsl::basic_string::append" ref="ga2877072ce0e85eeccf15a256ff2e0f8a" args="(const basic_string &amp;string, size_type position, size_type numChars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append at the end of this string the first specified <code>numChars</code> characters starting at the specified <code>position</code> in the specified <code>string</code>, or the suffix of <code>string</code> starting at <code>position</code> if <code>position + numChars</code> is larger than the length of <code>string</code>. Return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>position &gt; string.length()</code>. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="gac4401f5fc7543287231822293541ca32"></a><!-- doxytag: member="bsl::basic_string::append" ref="gac4401f5fc7543287231822293541ca32" args="(const CHAR_TYPE *characterString, size_type numChars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append at the end of this string the specified <code>numChars</code> characters from the array starting at the specified <code>characterString</code> address, and return a reference to this modifiable string. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="gabbd064cbe91220e783bff077a58e6b69"></a><!-- doxytag: member="bsl::basic_string::append" ref="gabbd064cbe91220e783bff077a58e6b69" args="(const CHAR_TYPE *characterString)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>characterString</code> (of length <code>CHAR_TRAITS::length(characterString)</code>) at the end of this string, and return a reference providing modifiable access to this string. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga9c2fb86b756802242f98cedc716073b1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, and <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga5fb62eb01697df2031aade78fc57221f"></a><!-- doxytag: member="bsl::basic_string::append" ref="ga5fb62eb01697df2031aade78fc57221f" args="(size_type numChars, CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append a number equal to the specified <code>numChars</code> of copies of the specified <code>character</code> at the end of this string, and return a reference providing modifiable access to this string. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7034cef2e187d81f2a2265e3a49d9322"></a><!-- doxytag: member="bsl::basic_string::append" ref="ga7034cef2e187d81f2a2265e3a49d9322" args="(INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append to the end of this string a string built from the characters in the range starting at the specified <code>first</code> and ending before the specified <code>last</code> iterators of the <code>iterator</code>, <code>const_iterator</code> or parameterized <code>INPUT_ITER</code> type, respectively. Return a reference providing modifiable access to this string. The behavior is undefined unless <code>[first, last)</code> is a valid iterator range. </p>

</div>
</div>
<a class="anchor" id="ga6cf77eba8e1c6889f82179256b876446"></a><!-- doxytag: member="bsl::basic_string::push_back" ref="ga6cf77eba8e1c6889f82179256b876446" args="(CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>character</code> at the end of this string. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#gacdde3b4bec7a70408f92732ca3a62d23">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::capacity()</a>, <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga65b2dba7122e31d8454685fb771f6063">bsl::getline()</a>, <a class="el" href="group__bslstl__string.html#gae5d2808b6aedbe18b59d79f836bd6d81">bsl::operator+()</a>, <a class="el" href="group__bslstl__string.html#ga1a20bd0dbe3e432566b4f4e2433e7477">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator+=()</a>, <a class="el" href="group__bslstl__string.html#ga389ca2ea44531dc5577498403eee4aa1">bsl::operator&gt;&gt;()</a>, and <a class="el" href="group__bslstl__stringbuf.html#gae8a925166e9e7071fbc78ccca5c2fb7f">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::overflow()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b257d66c0c5074edfa0973939bb6179"></a><!-- doxytag: member="bsl::basic_string::assign" ref="ga3b257d66c0c5074edfa0973939bb6179" args="(const basic_string &amp;string)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this string the value of the specified <code>string</code>, and return a reference providing modifiable access to this string. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga442cb787dcea2342b5cbea6a1069df93">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#ga343e1760f5cc0f569f29383ba12ec447">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string()</a>, <a class="el" href="group__bslstl__string.html#gafc5850be8c60d15b6a8d46efa5db876f">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::erase()</a>, <a class="el" href="group__bslstl__string.html#gaa730887a6af5ec76524fe2c74a5d8d46">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator=()</a>, <a class="el" href="group__bslstl__string.html#gab7139f8e4a967c1865e0e1f76397351a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::pop_back()</a>, and <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>.</p>

</div>
</div>
<a class="anchor" id="ga45ddf77dd0fed965fca1d3eb7fdf2fbd"></a><!-- doxytag: member="bsl::basic_string::assign" ref="ga45ddf77dd0fed965fca1d3eb7fdf2fbd" args="(const basic_string &amp;string, size_type position, size_type numChars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this string the value of the substring of the specified <code>numChars</code> length or <code>string.length() - position</code>, whichever is smaller, starting at the specified <code>position</code> in the specified <code>string</code>, and return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>position &gt; string.length()</code>. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga442cb787dcea2342b5cbea6a1069df93"></a><!-- doxytag: member="bsl::basic_string::assign" ref="ga442cb787dcea2342b5cbea6a1069df93" args="(const CHAR_TYPE *characterString)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this string the value of the specified null-terminated <code>characterString</code>, and return a reference providing modifiable access to this string. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, and <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="gab413ee9414d64d52c66eb5fca73ceb96"></a><!-- doxytag: member="bsl::basic_string::assign" ref="gab413ee9414d64d52c66eb5fca73ceb96" args="(const CHAR_TYPE *characterString, size_type numChars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this string the value of the string constructed from the specified <code>numChars</code> characters in the array starting at the specified <code>characterString</code> address, and return a reference providing modifiable access to this string. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf4e1014bf852bd9356729fc5fca4774"></a><!-- doxytag: member="bsl::basic_string::assign" ref="gaaf4e1014bf852bd9356729fc5fca4774" args="(size_type numChars, CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this string the value of a string of the specified <code>numChars</code> length whose every characters equal the specified <code>character</code>, and return a reference providing modifiable access to this string. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga141714d133832d9980540c42a0cd3276"></a><!-- doxytag: member="bsl::basic_string::assign" ref="ga141714d133832d9980540c42a0cd3276" args="(INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this string the value of a string built from the characters in the range starting at the specified <code>first</code> and ending before the specified <code>last</code> iterators of the <code>iterator</code>, <code>const_iterator</code> or parameterized <code>INPUT_ITER</code> type, respectively. Return a reference providing modifiable access to this string. The behavior is undefined unless <code>[first, last)</code> is a valid iterator range. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga343e1760f5cc0f569f29383ba12ec447">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_string()</a>, and <a class="el" href="group__bslstl__string.html#ga21e221082c6b08eaa6f3f8b4a003666e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::get_allocator()</a>.</p>

</div>
</div>
<a class="anchor" id="gac412644d4308344b0081691ec48e8442"></a><!-- doxytag: member="bsl::basic_string::insert" ref="gac412644d4308344b0081691ec48e8442" args="(size_type position, const basic_string &amp;string)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this string a copy of the specified <code>string</code>, and return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>position &gt; length()</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga61ae12c70a02028d7f4559fa6471cf92">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="gaae3683b45fb349560b817c5c0e7fbb90"></a><!-- doxytag: member="bsl::basic_string::insert" ref="gaae3683b45fb349560b817c5c0e7fbb90" args="(size_type outPosition, const basic_string &amp;string, size_type position, size_type numChars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>outPosition</code> in this string a copy of the substring of the specified <code>numChars</code> length or <code>string.length() - position</code>, whichever is smaller, starting at the specified <code>position</code> in the specified <code>string</code>, and return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>position &gt; length()</code>. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa28c69689f4914cccb4865e31a696837"></a><!-- doxytag: member="bsl::basic_string::insert" ref="gaa28c69689f4914cccb4865e31a696837" args="(size_type position, const CHAR_TYPE *characterString, size_type numChars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this string a copy of the string constructed from the specified <code>numChars</code> characters in the array starting at the specified <code>characterString</code> address, and return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>position &gt; length()</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga61ae12c70a02028d7f4559fa6471cf92"></a><!-- doxytag: member="bsl::basic_string::insert" ref="ga61ae12c70a02028d7f4559fa6471cf92" args="(size_type position, const CHAR_TYPE *characterString)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this string a copy of the string constructed from the specified <code>characterString</code> (of length <code>CHAR_TRAITS::length(characterString)</code>), and return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>position &gt; length()</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#gac412644d4308344b0081691ec48e8442">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="ga39dabb29dfa3b05bfff5a1a52f6db92a"></a><!-- doxytag: member="bsl::basic_string::insert" ref="ga39dabb29dfa3b05bfff5a1a52f6db92a" args="(size_type position, size_type numChars, CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this string a number equal to the specified <code>numChars</code> of copies of the specified <code>character</code>, and return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>position &gt; length()</code>. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga55b93e2994f6491ba60783db444e1e41"></a><!-- doxytag: member="bsl::basic_string::insert" ref="ga55b93e2994f6491ba60783db444e1e41" args="(const_iterator position, CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this string a copy of the specified <code>character</code>, and return an iterator providing modifiable access to the inserted character. The behavior is undefined unless <code>position</code> is a valid iterator on this string. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>, and <a class="el" href="group__bslstl__string.html#gac412644d4308344b0081691ec48e8442">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="gaec0a015838285fa679f695b27dfd7d1e"></a><!-- doxytag: member="bsl::basic_string::insert" ref="gaec0a015838285fa679f695b27dfd7d1e" args="(const_iterator position, size_type numChars, CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this string a specified <code>numChars</code> number of copies of the specified <code>character</code>, and return an iterator providing modifiable access to the first inserted character, or a non-const copy of the <code>position</code> iterator, if <code>numChars == 0</code>. The behavior is undefined unless <code>position</code> is a valid iterator on this string. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>, and <a class="el" href="group__bslstl__string.html#gac412644d4308344b0081691ec48e8442">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="ga729e8703bab227d076ea8aeb6b045284"></a><!-- doxytag: member="bsl::basic_string::insert" ref="ga729e8703bab227d076ea8aeb6b045284" args="(const_iterator position, INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this string a string built from the characters in the range starting at the specified <code>first</code> and ending before the specified <code>last</code> iterators, and return an iterator providing modifiable access to the first inserted character, or a non-const copy of the <code>position</code> iterator, if <code>first == last</code>. The behavior is undefined unless <code>position</code> is a valid iterator on this string and <code>[first, last)</code> is a valid iterator range. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, and <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>.</p>

</div>
</div>
<a class="anchor" id="gafc5850be8c60d15b6a8d46efa5db876f"></a><!-- doxytag: member="bsl::basic_string::erase" ref="gafc5850be8c60d15b6a8d46efa5db876f" args="(size_type position=0, size_type numChars=npos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase from this string the substring of length the optionally specified <code>numChars</code> or <code>original.length() - position</code>, whichever is smaller, starting at the optionally specified <code>position</code>. If <code>position</code> is not specified, the first position is used (i.e., <code>position</code> is set to 0). Return a reference providing modifiable access to this string. Note that if <code>numChars</code> equals <code>npos</code>, then the remaining length of the string is erased (i.e., <code>numChars</code> is set to <code>length() - position</code>). Throw <code>out_of_range</code> if <code>position &gt; length()</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga431be6461541b53f711211b84a472c2a"></a><!-- doxytag: member="bsl::basic_string::erase" ref="ga431be6461541b53f711211b84a472c2a" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase a character at the specified <code>position</code> from this string, and return an iterator providing modifiable access to the character at <code>position</code> prior to erasing. If no such character exists, return <code>end()</code>. The behavior is undefined unless <code>position</code> belongs to the half-open range <code>[cbegin(), cend())</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>, <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="gad3e452b31e49cd577ad59bff046d57a7"></a><!-- doxytag: member="bsl::basic_string::erase" ref="gad3e452b31e49cd577ad59bff046d57a7" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase from this string a substring defined by the pair of <code>first</code> and <code>last</code> iterators within this string. Return an iterator providing modifiable access to the the character at the <code>last</code> position prior to erasing. If no such character exists, return <code>end()</code>. The behavior is undefined unless <code>first</code> and <code>last</code> both belong to <code>[cbegin(), cend()]</code> and <code>first &lt;= last</code>. Note that this call invalidates existing iterators pointing to <code>first</code> or a subsequent position. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>, <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="gab7139f8e4a967c1865e0e1f76397351a"></a><!-- doxytag: member="bsl::basic_string::pop_back" ref="gab7139f8e4a967c1865e0e1f76397351a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase the last character from this string. The behavior is undefined if this string is empty. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>, <a class="el" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::empty()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="gaad28d25eb7340fc1e001ca844ad38d2a"></a><!-- doxytag: member="bsl::basic_string::replace" ref="gaad28d25eb7340fc1e001ca844ad38d2a" args="(size_type outPosition, size_type outNumChars, const basic_string &amp;string)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outNumChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the substring of this string starting at the specified <code>outPosition</code> of length <code>outNumChars</code> or <code>length() - outPosition</code>, whichever is smaller, by the specified <code>string</code>, and return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>outPosition &gt; length()</code>. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga525b75f9dff0e082007200f2a7a529ce">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace()</a>.</p>

</div>
</div>
<a class="anchor" id="gafa2bb7396a3abfdb5b8c3d0f5827dc66"></a><!-- doxytag: member="bsl::basic_string::replace" ref="gafa2bb7396a3abfdb5b8c3d0f5827dc66" args="(size_type outPosition, size_type outNumChars, const basic_string &amp;string, size_type position, size_type numChars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outNumChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the substring of this string starting at the specified <code>outPosition</code> of length <code>outNumChars</code> or <code>length() - outPosition</code>, whichever is smaller, by the substring of the specified <code>numChars</code> length or <code>string.length() - position</code>, whichever is smaller, starting at the specified <code>position</code> in the specified <code>string</code>. Return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>outPosition &gt; length()</code> or <code>position &gt; string.length()</code>. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e268bdc36e87462e7cd95981dc790f2"></a><!-- doxytag: member="bsl::basic_string::replace" ref="ga9e268bdc36e87462e7cd95981dc790f2" args="(size_type outPosition, size_type outNumChars, const CHAR_TYPE *characterString, size_type numChars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outNumChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the substring of this string starting at the specified <code>outPosition</code> of length <code>outNumChars</code> or <code>length() - outPosition</code>, whichever is smaller, by a copy of the string constructed from the specified <code>numChars</code> characters in the array starting at the specified <code>characterString</code> address. Return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>outPosition &gt; length()</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga525b75f9dff0e082007200f2a7a529ce"></a><!-- doxytag: member="bsl::basic_string::replace" ref="ga525b75f9dff0e082007200f2a7a529ce" args="(size_type outPosition, size_type outNumChars, const CHAR_TYPE *characterString)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outNumChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the substring of this string starting at the specified <code>outPosition</code> of length <code>outNumChars</code> or <code>length() - outPosition</code>, whichever is smaller, by the null-terminated specified <code>characterString</code> (of length <code>CHAR_TRAITS::length(characterString)</code>). Return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>outPosition &gt; length()</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#gaad28d25eb7340fc1e001ca844ad38d2a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace()</a>.</p>

</div>
</div>
<a class="anchor" id="ga35333503fd5bc38d53cd9a1b054b738a"></a><!-- doxytag: member="bsl::basic_string::replace" ref="ga35333503fd5bc38d53cd9a1b054b738a" args="(size_type outPosition, size_type outNumChars, size_type numChars, CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>outNumChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the substring of this string starting at the specified <code>outPosition</code> of length <code>outNumChars</code> or <code>length() - outPosition</code>, whichever is smaller, by a number equal to the specified <code>numChars</code> of copies of the specified <code>character</code>. Return a reference providing modifiable access to this string. Throw <code>out_of_range</code> if <code>outPosition &gt; length()</code>. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3831eb00bad69c251ffc910cb3031a08"></a><!-- doxytag: member="bsl::basic_string::replace" ref="ga3831eb00bad69c251ffc910cb3031a08" args="(const_iterator first, const_iterator last, const basic_string &amp;string)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the substring in the range starting at the specified <code>first</code> position and ending right before the specified <code>last</code> position, by the specified <code>string</code>. Return a reference providing modifiable access to this string. The behavior is undefined unless <code>first</code> and <code>last</code> both belong to <code>[cbegin(), cend()]</code> and <code>first &lt;= last</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga30dca582bee14c63a511c3f999da77aa"></a><!-- doxytag: member="bsl::basic_string::replace" ref="ga30dca582bee14c63a511c3f999da77aa" args="(const_iterator first, const_iterator last, const CHAR_TYPE *characterString, size_type numChars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the substring in the range starting at the specified <code>first</code> position and ending right before the specified <code>last</code> position, by a copy of the string constructed from the specified <code>numChars</code> characters in the array starting at the specified <code>characterString</code> address. Return a reference providing modifiable access to this string. The behavior is undefined unless <code>first</code> and <code>last</code> both belong to <code>[cbegin(), cend()]</code> and <code>first &lt;= last</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="gac09d3519c58209d4bfaf93a4df2f87cb"></a><!-- doxytag: member="bsl::basic_string::replace" ref="gac09d3519c58209d4bfaf93a4df2f87cb" args="(const_iterator first, const_iterator last, const CHAR_TYPE *characterString)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the substring in the range starting at the specified <code>first</code> position and ending right before the specified <code>last</code> position, by the null-terminated specified <code>characterString</code>. Return a reference providing modifiable access to this string. The behavior is undefined unless <code>first</code> and <code>last</code> both belong to the range <code>[cbegin(), cend()]</code> and <code>first &lt;= last</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>, and <a class="el" href="group__bslstl__string.html#gaad28d25eb7340fc1e001ca844ad38d2a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7cc25bf6bfda6433ecb222909f66668a"></a><!-- doxytag: member="bsl::basic_string::replace" ref="ga7cc25bf6bfda6433ecb222909f66668a" args="(const_iterator first, const_iterator last, size_type numChars, CHAR_TYPE character)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the substring in the range starting at the specified <code>first</code> position and ending right before the specified <code>last</code> position, by a number equal to the specified <code>numChars</code> of copies of the specified <code>character</code>. Return a reference providing modifiable access to this string. The behavior is undefined unless <code>first</code> and <code>last</code> both belong to the range <code>[cbegin(), cend()]</code> and <code>first &lt;= last</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa86721920ac4841d31577fdd99da4c4b"></a><!-- doxytag: member="bsl::basic_string::replace" ref="gaa86721920ac4841d31577fdd99da4c4b" args="(const_iterator first, const_iterator last, INPUT_ITER stringFirst, INPUT_ITER stringLast)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;typename INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gad4457314bf933929ad631ec608a4af36">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>stringFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>stringLast</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the substring in the range starting at the specified <code>first</code> position and ending right before the specified <code>last</code> position, by a string built from the characters in the range starting at the specified <code>stringFirst</code> and ending before the specified <code>stringLast</code> iterators of the <code>iterator</code>, <code>const_iterator</code>, or parameterized <code>INPUT_ITER</code> type, respectively. Return a reference providing modifiable access to this string. The behavior is undefined unless <code>first</code> and <code>last</code> both belong to the range <code>[cbegin(), cend()]</code>, <code>first &lt;= last</code> and <code>[stringFirst, stringLast)</code> is a valid iterator range. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga9b9731aa511086718f02540b2d0d90f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin()</a>, and <a class="el" href="group__bslstl__string.html#gaeab0a54907c6e714cd899ce76a4c73fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend()</a>.</p>

</div>
</div>
<a class="anchor" id="ga50ed91781391463b48216ff581aed48e"></a><!-- doxytag: member="bsl::basic_string::swap" ref="ga50ed91781391463b48216ff581aed48e" args="(basic_string &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this string with that of the specified <code>string</code>, so that the value of this string upon return equals that of <code>other</code> prior to this call, and vice-versa. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga21e221082c6b08eaa6f3f8b4a003666e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::get_allocator()</a>, and <a class="el" href="group__bslstl__string.html#gaa84e137b4df18defbd422bd14b7afb8e">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::swap()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#gaa85645c85b7e6553fc597a2fa2ddf31d">bsl::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga932e659d1de161e0721173e62f08d33c"></a><!-- doxytag: member="bsl::basic_string::begin" ref="ga932e659d1de161e0721173e62f08d33c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b9731aa511086718f02540b2d0d90f2"></a><!-- doxytag: member="bsl::basic_string::cbegin" ref="ga9b9731aa511086718f02540b2d0d90f2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first character of this string (or the past-the-end iterator if this string is empty). </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga431be6461541b53f711211b84a472c2a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::erase()</a>, <a class="el" href="group__bslstl__string.html#ga55b93e2994f6491ba60783db444e1e41">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>, and <a class="el" href="group__bslstl__string.html#ga3831eb00bad69c251ffc910cb3031a08">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace()</a>.</p>

</div>
</div>
<a class="anchor" id="gabf8c61395a4b50d036f5d06f0069c711"></a><!-- doxytag: member="bsl::basic_string::end" ref="gabf8c61395a4b50d036f5d06f0069c711" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, and <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>.</p>

</div>
</div>
<a class="anchor" id="gaeab0a54907c6e714cd899ce76a4c73fb"></a><!-- doxytag: member="bsl::basic_string::cend" ref="gaeab0a54907c6e714cd899ce76a4c73fb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this string. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga40fba499341341e223a15734121e65ee">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::end()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga431be6461541b53f711211b84a472c2a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::erase()</a>, <a class="el" href="group__bslstl__string.html#ga55b93e2994f6491ba60783db444e1e41">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>, and <a class="el" href="group__bslstl__string.html#ga3831eb00bad69c251ffc910cb3031a08">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e47132aac1af1b16b2dd5ea0a2a8094"></a><!-- doxytag: member="bsl::basic_string::rbegin" ref="ga9e47132aac1af1b16b2dd5ea0a2a8094" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_reverse_iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga40fba499341341e223a15734121e65ee">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::end()</a>.</p>

</div>
</div>
<a class="anchor" id="gafb69c6060bfdebc5babd9a193c9be1ca"></a><!-- doxytag: member="bsl::basic_string::crbegin" ref="gafb69c6060bfdebc5babd9a193c9be1ca" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_reverse_iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the last character of this string (or the past-the-end reverse iterator if this string is empty). </p>

<p>References <a class="el" href="group__bslstl__string.html#ga40fba499341341e223a15734121e65ee">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::end()</a>.</p>

</div>
</div>
<a class="anchor" id="gad8188c17e28370c22cae20ec8c7366db"></a><!-- doxytag: member="bsl::basic_string::rend" ref="gad8188c17e28370c22cae20ec8c7366db" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_reverse_iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3d5d6af3ad603d4924da19364a6d5568"></a><!-- doxytag: member="bsl::basic_string::crend" ref="ga3d5d6af3ad603d4924da19364a6d5568" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_reverse_iterator <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this string. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>.</p>

</div>
</div>
<a class="anchor" id="ga78edaba5c76c2e2f09067f478be101d2"></a><!-- doxytag: member="bsl::basic_string::length" ref="ga78edaba5c76c2e2f09067f478be101d2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the length of this string. Note that this number may differ from <code>CHAR_TRAITS::length(c_str())</code> in case the string contains null characters. Also note that a null-terminating character added by the <code>c_str</code> method is <em>not</em> counted in this length. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga2877072ce0e85eeccf15a256ff2e0f8a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, <a class="el" href="group__bslstl__string.html#ga45ddf77dd0fed965fca1d3eb7fdf2fbd">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#gaa1d2382eeb4b366a2368b43272a8d6e5">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::at()</a>, <a class="el" href="group__bslstl__string.html#ga692652ff0c2a02fef66d07686d9cdb4c">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::back()</a>, <a class="el" href="group__bslstl__string.html#ga525e68250a8bd6aa966f41bc4a087439">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare()</a>, <a class="el" href="group__bslstl__string.html#gaeb2d4cf4d56a290b3091777b6cb66fc8">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::copy()</a>, <a class="el" href="group__bslstl__string.html#gafc5850be8c60d15b6a8d46efa5db876f">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::erase()</a>, <a class="el" href="group__bslstl__string.html#ga7fe8ba1674bd8c0d454432836e58827a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find()</a>, <a class="el" href="group__bslstl__string.html#gacdf727ecef642d9ae15340a3bbd22ed3">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_not_of()</a>, <a class="el" href="group__bslstl__string.html#ga484c8d8ec7792356c9b119cbbf6f9a33">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_of()</a>, <a class="el" href="group__bslstl__string.html#gacab02499b7e85d3cf0193f95e32c6c6a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_not_of()</a>, <a class="el" href="group__bslstl__string.html#gaaa66e07dac22a503d66e7bbb927b25df">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_of()</a>, <a class="el" href="group__bslstl__string.html#gaae3683b45fb349560b817c5c0e7fbb90">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>, <a class="el" href="group__bslstl__string.html#gad9c0939db2b84b4f3d7cbe8d8cd0cd3b">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt;()</a>, <a class="el" href="group__bslstl__string.html#ga7002308bb0f4bda8f778835534b42c77">bsl::operator+()</a>, <a class="el" href="group__bslstl__string.html#ga53520ad4579b0e7ebe3a330ea3aef1a6">bsl::operator&lt;()</a>, <a class="el" href="group__bslstl__string.html#ga1a5d4f6852a29ce65d258aca6d4e51e1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator[]()</a>, <a class="el" href="group__bslstl__string.html#gab7139f8e4a967c1865e0e1f76397351a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::pop_back()</a>, <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>, <a class="el" href="group__bslstl__string.html#gaad28d25eb7340fc1e001ca844ad38d2a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace()</a>, <a class="el" href="group__bslstl__string.html#gab516a89e7e0625d7f7aeab02fa1711b4">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rfind()</a>, and <a class="el" href="group__bslstl__string.html#gaf8d5e8dde4a2ba49ab5975c2390370f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::~basic_string()</a>.</p>

</div>
</div>
<a class="anchor" id="gab550ff7fbf2bc8edf24ee0a3ed8ac140"></a><!-- doxytag: member="bsl::basic_string::size" ref="gab550ff7fbf2bc8edf24ee0a3ed8ac140" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the length of this string. Note that this number may differ from <code>CHAR_TRAITS::length(c_str())</code> in case the string contains null characters. Also note that a null-terminating character added by the <code>c_str</code> method is <em>not</em> counted in this length. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga466018873ba5698c6e628a7a53a2b6bd">bsl::hashBasicString()</a>, <a class="el" href="group__bslstl__string.html#ga018249bd88b8a5cabef70d879d83f4e2">bsl::operator==()</a>, <a class="el" href="group__bslstl__string.html#ga389ca2ea44531dc5577498403eee4aa1">bsl::operator&gt;&gt;()</a>, <a class="el" href="group__bslstl__stringbuf.html#gae8a925166e9e7071fbc78ccca5c2fb7f">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::overflow()</a>, <a class="el" href="group__bslstl__stringbuf.html#ga3edf3d8359dd3d334f60c690fd79e8a2">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::str()</a>, <a class="el" href="group__bslstl__stringbuf.html#ga135b1efa7fe5b6022b56f16e8a89b1fd">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::xsputn()</a>, and <a class="el" href="group__bslstl__stringbuf.html#ga8a37f30181b44753d4b0483daf0704fa">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::~basic_stringbuf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga64856cc5871a51db0b635a817b289767"></a><!-- doxytag: member="bsl::basic_string::max_size" ref="ga64856cc5871a51db0b635a817b289767" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximal possible length of this string. Note that requests to create a string longer than this number of characters is guaranteed to raise a <code>length_error</code> exception. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga21e221082c6b08eaa6f3f8b4a003666e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::get_allocator()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga2877072ce0e85eeccf15a256ff2e0f8a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, <a class="el" href="group__bslstl__string.html#ga45ddf77dd0fed965fca1d3eb7fdf2fbd">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#ga65b2dba7122e31d8454685fb771f6063">bsl::getline()</a>, <a class="el" href="group__bslstl__string.html#gaae3683b45fb349560b817c5c0e7fbb90">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>, <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>, <a class="el" href="group__bslstl__string.html#gaad28d25eb7340fc1e001ca844ad38d2a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace()</a>, <a class="el" href="group__bslstl__string.html#ga89c1eba9a0af6cc49856833210509d4e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reserve()</a>, and <a class="el" href="group__bslstl__string.html#ga25b862783d3d32a02bff9aa4c9e1a4c4">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="gacdde3b4bec7a70408f92732ca3a62d23"></a><!-- doxytag: member="bsl::basic_string::capacity" ref="gacdde3b4bec7a70408f92732ca3a62d23" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the capacity of this string, i.e., the maximum length for which resizing is guaranteed not to trigger a reallocation. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaae930e07f058fc30aa7bc8af3cf9f81">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_capacity</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>, and <a class="el" href="group__bslstl__string.html#gaf8d5e8dde4a2ba49ab5975c2390370f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::~basic_string()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf40500fd21fcacd3d5e3b52d406914c"></a><!-- doxytag: member="bsl::basic_string::empty" ref="gaaf40500fd21fcacd3d5e3b52d406914c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this string has length 0, and <code>false</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga1de95b9d967e4faedc6796cb6e05ae90">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::d_length</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga692652ff0c2a02fef66d07686d9cdb4c">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::back()</a>, <a class="el" href="group__bslstl__string.html#ga5cd6424f238c70dcf17508ae6efcd509">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::front()</a>, and <a class="el" href="group__bslstl__string.html#gab7139f8e4a967c1865e0e1f76397351a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::pop_back()</a>.</p>

</div>
</div>
<a class="anchor" id="ga223a2d900ca1f665967dfd9097826ae5"></a><!-- doxytag: member="bsl::basic_string::operator[]" ref="ga223a2d900ca1f665967dfd9097826ae5" args="(size_type position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_reference <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the character at the specified <code>position</code> in this string. The behavior is undefined unless <code>position &lt;= length()</code>. Note that if <code>position == length()</code>, a reference to the null-terminating character is returned. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c6520944972cc1dff291a1e8413f5fb"></a><!-- doxytag: member="bsl::basic_string::at" ref="ga5c6520944972cc1dff291a1e8413f5fb" args="(size_type position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_reference <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the character at the specified <code>position</code> in this string. Throw <code>out_of_range</code> if <code>position &gt;= length()</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="gaef3786be047d65bfbe24d8497c939539"></a><!-- doxytag: member="bsl::basic_string::front" ref="gaef3786be047d65bfbe24d8497c939539" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_reference <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the character at the first position in this string. The behavior is undefined if this string is empty. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::empty()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8b8784741aacc2b4c6a0b0192264d14d"></a><!-- doxytag: member="bsl::basic_string::back" ref="ga8b8784741aacc2b4c6a0b0192264d14d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_reference <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the character at the last position in this string. The behavior is undefined if this string is empty. Note that the last position is <code>length() - 1</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gaaf40500fd21fcacd3d5e3b52d406914c">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::empty()</a>, and <a class="el" href="group__bslstl__string.html#ga40fba499341341e223a15734121e65ee">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::end()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb2d4cf4d56a290b3091777b6cb66fc8"></a><!-- doxytag: member="bsl::basic_string::copy" ref="gaeb2d4cf4d56a290b3091777b6cb66fc8" args="(CHAR_TYPE *characterString, size_type numChars, size_type position=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy the specified <code>numChars</code> or <code>length() - position</code>, whichever is smaller, characters from this string into the specified <code>characterString</code> buffer, and return the number of characters copied. Throw <code>out_of_range</code> if <code>position &gt; length()</code>. Note that the output <code>characterString</code> is <em>not</em> null-terminated. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="gae44d262d49cf758642925805e08529ab"></a><!-- doxytag: member="bsl::basic_string::c_str" ref="gae44d262d49cf758642925805e08529ab" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_pointer <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an address providing non-modifiable access to the null-terminated buffer of <code>length() + 1</code> characters whose contents are identical to the value of this string. Note that any call to the string destructor or any of its manipulators invalidates the returned pointer. </p>

<p>References <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="gaac917fd3a1a7498eef93bc91d8348c8d"></a><!-- doxytag: member="bsl::basic_string::data" ref="gaac917fd3a1a7498eef93bc91d8348c8d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::const_pointer <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an address providing non-modifiable access to the null-terminated buffer of <code>length()</code> characters whose contents are identical to the value of this string. Note that any call to the string destructor or any of its manipulators invalidates the returned pointer. </p>

<p>References <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga2877072ce0e85eeccf15a256ff2e0f8a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, <a class="el" href="group__bslstl__string.html#ga45ddf77dd0fed965fca1d3eb7fdf2fbd">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#ga525e68250a8bd6aa966f41bc4a087439">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare()</a>, <a class="el" href="group__bslstl__string.html#ga7fe8ba1674bd8c0d454432836e58827a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find()</a>, <a class="el" href="group__bslstl__string.html#gacdf727ecef642d9ae15340a3bbd22ed3">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_not_of()</a>, <a class="el" href="group__bslstl__string.html#ga484c8d8ec7792356c9b119cbbf6f9a33">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_of()</a>, <a class="el" href="group__bslstl__string.html#gacab02499b7e85d3cf0193f95e32c6c6a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_not_of()</a>, <a class="el" href="group__bslstl__string.html#gaaa66e07dac22a503d66e7bbb927b25df">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_of()</a>, <a class="el" href="group__bslstl__string.html#ga466018873ba5698c6e628a7a53a2b6bd">bsl::hashBasicString()</a>, <a class="el" href="group__bslstl__string.html#gaae3683b45fb349560b817c5c0e7fbb90">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>, <a class="el" href="group__bslstl__string.html#gad9c0939db2b84b4f3d7cbe8d8cd0cd3b">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt;()</a>, <a class="el" href="group__bslstl__string.html#ga53520ad4579b0e7ebe3a330ea3aef1a6">bsl::operator&lt;()</a>, <a class="el" href="group__bslstl__string.html#ga018249bd88b8a5cabef70d879d83f4e2">bsl::operator==()</a>, <a class="el" href="group__bslstl__string.html#gaad28d25eb7340fc1e001ca844ad38d2a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::replace()</a>, <a class="el" href="group__bslstl__string.html#gab516a89e7e0625d7f7aeab02fa1711b4">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rfind()</a>, <a class="el" href="group__bslstl__stringbuf.html#ga135b1efa7fe5b6022b56f16e8a89b1fd">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::xsputn()</a>, and <a class="el" href="group__bslstl__stringbuf.html#ga8a37f30181b44753d4b0483daf0704fa">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::~basic_stringbuf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga21e221082c6b08eaa6f3f8b4a003666e"></a><!-- doxytag: member="bsl::basic_string::get_allocator" ref="ga21e221082c6b08eaa6f3f8b4a003666e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::allocator_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the allocator used by this string to supply memory. </p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga141714d133832d9980540c42a0cd3276">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>, <a class="el" href="group__bslstl__string.html#gaa85645c85b7e6553fc597a2fa2ddf31d">bsl::swap()</a>, and <a class="el" href="group__bslstl__string.html#ga50ed91781391463b48216ff581aed48e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7fe8ba1674bd8c0d454432836e58827a"></a><!-- doxytag: member="bsl::basic_string::find" ref="ga7fe8ba1674bd8c0d454432836e58827a" args="(const basic_string &amp;string, size_type position=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the starting position of the <em>first</em> occurrence of a substring whose value equals that of the specified <code>string</code>, if such a substring can be found in this string (on or <em>after</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#gaff7c4f8fad18f3b6527f658ad762d5fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find()</a>.</p>

</div>
</div>
<a class="anchor" id="gaff7c4f8fad18f3b6527f658ad762d5fb"></a><!-- doxytag: member="bsl::basic_string::find" ref="gaff7c4f8fad18f3b6527f658ad762d5fb" args="(const CHAR_TYPE *string, size_type position, size_type numChars) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, <a class="el" href="group__bslstl__string.html#ga7fe8ba1674bd8c0d454432836e58827a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

</div>
</div>
<a class="anchor" id="gaa70729dab1eab63a9e01e4629336001d"></a><!-- doxytag: member="bsl::basic_string::find" ref="gaa70729dab1eab63a9e01e4629336001d" args="(const CHAR_TYPE *string, size_type position=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the starting position of the <em>first</em> occurrence of a substring whose value equals that of the specified <code>characterString</code> of the optionally specified <code>numChars</code> length, if such a substring can be found in this string (on or <em>after</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. If <code>numChars</code> is not specified, <code>CHAR_TRAITS::length(characterString)</code> is used. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#ga7fe8ba1674bd8c0d454432836e58827a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find()</a>.</p>

</div>
</div>
<a class="anchor" id="ga972a9aebff34a9b457d34361675cef1c"></a><!-- doxytag: member="bsl::basic_string::find" ref="ga972a9aebff34a9b457d34361675cef1c" args="(CHAR_TYPE character, size_type position=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>first</em> occurrence of the specified <code>character</code>, if such an occurrence can be found in this string (on or <em>after</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, <a class="el" href="group__bslstl__string.html#ga7fe8ba1674bd8c0d454432836e58827a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

</div>
</div>
<a class="anchor" id="gab516a89e7e0625d7f7aeab02fa1711b4"></a><!-- doxytag: member="bsl::basic_string::rfind" ref="gab516a89e7e0625d7f7aeab02fa1711b4" args="(const basic_string &amp;string, size_type position=npos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the starting position of the <em>last</em> occurrence of a substring whose value equals that of the specified <code>string</code>, if such a substring can be found in this string (on or <em>before</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#gaccb57c87fff3fe2f5d7ca7f6a59988c4">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rfind()</a>.</p>

</div>
</div>
<a class="anchor" id="ga376e9ece84c406f66191bbfd073b2e79"></a><!-- doxytag: member="bsl::basic_string::rfind" ref="ga376e9ece84c406f66191bbfd073b2e79" args="(const CHAR_TYPE *characterString, size_type position, size_type numChars) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

</div>
</div>
<a class="anchor" id="gaccb57c87fff3fe2f5d7ca7f6a59988c4"></a><!-- doxytag: member="bsl::basic_string::rfind" ref="gaccb57c87fff3fe2f5d7ca7f6a59988c4" args="(const CHAR_TYPE *characterString, size_type position=npos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the starting position of the <em>last</em> occurrence of a substring whose value equals that of the specified <code>characterString</code> of the optionally specified <code>numChars</code> length, if such a substring can be found in this string (on or <em>before</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. If <code>numChars</code> is not specified, <code>CHAR_TRAITS::length(characterString)</code> is used. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#gab516a89e7e0625d7f7aeab02fa1711b4">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rfind()</a>.</p>

</div>
</div>
<a class="anchor" id="ga374222c5804a9217c8244fbee9bdf0fc"></a><!-- doxytag: member="bsl::basic_string::rfind" ref="ga374222c5804a9217c8244fbee9bdf0fc" args="(CHAR_TYPE character, size_type position=npos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>last</em> occurrence of the specified <code>character</code>, if such an occurrence can be found in this string (on or <em>before</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gab516a89e7e0625d7f7aeab02fa1711b4">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rfind()</a>.</p>

</div>
</div>
<a class="anchor" id="ga484c8d8ec7792356c9b119cbbf6f9a33"></a><!-- doxytag: member="bsl::basic_string::find_first_of" ref="ga484c8d8ec7792356c9b119cbbf6f9a33" args="(const basic_string &amp;string, size_type position=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>first</em> occurrence of a character belonging to the specified <code>string</code>, if such an occurrence can be found in this string (on or <em>after</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga87d0a73be0adc3ada5fa388d5fcbb22f">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gad3af44284b0c6c0fbcea8399bdd9bc30"></a><!-- doxytag: member="bsl::basic_string::find_first_of" ref="gad3af44284b0c6c0fbcea8399bdd9bc30" args="(const CHAR_TYPE *characterString, size_type position, size_type numChars) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

</div>
</div>
<a class="anchor" id="ga87d0a73be0adc3ada5fa388d5fcbb22f"></a><!-- doxytag: member="bsl::basic_string::find_first_of" ref="ga87d0a73be0adc3ada5fa388d5fcbb22f" args="(const CHAR_TYPE *characterString, size_type position=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>first</em> occurrence of a character belonging to the specified <code>characterString</code> of the optionally specified <code>numChars</code> length, if such an occurrence can be found in this string (on or <em>after</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. If <code>numChars</code> is not specified, <code>CHAR_TRAITS::length(characterString)</code> is used. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#ga484c8d8ec7792356c9b119cbbf6f9a33">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gad7dd5685652a9f79e61ce12709b9bb39"></a><!-- doxytag: member="bsl::basic_string::find_first_of" ref="gad7dd5685652a9f79e61ce12709b9bb39" args="(CHAR_TYPE character, size_type position=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>first</em> occurrence of the specified <code>character</code>, if such an occurrence can be found in this string (on or <em>after</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga484c8d8ec7792356c9b119cbbf6f9a33">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa66e07dac22a503d66e7bbb927b25df"></a><!-- doxytag: member="bsl::basic_string::find_last_of" ref="gaaa66e07dac22a503d66e7bbb927b25df" args="(const basic_string &amp;string, size_type position=npos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>last</em> occurrence of a character belonging to the specified <code>string</code>, if such an occurrence can be found in this string (on or <em>before</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga218262e4d72325abfca70a904b83474b">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_of()</a>.</p>

</div>
</div>
<a class="anchor" id="ga31cd337585f032f46838338fd54bfc2f"></a><!-- doxytag: member="bsl::basic_string::find_last_of" ref="ga31cd337585f032f46838338fd54bfc2f" args="(const CHAR_TYPE *characterString, size_type position, size_type numChars) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

</div>
</div>
<a class="anchor" id="ga218262e4d72325abfca70a904b83474b"></a><!-- doxytag: member="bsl::basic_string::find_last_of" ref="ga218262e4d72325abfca70a904b83474b" args="(const CHAR_TYPE *characterString, size_type position=npos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>last</em> occurrence of a character belonging to the specified <code>characterString</code> of the optionally specified <code>numChars</code> length, if such an occurrence can be found in this string (on or <em>before</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. If <code>numChars</code> is not specified, <code>CHAR_TRAITS::length(characterString)</code> is used. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#gaaa66e07dac22a503d66e7bbb927b25df">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_of()</a>.</p>

</div>
</div>
<a class="anchor" id="ga295e81f61cf16fb47bb4d705ff16d5c5"></a><!-- doxytag: member="bsl::basic_string::find_last_of" ref="ga295e81f61cf16fb47bb4d705ff16d5c5" args="(CHAR_TYPE character, size_type position=npos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>last</em> occurrence of the specified <code>character</code>, if such an occurrence can be found in this string (on or <em>before</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaa66e07dac22a503d66e7bbb927b25df">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gacdf727ecef642d9ae15340a3bbd22ed3"></a><!-- doxytag: member="bsl::basic_string::find_first_not_of" ref="gacdf727ecef642d9ae15340a3bbd22ed3" args="(const basic_string &amp;string, size_type position=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>first</em> occurrence of a character <em>not</em> belonging to the specified <code>string</code>, if such an occurrence can be found in this string (on or <em>after</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga99c459c692089c2a4b527a56b74af81e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_not_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gacc2e62f92f7c65435d5cf5903faeeb7b"></a><!-- doxytag: member="bsl::basic_string::find_first_not_of" ref="gacc2e62f92f7c65435d5cf5903faeeb7b" args="(const CHAR_TYPE *characterString, size_type position, size_type numChars) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

</div>
</div>
<a class="anchor" id="ga99c459c692089c2a4b527a56b74af81e"></a><!-- doxytag: member="bsl::basic_string::find_first_not_of" ref="ga99c459c692089c2a4b527a56b74af81e" args="(const CHAR_TYPE *characterString, size_type position=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>first</em> occurrence of a character <em>not</em> belonging to the specified <code>characterString</code> of the optionally specified <code>numChars</code> length, if such an occurrence can be found in this string (on or <em>after</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. If <code>numChars</code> is not specified, <code>CHAR_TRAITS::length(characterString)</code> is used. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#gacdf727ecef642d9ae15340a3bbd22ed3">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_not_of()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c40cc014ae42f4867eb1063c98b1667"></a><!-- doxytag: member="bsl::basic_string::find_first_not_of" ref="ga8c40cc014ae42f4867eb1063c98b1667" args="(CHAR_TYPE character, size_type position=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>first</em> occurrence of a character <em>different</em> from the specified <code>character</code>, if such an occurrence can be found in this string (on or <em>after</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gacdf727ecef642d9ae15340a3bbd22ed3">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_not_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gacab02499b7e85d3cf0193f95e32c6c6a"></a><!-- doxytag: member="bsl::basic_string::find_last_not_of" ref="gacab02499b7e85d3cf0193f95e32c6c6a" args="(const basic_string &amp;string, size_type position=npos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>last</em> occurrence of a character <em>not</em> belonging to the specified <code>string</code>, if such an occurrence can be found in this string (on or <em>before</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga6ed8bc6a496659c06f9b0830dbbd6016">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_not_of()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4aeabc89e32958ce595fdcafe86fdb69"></a><!-- doxytag: member="bsl::basic_string::find_last_not_of" ref="ga4aeabc89e32958ce595fdcafe86fdb69" args="(const CHAR_TYPE *characterString, size_type position, size_type numChars) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, ALLOCATOR::size_type &gt;::dataPtr()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos</a>.</p>

</div>
</div>
<a class="anchor" id="ga6ed8bc6a496659c06f9b0830dbbd6016"></a><!-- doxytag: member="bsl::basic_string::find_last_not_of" ref="ga6ed8bc6a496659c06f9b0830dbbd6016" args="(const CHAR_TYPE *characterString, size_type position=npos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>characterString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>last</em> occurrence of a character <em>not</em> belonging to the specified <code>characterString</code> of the optionally specified <code>numChars</code> length, if such an occurrence can be found in this string (on or <em>before</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. If <code>numChars</code> is not specified, <code>CHAR_TRAITS::length(characterString)</code> is used. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#gacab02499b7e85d3cf0193f95e32c6c6a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_not_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gaea3ef5bb4eaffb56b86714704f008f04"></a><!-- doxytag: member="bsl::basic_string::find_last_not_of" ref="gaea3ef5bb4eaffb56b86714704f008f04" args="(CHAR_TYPE character, size_type position=npos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the position of the <em>last</em> occurrence of a character <em>different</em> from the specified <code>character</code>, if such an occurrence can be found in this string (on or <em>before</em> the optionally specified <code>position</code> if such a <code>position</code> is specified), and return <code>npos</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__string.html#gacab02499b7e85d3cf0193f95e32c6c6a">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_not_of()</a>.</p>

</div>
</div>
<a class="anchor" id="ga99adb606a144a71521e23cc75f2e309c"></a><!-- doxytag: member="bsl::basic_string::substr" ref="ga99adb606a144a71521e23cc75f2e309c" args="(size_type position=0, size_type numChars=npos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::substr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em> = <code><a class="el" href="group__bslstl__string.html#ga700a29a04787c42a48ec3d0f1eea57ba">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a string whose value is the substring of length the optionally specified <code>numChars</code> or <code>length() - position</code>, whichever is smaller, starting at the optionally specified <code>position</code> in this string. If <code>position</code> is not specified, 0 is used (i.e., the substring is from the beginning of this string). If <code>numChars</code> is not specified, <code>npos</code> is used (i.e., the entire suffix from <code>position</code> to the end of the string is returned). </p>

</div>
</div>
<a class="anchor" id="ga525e68250a8bd6aa966f41bc4a087439"></a><!-- doxytag: member="bsl::basic_string::compare" ref="ga525e68250a8bd6aa966f41bc4a087439" args="(const basic_string &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compare this string with the specified <code>other</code> string (using <code>CHAR_TRAITS::lt</code> to compare characters), and return a negative value if this string is less than <code>other</code>, a positive value if it is more than <code>other</code>, and 0 in case of equality. See "Lexicographical Comparisons" for definitions. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga6c2fb24e6cbc3e3a54f9dd975a0fab34">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare()</a>.</p>

</div>
</div>
<a class="anchor" id="gacb0ed7da149152e171cb89437088c785"></a><!-- doxytag: member="bsl::basic_string::compare" ref="gacb0ed7da149152e171cb89437088c785" args="(size_type position, size_type numChars, const basic_string &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compare the substring of this string starting at the specified <code>lhsPosition</code> of length <code>lhsNumChars</code> or <code>length() - lhsPosition</code>, whichever is smaller, with the specified <code>other</code> string (using <code>CHAR_TRAITS::lt</code> to compare characters), and return a negative value if this string is less than <code>other</code>, a positive value if it is more than <code>other</code>, and 0 in case of equality. See "Lexicographical Comparisons" for definitions. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga69f9d735d435ca4bb34c5a7f8b4b4811"></a><!-- doxytag: member="bsl::basic_string::compare" ref="ga69f9d735d435ca4bb34c5a7f8b4b4811" args="(size_type lhsPosition, size_type lhsNumChars, const basic_string &amp;other, size_type otherPosition, size_type otherNumChars) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>lhsPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>lhsNumChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>otherPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>otherNumChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compare the substring of this string starting at the specified <code>lhsPosition</code> of length <code>lhsNumChars</code> or <code>length() - lhsPosition</code>, whichever is smaller, with the substring of the specified <code>other</code> string starting at the specified <code>otherPosition</code> of length <code>otherNumChars</code> or <code>length() - otherPosition</code>, whichever is smaller, (using <code>CHAR_TRAITS::lt</code> to compare characters), and return a negative value if this string is less than <code>other</code>, a positive value if it is more than <code>other</code>, and 0 in case of equality. Throw <code>out_of_range</code> if <code>lhsPosition &gt; length()</code> or <code>otherPosition &gt; other.length()</code>. See "Lexicographical Comparisons" for definitions. </p>

<p>References <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::dataPtr()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="gaee87dd79a67b213cace4c14044ada1e6"></a><!-- doxytag: member="bsl::basic_string::compare" ref="gaee87dd79a67b213cace4c14044ada1e6" args="(const CHAR_TYPE *other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compare this string with the null-terminated specified <code>other</code> string (of length <code>CHAR_TRAITS::length(other)</code>, using <code>CHAR_TRAITS::lt</code> to compare characters), and return a negative value if this string is less than <code>other</code>, a positive value if it is more than <code>other</code>, and 0 in case of equality. See "Lexicographical Comparisons" for definitions. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga84e589319926c3572317f3ce9f40bcbf"></a><!-- doxytag: member="bsl::basic_string::compare" ref="ga84e589319926c3572317f3ce9f40bcbf" args="(size_type lhsPosition, size_type lhsNumChars, const CHAR_TYPE *other, size_type otherNumChars) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>lhsPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>lhsNumChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>otherNumChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compare the substring of this string starting at the specified <code>lhsPosition</code> of length <code>lhsNumChars</code> or <code>length() - lhsPosition</code>, whichever is smaller, with the string constructed from the specified <code>numChars</code> characters in the array starting at the specified <code>characterString</code> address, and return a negative value if this string is less than <code>other</code>, a positive value if it is more than <code>other</code>, and 0 in case of equality. Throw <code>out_of_range</code> if <code>lhsPosition &gt; length()</code>. See "Lexicographical
         Comparisons" for definitions. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6c2fb24e6cbc3e3a54f9dd975a0fab34"></a><!-- doxytag: member="bsl::basic_string::compare" ref="ga6c2fb24e6cbc3e3a54f9dd975a0fab34" args="(size_type lhsPosition, size_type lhsNumChars, const CHAR_TYPE *other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>lhsPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__string.html#gae80612f2bd647c7b123866246775c502">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>lhsNumChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compare the substring of this string starting at the specified <code>lhsPosition</code> of length <code>lhsNumChars</code> or <code>length() - lhsPosition</code>, whichever is smaller, with the null-terminated specified <code>other</code> string (of length <code>CHAR_TRAITS::length(other)</code>, using <code>CHAR_TRAITS::lt</code> to compare characters), and return a negative value if this string is less than <code>other</code>, a positive value if it is more than <code>other</code>, and 0 in case of equality. Throw <code>out_of_range</code> if <code>lhsPosition &gt; length()</code>. See "Lexicographical Comparisons" for definitions. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bslstl__string.html#ga525e68250a8bd6aa966f41bc4a087439">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::compare()</a>.</p>

</div>
</div>
<a class="anchor" id="ga018249bd88b8a5cabef70d879d83f4e2"></a><!-- doxytag: member="bsl::operator==" ref="ga018249bd88b8a5cabef70d879d83f4e2" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga174c18650388ebbfaf65903622e8d411"></a><!-- doxytag: member="bsl::operator==" ref="ga174c18650388ebbfaf65903622e8d411" args="(const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeea3e40017b0b91afde35924cacd0236"></a><!-- doxytag: member="bsl::operator==" ref="gaeea3e40017b0b91afde35924cacd0236" args="(const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="gae4236ec7ed54aad1d2ab459c07272686"></a><!-- doxytag: member="bsl::operator==" ref="gae4236ec7ed54aad1d2ab459c07272686" args="(const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga94f4f2fcc02cea9d859bc6fc590c37ce"></a><!-- doxytag: member="bsl::operator==" ref="ga94f4f2fcc02cea9d859bc6fc590c37ce" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> string has the same value as the specified <code>rhs</code> string, and <code>false</code> otherwise. Two strings have the same value if they have the same length, and the characters at each respective position have the same value according to <code>CHAR_TRAITS::eq</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a515bec807795fc9c397df08143ece3"></a><!-- doxytag: member="bsl::operator!=" ref="ga4a515bec807795fc9c397df08143ece3" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf2fe09d66ed45e7186d3662d19098ee1"></a><!-- doxytag: member="bsl::operator!=" ref="gaf2fe09d66ed45e7186d3662d19098ee1" args="(const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf17352aafac44a780c4527aff83cbd3d"></a><!-- doxytag: member="bsl::operator!=" ref="gaf17352aafac44a780c4527aff83cbd3d" args="(const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga53ac23905daba69217f6395b18a18c48"></a><!-- doxytag: member="bsl::operator!=" ref="ga53ac23905daba69217f6395b18a18c48" args="(const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga099e3847d670070b532e1656f6949c6f"></a><!-- doxytag: member="bsl::operator!=" ref="ga099e3847d670070b532e1656f6949c6f" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> string has a different value from the specified <code>rhs</code> string, and <code>false</code> otherwise. Two strings have the same value if they have the same length, and the characters at each respective position have the same value according to <code>CHAR_TRAITS::eq</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c67cfa96cea8409daeb261194224055"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga3c67cfa96cea8409daeb261194224055" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga31d7c587dc965a9d5bacf1c7804e8419"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga31d7c587dc965a9d5bacf1c7804e8419" args="(const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9b607b0f429d7d06fdb1ea217e029624"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga9b607b0f429d7d06fdb1ea217e029624" args="(const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga53520ad4579b0e7ebe3a330ea3aef1a6"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga53520ad4579b0e7ebe3a330ea3aef1a6" args="(const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf6dc55ce3ecacb8f1ee81c6d19f77a05"></a><!-- doxytag: member="bsl::operator&lt;" ref="gaf6dc55ce3ecacb8f1ee81c6d19f77a05" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> string has a lexicographically smaller value than the specified <code>rhs</code> string, and <code>false</code> otherwise. See "Lexicographical Comparisons" for definitions. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="gacda2be81859ae7036eedca64e4231345"></a><!-- doxytag: member="bsl::operator&gt;" ref="gacda2be81859ae7036eedca64e4231345" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga88796fccdc9069c252a2f2da21b42a38"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga88796fccdc9069c252a2f2da21b42a38" args="(const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2970f100d7b208f34a4422d55683f661"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga2970f100d7b208f34a4422d55683f661" args="(const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf9104abf11faaf9942d7ffd2b8de967a"></a><!-- doxytag: member="bsl::operator&gt;" ref="gaf9104abf11faaf9942d7ffd2b8de967a" args="(const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga577e4a2c400b379888b612dd6cb99e7f"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga577e4a2c400b379888b612dd6cb99e7f" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> string has a lexicographically larger value than the specified <code>rhs</code> string, and <code>false</code> otherwise. See "Lexicographical Comparisons" for definitions. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="gaccc781f81a2995d86f0343dc53b91029"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gaccc781f81a2995d86f0343dc53b91029" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa0808c8a264435c0e68d22105dafdf4c"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gaa0808c8a264435c0e68d22105dafdf4c" args="(const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga09517e1c94cbeb09c0f7726db39a4cba"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga09517e1c94cbeb09c0f7726db39a4cba" args="(const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa248cb81f7d2915d3bc73db7dc8347a2"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gaa248cb81f7d2915d3bc73db7dc8347a2" args="(const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga88654fdf68b7f294544efe5f5137e24c"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga88654fdf68b7f294544efe5f5137e24c" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> string has a value lexicographically smaller than or or equal to the specified <code>rhs</code> string, and <code>false</code> otherwise. See "Lexicographical Comparisons" for definitions. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga64a1cad020be5478c3bcda0e2f1d492c"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ga64a1cad020be5478c3bcda0e2f1d492c" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4824e50e3103d3fcaf2c967d611c9bf2"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ga4824e50e3103d3fcaf2c967d611c9bf2" args="(const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gafd58b60d5dfbc0dce3b941af777ddaf3"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gafd58b60d5dfbc0dce3b941af777ddaf3" args="(const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1e50fd9fe50da05263c7474dc28274af"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ga1e50fd9fe50da05263c7474dc28274af" args="(const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga41cc8642f854de72b026f8c0de3df3e8"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ga41cc8642f854de72b026f8c0de3df3e8" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> string has a value lexicographically larger than or equal to the specified <code>rhs</code> string, and <code>false</code> otherwise. See "Lexicographical Comparisons" for definitions. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ga7002308bb0f4bda8f778835534b42c77"></a><!-- doxytag: member="bsl::operator+" ref="ga7002308bb0f4bda8f778835534b42c77" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; bsl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga89c1eba9a0af6cc49856833210509d4e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reserve()</a>.</p>

</div>
</div>
<a class="anchor" id="gae8d80734fc3cc567b156eb41cd1ef2f9"></a><!-- doxytag: member="bsl::operator+" ref="gae8d80734fc3cc567b156eb41cd1ef2f9" args="(const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; bsl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga9c2fb86b756802242f98cedc716073b1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga89c1eba9a0af6cc49856833210509d4e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reserve()</a>.</p>

</div>
</div>
<a class="anchor" id="ga23ab81de15e0a819eabd833d4e772cce"></a><!-- doxytag: member="bsl::operator+" ref="ga23ab81de15e0a819eabd833d4e772cce" args="(const bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; bsl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga9c2fb86b756802242f98cedc716073b1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga89c1eba9a0af6cc49856833210509d4e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reserve()</a>.</p>

</div>
</div>
<a class="anchor" id="gaec70661d55ff3e072f49adf62a79089a"></a><!-- doxytag: member="bsl::operator+" ref="gaec70661d55ff3e072f49adf62a79089a" args="(const CHAR_TYPE *lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; bsl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga9c2fb86b756802242f98cedc716073b1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga89c1eba9a0af6cc49856833210509d4e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reserve()</a>.</p>

</div>
</div>
<a class="anchor" id="gae5d2808b6aedbe18b59d79f836bd6d81"></a><!-- doxytag: member="bsl::operator+" ref="gae5d2808b6aedbe18b59d79f836bd6d81" args="(CHAR_TYPE lhs, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; bsl::operator+ </td>
          <td>(</td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>, and <a class="el" href="group__bslstl__string.html#ga89c1eba9a0af6cc49856833210509d4e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reserve()</a>.</p>

</div>
</div>
<a class="anchor" id="gae571b4cf326a6c1e456bd254b6c3828f"></a><!-- doxytag: member="bsl::operator+" ref="gae571b4cf326a6c1e456bd254b6c3828f" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; bsl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__string.html#ga9c2fb86b756802242f98cedc716073b1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, and <a class="el" href="group__bslstl__string.html#ga89c1eba9a0af6cc49856833210509d4e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reserve()</a>.</p>

</div>
</div>
<a class="anchor" id="gacffc0ca7ec91947c737e86c00ae095e0"></a><!-- doxytag: member="bsl::operator+" ref="gacffc0ca7ec91947c737e86c00ae095e0" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, CHAR_TYPE rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; bsl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the concatenation of strings constructed from the specified <code>lhs</code> and <code>rhs</code> arguments, i.e., <code>basic_string(lhs).append(rhs)</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::length()</a>, <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>, and <a class="el" href="group__bslstl__string.html#ga89c1eba9a0af6cc49856833210509d4e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reserve()</a>.</p>

</div>
</div>
<a class="anchor" id="ga651fb2835be5936337f1ced5d2d23167"></a><!-- doxytag: member="bsl::operator&lt;&lt;" ref="ga651fb2835be5936337f1ced5d2d23167" args="(std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;os, const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp; bsl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the string specified by <code>str</code> into the output stream specified by <code>os</code> and return <code>os</code>. If the string is shorter than <code>os.width()</code>, then it is padded to <code>os.width()</code> with the current <code>os.fill()</code> character. The padding, if any, is output after the string (on the right) if <code>os.flags() | ios::left</code> is non-zero and before the string otherwise. This function will do nothing unless <code>os.good()</code> is true on entry. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga4b3fce5dc0cd144fbc681a1858813f82">bsl::bslstl_string_fill()</a>.</p>

</div>
</div>
<a class="anchor" id="ga389ca2ea44531dc5577498403eee4aa1"></a><!-- doxytag: member="bsl::operator&gt;&gt;" ref="ga389ca2ea44531dc5577498403eee4aa1" args="(std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp; bsl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the contents of the specified <code>str</code> string with a word read from the specified <code>is</code> input stream and return <code>is</code>. The word begins at the first non-whitespace character on the input stream and ends when another whitespace character (or eof) is found. The trailing whitespace character is left on the input stream. If <code>is.good()</code> is not true on entry or if eof is found before any non-whitespace characters, then <code>str</code> is unchanged and <code>is.fail()</code> is becomes true. If eof is detected after some characters have been read into <code>str</code>, then <code>is.eof()</code> becomes true, but <code>is.fail()</code> does not. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga1bade383cf64eed66f1c43ae0aa450a5">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::clear()</a>, <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>, <a class="el" href="group__bslstl__string.html#ga89c1eba9a0af6cc49856833210509d4e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::reserve()</a>, and <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa85645c85b7e6553fc597a2fa2ddf31d"></a><!-- doxytag: member="bsl::swap" ref="gaa85645c85b7e6553fc597a2fa2ddf31d" args="(basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the values of the specified <code>lhs</code> and <code>rhs</code> strings in constant time without throwing an exception. The behavior is undefined unless <code>lhs.get_allocator() == rhs.get_allocator()</code>. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, <a class="el" href="group__bslstl__string.html#ga21e221082c6b08eaa6f3f8b4a003666e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::get_allocator()</a>, and <a class="el" href="group__bslstl__string.html#ga50ed91781391463b48216ff581aed48e">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga65b2dba7122e31d8454685fb771f6063"></a><!-- doxytag: member="bsl::getline" ref="ga65b2dba7122e31d8454685fb771f6063" args="(std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str, CHAR_TYPE delim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp; bsl::getline </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR_TYPE&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the contents of the specified <code>str</code> string by extracting characters from the specified <code>is</code> stream until the specified <code>delim</code> character is extracted and return <code>is</code>. The <code>delim</code> character is removed from the input stream but is not appended to <code>str</code>. If an <code>eof</code> is detected before <code>delim</code>, then the characters up to the <code>eof</code> are put into <code>str</code> and <code>is.eof()</code> becomes true. If <code>is.good()</code> is false on entry, then do nothing, otherwise if no characters are extracted (e.g., because because the stream is at eof), <code>str</code> will become empty and <code>is.fail()</code> will become true. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga1bade383cf64eed66f1c43ae0aa450a5">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::clear()</a>, <a class="el" href="group__bslstl__string.html#ga64856cc5871a51db0b635a817b289767">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::max_size()</a>, and <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga1ca512eae66e91d9165a0d5486f49520">bsl::getline()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ca512eae66e91d9165a0d5486f49520"></a><!-- doxytag: member="bsl::getline" ref="ga1ca512eae66e91d9165a0d5486f49520" args="(std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp; bsl::getline </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the contents of the specified <code>str</code> string by extracting characters from the specified <code>is</code> stream until a newline character (is.widen(<code>\n</code>) is extracted and return <code>is</code>. The newline character is removed from the input stream but is not appended to <code>str</code>. If an <code>eof</code> is detected before the newline, then the characters up to the <code>eof</code> are put into <code>str</code> and <code>is.eof()</code> becomes true. If <code>is.good()</code> is false on entry, then do nothing, otherwise if no characters are extracted (e.g., because because the stream is at eof), <code>str</code> will become empty and <code>is.fail()</code> will become true. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga65b2dba7122e31d8454685fb771f6063">bsl::getline()</a>.</p>

</div>
</div>
<a class="anchor" id="ga466018873ba5698c6e628a7a53a2b6bd"></a><!-- doxytag: member="bsl::hashBasicString" ref="ga466018873ba5698c6e628a7a53a2b6bd" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bsl::hashBasicString </td>
          <td>(</td>
          <td class="paramtype">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value for the specified <code>str</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#gac97967f09e38712f663c652eb381a548">bsl::hash&lt; basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ab59c0071935cd8bb0ad6036b167505"></a><!-- doxytag: member="bsl::hashBasicString" ref="ga1ab59c0071935cd8bb0ad6036b167505" args="(const string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bsl::hashBasicString </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value for the specified <code>str</code>. </p>

</div>
</div>
<a class="anchor" id="gac97967f09e38712f663c652eb381a548"></a><!-- doxytag: member="bsl::hash&lt; basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &gt;::operator()" ref="gac97967f09e38712f663c652eb381a548" args="(const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bsl::hash&lt; basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Return a hash value computed using the specified <code>str</code> value. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga466018873ba5698c6e628a7a53a2b6bd">bsl::hashBasicString()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4b3fce5dc0cd144fbc681a1858813f82"></a><!-- doxytag: member="bsl::bslstl_string_fill" ref="ga4b3fce5dc0cd144fbc681a1858813f82" args="(std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;os, std::basic_streambuf&lt; CHAR_TYPE, CHAR_TRAITS &gt; *buf, size_t n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::bslstl_string_fill </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_streambuf&lt; CHAR_TYPE, CHAR_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Do not use, for internal use by <code>operator&lt;&lt;</code> only. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga651fb2835be5936337f1ced5d2d23167">bsl::operator&lt;&lt;()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="gae4efd14b4282e2102bbee73841ae5f2f"></a><!-- doxytag: member="bsl::String_Imp::d_start_p" ref="gae4efd14b4282e2102bbee73841ae5f2f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CHAR_TYPE* <a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_start_p<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>pointer to the data on heap </p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#gac7e983fc7ad932e4b6d80bea7c2611f0">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::dataPtr()</a>, <a class="el" href="group__bslstl__string.html#gad45a4779242e1126b7c28f5c9f38ddc9">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::resetFields()</a>, and <a class="el" href="group__bslstl__string.html#gaa84e137b4df18defbd422bd14b7afb8e">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c1b296161780842e8f1ce16f1571c14"></a><!-- doxytag: member="bsl::String_Imp::@118::d_start_p" ref="ga3c1b296161780842e8f1ce16f1571c14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CHAR_TYPE* { ... } ::d_start_p<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>pointer to the data on heap </p>

</div>
</div>
<a class="anchor" id="gacbf4fcb16658c3fe67769b65f24dd7ad"></a><!-- doxytag: member="bsl::String_Imp::@119" ref="gacbf4fcb16658c3fe67769b65f24dd7ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union { ... } <code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the union of the string storage options: it can either be stored inside the short string buffer, <code>d_short</code>, or in the externally allocated memory, pointed to by <code>d_start_p</code>. </p>

</div>
</div>
<a class="anchor" id="ga442911ee00d50c7f0fccb6d0851e0804"></a><!-- doxytag: member="bsl::String_Imp::@118::d_short" ref="ga442911ee00d50c7f0fccb6d0851e0804" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BloombergLP::bsls::AlignedBuffer&lt; { ... } ::d_short<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>short string buffer </p>

</div>
</div>
<a class="anchor" id="ga1de95b9d967e4faedc6796cb6e05ae90"></a><!-- doxytag: member="bsl::String_Imp::d_length" ref="ga1de95b9d967e4faedc6796cb6e05ae90" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SIZE_TYPE <a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_length<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>length of the string </p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#gad45a4779242e1126b7c28f5c9f38ddc9">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::resetFields()</a>, and <a class="el" href="group__bslstl__string.html#gaa84e137b4df18defbd422bd14b7afb8e">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaae930e07f058fc30aa7bc8af3cf9f81"></a><!-- doxytag: member="bsl::String_Imp::d_capacity" ref="gaaae930e07f058fc30aa7bc8af3cf9f81" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename SIZE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SIZE_TYPE <a class="el" href="classbsl_1_1String__Imp.html">bsl::String_Imp</a>&lt; CHAR_TYPE, SIZE_TYPE &gt;::d_capacity<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>capacity to which the string can grow </p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga5e8fe3a4824803307fd12d99dbdb75aa">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::isShortString()</a>, <a class="el" href="group__bslstl__string.html#gad45a4779242e1126b7c28f5c9f38ddc9">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::resetFields()</a>, and <a class="el" href="group__bslstl__string.html#gaa84e137b4df18defbd422bd14b7afb8e">bsl::String_Imp&lt; CHAR_TYPE, SIZE_TYPE &gt;::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga700a29a04787c42a48ec3d0f1eea57ba"></a><!-- doxytag: member="bsl::basic_string::npos" ref="ga700a29a04787c42a48ec3d0f1eea57ba" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE, typename CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;, typename ALLOCATOR = allocator&lt;CHAR_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size_type <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::npos = ~size_type(0)<code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Value used to denote "not-a-position", guaranteed to be outside the range <code>[ 0, max_size() ]</code>. </p>

<p>Referenced by <a class="el" href="group__bslstl__string.html#ga9c2fb86b756802242f98cedc716073b1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, <a class="el" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::assign()</a>, <a class="el" href="group__bslstl__string.html#gaff7c4f8fad18f3b6527f658ad762d5fb">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find()</a>, <a class="el" href="group__bslstl__string.html#gacc2e62f92f7c65435d5cf5903faeeb7b">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_not_of()</a>, <a class="el" href="group__bslstl__string.html#gad3af44284b0c6c0fbcea8399bdd9bc30">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_first_of()</a>, <a class="el" href="group__bslstl__string.html#ga4aeabc89e32958ce595fdcafe86fdb69">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_not_of()</a>, <a class="el" href="group__bslstl__string.html#ga31cd337585f032f46838338fd54bfc2f">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::find_last_of()</a>, <a class="el" href="group__bslstl__string.html#gac412644d4308344b0081691ec48e8442">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::insert()</a>, <a class="el" href="group__bslstl__string.html#gaa730887a6af5ec76524fe2c74a5d8d46">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::operator=()</a>, <a class="el" href="group__bslstl__string.html#ga376e9ece84c406f66191bbfd073b2e79">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rfind()</a>, and <a class="el" href="group__bslstl__string.html#gaf8d5e8dde4a2ba49ab5975c2390370f2">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::~basic_string()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 9 2013 14:50:05 for BSL Release 2.19 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
