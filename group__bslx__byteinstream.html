<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.22.1.2 OSS: bslx_byteinstream Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslx_byteinstream<br/>
<small>
[<a class="el" href="group__bslx.html">Package bslx</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a stream class for unexternalization of fundamental types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslx.html">bslx</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Basic Unexternalization</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a stream class for unexternalization of fundamental types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a> </td><td>byte-array-based input stream for fundamental types  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslx__byteoutstream.html" title="Provide a stream class for externalization of fundamental types.">Component bslx_byteoutstream</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a byte-array-based input stream class that provides platform-independent input methods ("unexternalization") on values, and arrays of values, of fundamental types, and on <code>bsl::string</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component reads from a user-supplied buffer directly, with no data copying or assumption of ownership. The user must therefore make sure that the lifetime and visibility of the buffer is sufficient to satisfy the needs of the input stream. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is intended to be used in conjunction with the <code>bslx_byteoutstream</code> "externalization" component. Each input method of <code><a class="el" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a></code> reads either a value or a homogeneous array of values of a fundamental type, in a format that was written by the corresponding <code><a class="el" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a></code> method. In general, the user of this component cannot rely on being able to read data that was written by any mechanism other than <code><a class="el" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The supported types and required content are listed in the table below. All of the fundamental types in the table may be input as scalar values or as homogeneous arrays. <code>bsl::string</code> is input as an <code>int</code> representing the string's length and a homogeneous <code>char</code> array for the string's data. Note that <code>Int64</code> and <code>Uint64</code> denote <code><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a></code> and <code><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a></code>, which in turn are <code>typedef</code> names for the signed and unsigned 64-bit integer types, respectively, on the host platform. <br/>
<br/>
<div class="fragment"><pre class="fragment">      C++ TYPE          REQUIRED CONTENT OF ANY PLATFORM-NEUTRAL FORMAT
      --------          -----------------------------------------------
      Int64             least significant 64 bits (<span class="keywordtype">signed</span>)
      Uint64            least significant 64 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">int</span>               least significant 32 bits (<span class="keywordtype">signed</span>)
      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      least significant 32 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">short</span>             least significant 16 bits (<span class="keywordtype">signed</span>)
      <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>    least significant 16 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">char</span>              least significant  8 bits (platform-dependent)
      <span class="keywordtype">signed</span> <span class="keywordtype">char</span>       least significant  8 bits (<span class="keywordtype">signed</span>)
      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>     least significant  8 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">double</span>            IEEE standard 8-byte floating-point value
      <span class="keywordtype">float</span>             IEEE standard 4-byte floating-point value

      bsl::<span class="keywordtype">string</span>       BDE implementation of the STL <span class="keywordtype">string</span> class
</pre></div><br/>
<br/>
 This component also supports compact streaming in of integer types. In particular, 64-bit values can be streamed in from 40-, 48-, 56-, or 64-bit values, and 32-bit values can be streamed in from 24- or 32-bit values (consistent with what has been written to the stream, of course). Note that, for signed types, the sign is preserved for all streamed-in values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that input streams can be <em>invalidated</em> explicitly and queried for <em>validity</em> and <em>emptiness</em>. Reading from an initially invalid stream has no effect. Attempting to read beyond the end of a stream will automatically invalidate the stream. Whenever an inconsistent value is detected, the stream should be invalidated explicitly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_unexternalization"></a> <a class="anchor" id="usage.example_1~3A_basic_unexternalization"></a> <a class="anchor" id="description.usage.example_1~3A_basic_unexternalization"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Unexternalization: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wish to implement a (deliberately simple) <code>MyPerson</code> class as a value-semantic object that supports BDEX externalization and unexternalization. In addition to whatever data and methods that we choose to put into our design, we must supply three methods having specific names and signatures in order to comply with the BDEX protocol: a class method <code>maxSupportedBdexVersion</code>, an accessor (i.e., a <code>const</code> method) <code>bdexStreamOut</code>, and a manipulator (i.e., a non-'const' method) <code>bdexStreamIn</code>. This example shows how to implement those three methods. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we will not worry overly about "good design" of the <code>MyPerson</code> component, and we will declare but not implement illustrative methods and free operators, except for the three required BDEX methods, which are implemented in full. In particular, we will not make explicit use of <code>bslma</code> allocators; a more complete design would do so: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we implement <code>MyPerson</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyPerson {
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_firstName;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_lastName;
      <span class="keywordtype">int</span>         d_age;

      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebdldfp.html#ae38909e0885ad40b01e80afb221e6737">operator==</a>(<span class="keyword">const</span> MyPerson&amp;, <span class="keyword">const</span> MyPerson&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespacebslx_1_1VersionFunctions__Impl.html#a0f83193663d2532a7032ccdac6fa3c28">maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> serializationVersion);
          <span class="comment">// Return the &#39;version&#39; to be used with the &#39;bdexStreamOut&#39; method</span>
          <span class="comment">// corresponding to the specified &#39;serializationVersion&#39;.  See the</span>
          <span class="comment">// &#39;bslx&#39; package-level documentation for more information on BDEX</span>
          <span class="comment">// streaming of value-semantic types and containers.</span>

      <span class="comment">// CREATORS</span>
      MyPerson();
          <span class="comment">// Create a default person.</span>

      MyPerson(<span class="keyword">const</span> <span class="keywordtype">char</span> *firstName, <span class="keyword">const</span> <span class="keywordtype">char</span> *lastName, <span class="keywordtype">int</span> age);
          <span class="comment">// Create a person having the specified &#39;firstName&#39;, &#39;lastName&#39;,</span>
          <span class="comment">// and &#39;age&#39;.</span>

      MyPerson(<span class="keyword">const</span> MyPerson&amp; original);
          <span class="comment">// Create a person having the value of the specified &#39;original&#39;</span>
          <span class="comment">// person.</span>

      ~MyPerson();
          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      MyPerson&amp; operator=(<span class="keyword">const</span> MyPerson&amp; rhs);
          <span class="comment">// Assign to this person the value of the specified &#39;rhs&#39; person,</span>
          <span class="comment">// and return a reference to this person.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebslx_1_1InStreamFunctions.html#a51ef35d627d850a81a33c3106cbf1b52">bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version);
          <span class="comment">// Assign to this object the value read from the specified input</span>
          <span class="comment">// &#39;stream&#39; using the specified &#39;version&#39; format, and return a</span>
          <span class="comment">// reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this</span>
          <span class="comment">// operation has no effect.  If &#39;version&#39; is not supported, this</span>
          <span class="comment">// object is unaltered and &#39;stream&#39; is invalidated but otherwise</span>
          <span class="comment">// unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes</span>
          <span class="comment">// invalid during this operation, this object has an undefined, but</span>
          <span class="comment">// valid, state.  Note that no version is read from &#39;stream&#39;.  See</span>
          <span class="comment">// the &#39;bslx&#39; package-level documentation for more information on</span>
          <span class="comment">// BDEX streaming of value-semantic types and containers.</span>

      <span class="comment">//...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; firstName() <span class="keyword">const</span>;
          <span class="comment">// Return the first name of this person.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; lastName() <span class="keyword">const</span>;
          <span class="comment">// Return the last name of this person.</span>

      <span class="keywordtype">int</span> age() <span class="keyword">const</span>;
          <span class="comment">// Return the age of this person.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebslx_1_1OutStreamFunctions.html#a74f1889766c3cbd4427fd8370e4e734a">bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version) <span class="keyword">const</span>;
          <span class="comment">// Write this value to the specified output &#39;stream&#39; using the</span>
          <span class="comment">// specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.</span>
          <span class="comment">// If &#39;stream&#39; is initially invalid, this operation has no effect.</span>
          <span class="comment">// If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but</span>
          <span class="comment">// otherwise unmodified.  Note that &#39;version&#39; is not written to</span>
          <span class="comment">// &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more</span>
          <span class="comment">// information on BDEX streaming of value-semantic types and</span>
          <span class="comment">// containers.</span>

      <span class="comment">//...</span>

  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebdldfp.html#ae38909e0885ad40b01e80afb221e6737">operator==</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two person objects have the</span>
      <span class="comment">// same value if they have the same first name, last name, and age.</span>

  <span class="keywordtype">bool</span> <a class="code" href="namespacebdldfp.html#a3be038ba34aba97e5c03f884da729377">operator!=</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects do not</span>
      <span class="comment">// have the same value, and &#39;false&#39; otherwise.  Two person objects</span>
      <span class="comment">// differ in value if they differ in first name, last name, or age.</span>

  bsl::ostream&amp; <a class="code" href="namespacebdldfp.html#a1d862754e6d8787eb6849b24bfe6eb6e">operator&lt;&lt;</a>(bsl::ostream&amp; stream, <span class="keyword">const</span> MyPerson&amp; person);
      <span class="comment">// Write the specified &#39;person&#39; value to the specified output &#39;stream&#39;</span>
      <span class="comment">// in some reasonable format, and return a reference to &#39;stream&#39;.</span>

  <span class="comment">// ========================================================================</span>
  <span class="comment">//                  INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

  <span class="comment">// CLASS METHODS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> <a class="code" href="namespacebslx_1_1VersionFunctions__Impl.html#a0f83193663d2532a7032ccdac6fa3c28">MyPerson::maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> <span class="comment">/* serializationVersion */</span>) {
      <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyPerson::MyPerson()
  : d_firstName(<span class="stringliteral">&quot;&quot;</span>)
  , d_lastName(<span class="stringliteral">&quot;&quot;</span>)
  , d_age(0)
  {
  }

  <span class="keyword">inline</span>
  MyPerson::MyPerson(<span class="keyword">const</span> <span class="keywordtype">char</span> *firstName, <span class="keyword">const</span> <span class="keywordtype">char</span> *lastName, <span class="keywordtype">int</span> age)
  : d_firstName(firstName)
  , d_lastName(lastName)
  , d_age(age)
  {
  }

  <span class="keyword">inline</span>
  MyPerson::~MyPerson()
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebslx_1_1InStreamFunctions.html#a51ef35d627d850a81a33c3106cbf1b52">MyPerson::bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)
  {
      <span class="keywordflow">if</span> (stream) {
          <span class="keywordflow">switch</span> (version) {  <span class="comment">// switch on the &#39;bslx&#39; version</span>
            <span class="keywordflow">case</span> 1: {
              stream.getString(d_firstName);
              <span class="keywordflow">if</span> (!stream) {
                  d_firstName = <span class="stringliteral">&quot;stream error&quot;</span>;  <span class="comment">// *might* be corrupted;</span>
                                                 <span class="comment">//  value for testing</span>
                  <span class="keywordflow">return</span> stream;
              }
              stream.getString(d_lastName);
              <span class="keywordflow">if</span> (!stream) {
                  d_lastName = <span class="stringliteral">&quot;stream error&quot;</span>;  <span class="comment">// *might* be corrupted;</span>
                                                <span class="comment">//  value for testing</span>
                  <span class="keywordflow">return</span> stream;
              }
              stream.getInt32(d_age);
              <span class="keywordflow">if</span> (!stream) {
                  d_age = 999;     <span class="comment">// *might* be corrupted; value for testing</span>
                  <span class="keywordflow">return</span> stream;
              }
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">default</span>: {
              stream.invalidate();
            }
          }
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebslx_1_1OutStreamFunctions.html#a74f1889766c3cbd4427fd8370e4e734a">MyPerson::bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          stream.putString(d_firstName);
          stream.putString(d_lastName);
          stream.putInt32(d_age);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 Then, we can exercise the new <code>MyPerson</code> value-semantic class by externalizing and reconstituting an object. First, create a <code>MyPerson</code> <code>janeSmith</code> and a <code><a class="el" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a></code> <code>outStream</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson janeSmith(<span class="stringliteral">&quot;Jane&quot;</span>, <span class="stringliteral">&quot;Smith&quot;</span>, 42);
  <a class="code" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a> outStream(20131127);
  <span class="keyword">const</span> <span class="keywordtype">int</span> VERSION = 1;
  outStream.putVersion(VERSION);
  janeSmith.bdexStreamOut(outStream, VERSION);
  assert(outStream.isValid());
</pre></div><br/>
<br/>
 Next, create a <code>MyPerson</code> <code>janeCopy</code> initialized to the default value, and assert that <code>janeCopy</code> is different from <code>janeSmith</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson janeCopy;
  assert(janeCopy != janeSmith);
</pre></div><br/>
<br/>
 Then, create a <code><a class="el" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a></code> <code>inStream</code> initialized with the buffer from the <code><a class="el" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a></code> object <code>outStream</code> and unexternalize this data into <code>janeCopy</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a> inStream(outStream.data(), outStream.length());
  <span class="keywordtype">int</span> version;
  inStream.getVersion(version);
  janeCopy.bdexStreamIn(inStream, version);
  assert(inStream.isValid());
</pre></div><br/>
<br/>
 Finally, <code>assert</code> the obtained values are as expected and display the results to <code>bsl::stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(version  == VERSION);
  assert(janeCopy == janeSmith);

  <span class="keywordflow">if</span> (janeCopy == janeSmith) {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Successfully serialized and de-serialized Jane Smith:&quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;\n\tFirstName: &quot;</span> &lt;&lt; janeCopy.firstName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tLastName : &quot;</span> &lt;&lt; janeCopy.lastName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tAge      : &quot;</span> &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
  }
  <span class="keywordflow">else</span> {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Serialization unsuccessful.  &#39;janeCopy&#39; holds:&quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;\n\tFirstName: &quot;</span> &lt;&lt; janeCopy.firstName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tLastName : &quot;</span> &lt;&lt; janeCopy.lastName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tAge      : &quot;</span> &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 3 2014 19:27:31 for BDE Release 2.22.1.2 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
