<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.22.1.2 OSS: bslx_testinstream Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<h1>Component bslx_testinstream<br/>
<small>
[<a class="el" href="group__bslx.html">Package bslx</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Enable unexternalization of fundamental types with identification.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslx.html">bslx</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslx__testinstream.html#ga6e4e620b6fdc3c442776032fe961bc86">BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN</a>(testInStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslx__testinstream.html#ga3aaf620a84c8adb8b9a7ab81a2b37bb6">BSLX_TESTINSTREAM_EXCEPTION_TEST_END</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Input Limit</a> </li>
<li>
<a href="#4.2">Exception Test Macros</a> </li>
<li>
<a href="#4.3">Usage</a> <ul>
<li>
<a href="#4.3.1">Example 1: Basic Unexternalization Test</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Enable unexternalization of fundamental types with identification. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a> </td><td>byte-array-based input stream class  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN </td><td>macro to begin testing exceptions  </td></tr>
<tr>
<td>BSLX_TESTINSTREAM_EXCEPTION_TEST_END </td><td>macro to end testing exceptions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslx__testoutstream.html" title="Enable externalization of fundamental types with identification.">Component bslx_testoutstream</a>, <a class="el" href="group__bslx__byteinstream.html" title="Provide a stream class for unexternalization of fundamental types.">Component bslx_byteinstream</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a byte-array-based input stream class that provides platform-independent input methods ("unexternalization") on values, and arrays of values, of fundamental types, and on <code>bsl::string</code>. This component also verifies, for these types, that the type of data requested from the stream matches what was written to the stream. This component is meant for testing only. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component reads from a user-supplied buffer directly, with no data copying or assumption of ownership. The user must therefore make sure that the lifetime and visibility of the buffer is sufficient to satisfy the needs of the input stream. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is intended to be used in conjunction with the <code>bslx_testoutstream</code> externalization component. Each input method of <code><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a></code> reads either a value or a homogeneous array of values of a fundamental type, in a format that was written by the corresponding <code><a class="el" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a></code> method. In general, the user of this component cannot rely on being able to read data that was written by any mechanism other than <code><a class="el" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The supported types and required content are listed in the table below. All of the fundamental types in the table may be input as scalar values or as homogeneous arrays. <code>bsl::string</code> is input as an <code>int</code> representing the string's length and a homogeneous <code>char</code> array for the string's data. Note that <code>Int64</code> and <code>Uint64</code> denote <code><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a></code> and <code><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a></code>, which in turn are <code>typedef</code> names for the signed and unsigned 64-bit integer types, respectively, on the host platform: <br/>
<br/>
<div class="fragment"><pre class="fragment">      C++ TYPE          REQUIRED CONTENT OF ANY PLATFORM-NEUTRAL FORMAT
      --------          -----------------------------------------------
      Int64             least significant 64 bits (<span class="keywordtype">signed</span>)
      Uint64            least significant 64 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">int</span>               least significant 32 bits (<span class="keywordtype">signed</span>)
      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      least significant 32 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">short</span>             least significant 16 bits (<span class="keywordtype">signed</span>)
      <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>    least significant 16 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">char</span>              least significant  8 bits (platform-dependent)
      <span class="keywordtype">signed</span> <span class="keywordtype">char</span>       least significant  8 bits (<span class="keywordtype">signed</span>)
      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>     least significant  8 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">double</span>            IEEE standard 8-byte floating-point value
      <span class="keywordtype">float</span>             IEEE standard 4-byte floating-point value

      bsl::<span class="keywordtype">string</span>       BDE implementation of the STL <span class="keywordtype">string</span> class
</pre></div><br/>
<br/>
 This component also supports compact streaming in of integer types. In particular, 64-bit values can be streamed in from 40-, 48-, 56-, or 64-bit values, and 32-bit values can be streamed in from 24- or 32-bit values (consistent with what has been written to the stream, of course). Note that, for signed types, the sign is preserved for all streamed-in values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that input streams can be <em>invalidated</em> explicitly and queried for <em>validity</em> and <em>emptiness</em>. Reading from an initially invalid stream has no effect. Attempting to read beyond the end of a stream will automatically invalidate the stream. Whenever an inconsistent value is detected, the stream should be invalidated explicitly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="input_limit"></a> <a class="anchor" id="description.input_limit"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Input Limit: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If exceptions are enabled at compile time, the test input stream can be configured to throw an exception after a specified number of input requests is exceeded. If the input limit is less than zero (default), then the stream never throws an exception. Note that a non-negative input limit is decremented after each input attempt, and throws only when the current input limit transitions from 0 to -1; no additional exceptions will be thrown until the input limit is again reset to a non-negative value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The input limit is set using the <code>setInputLimit</code> manipulator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="exception_test_macros"></a> <a class="anchor" id="description.exception_test_macros"></a> <a class="anchor" id="4.2"></a> </dd></dl>
<dl class="user"><dt><b>Exception Test Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also provides a pair of macros: <br/>
<br/>
<div class="fragment"><pre class="fragment"> &lt;ul&gt;
 &lt;li&gt;
 <a class="code" href="group__bslx__testinstream.html#ga6e4e620b6fdc3c442776032fe961bc86">BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN</a>(testInStream)
 &lt;/li&gt;
 &lt;li&gt;
 <a class="code" href="group__bslx__testinstream.html#ga3aaf620a84c8adb8b9a7ab81a2b37bb6">BSLX_TESTINSTREAM_EXCEPTION_TEST_END</a>
 &lt;/li&gt;
 &lt;/ul&gt;
</pre></div><br/>
<br/>
 These macros can be used for testing exception-safety of classes and their methods when BDEX streaming is involved. A reference to an object of type <code><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a></code> must be supplied as an argument to the <code>*_BEGIN</code> macro. Note that if exception-handling is disabled (i.e., if <code>-DBDE_BUILD_TARGET_EXC</code> was <em>not</em> supplied at compile time), then the macros simply print the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  BSLX EXCEPTION TEST -- (NOT ENABLED) --
</pre></div><br/>
<br/>
 When exception-handling is enabled (i.e., if <code>-DBDE_BUILD_TARGET_EXC</code> was supplied at compile time), the <code>*_BEGIN</code> macro will set the input limit of the supplied instream to 0, <code>try</code> the code being tested, <code>catch</code> any <code>TestInstreamException</code>s that are thrown, and keep increasing the input limit until the code being tested completes successfully. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_unexternalization_test"></a> <a class="anchor" id="usage.example_1~3A_basic_unexternalization_test"></a> <a class="anchor" id="description.usage.example_1~3A_basic_unexternalization_test"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="4.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Unexternalization Test: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wish to implement a (deliberately simple) <code>MyPerson</code> class as a value-semantic object that supports BDEX externalization and unexternalization. In addition to whatever data and methods that we choose to put into our design, we must supply three methods having specific names and signatures in order to comply with the BDEX protocol: a class method <code>maxSupportedBdexVersion</code>, an accessor (i.e., a <code>const</code> method) <code>bdexStreamOut</code>, and a manipulator (i.e., a non-'const' method) <code>bdexStreamIn</code>. This example shows how to implement those three methods. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we will not worry overly about "good design" of the <code>MyPerson</code> component, and we will declare but not implement illustrative methods and free operators, except for the three required BDEX methods, which are implemented in full. In particular, we will not make explicit use of <code>bslma</code> allocators; a more complete design would do so: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we implement <code>MyPerson</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyPerson {
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_firstName;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_lastName;
      <span class="keywordtype">int</span>         d_age;

      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebdldfp.html#ae38909e0885ad40b01e80afb221e6737">operator==</a>(<span class="keyword">const</span> MyPerson&amp;, <span class="keyword">const</span> MyPerson&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespacebslx_1_1VersionFunctions__Impl.html#a0f83193663d2532a7032ccdac6fa3c28">maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> serializationVersion);
          <span class="comment">// Return the &#39;version&#39; to be used with the &#39;bdexStreamOut&#39; method</span>
          <span class="comment">// corresponding to the specified &#39;serializationVersion&#39;.  See the</span>
          <span class="comment">// &#39;bslx&#39; package-level documentation for more information on BDEX</span>
          <span class="comment">// streaming of value-semantic types and containers.</span>

      <span class="comment">// CREATORS</span>
      MyPerson();
          <span class="comment">// Create a default person.</span>

      MyPerson(<span class="keyword">const</span> <span class="keywordtype">char</span> *firstName, <span class="keyword">const</span> <span class="keywordtype">char</span> *lastName, <span class="keywordtype">int</span> age);
          <span class="comment">// Create a person having the specified &#39;firstName&#39;, &#39;lastName&#39;,</span>
          <span class="comment">// and &#39;age&#39;.</span>

      MyPerson(<span class="keyword">const</span> MyPerson&amp; original);
          <span class="comment">// Create a person having the value of the specified &#39;original&#39;</span>
          <span class="comment">// person.</span>

      ~MyPerson();
          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      MyPerson&amp; operator=(<span class="keyword">const</span> MyPerson&amp; rhs);
          <span class="comment">// Assign to this person the value of the specified &#39;rhs&#39; person,</span>
          <span class="comment">// and return a reference to this person.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebslx_1_1InStreamFunctions.html#a51ef35d627d850a81a33c3106cbf1b52">bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version);
          <span class="comment">// Assign to this object the value read from the specified input</span>
          <span class="comment">// &#39;stream&#39; using the specified &#39;version&#39; format, and return a</span>
          <span class="comment">// reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this</span>
          <span class="comment">// operation has no effect.  If &#39;version&#39; is not supported, this</span>
          <span class="comment">// object is unaltered and &#39;stream&#39; is invalidated but otherwise</span>
          <span class="comment">// unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes</span>
          <span class="comment">// invalid during this operation, this object has an undefined, but</span>
          <span class="comment">// valid, state.  Note that no version is read from &#39;stream&#39;.  See</span>
          <span class="comment">// the &#39;bslx&#39; package-level documentation for more information on</span>
          <span class="comment">// BDEX streaming of value-semantic types and containers.</span>

      <span class="comment">//...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; firstName() <span class="keyword">const</span>;
          <span class="comment">// Return the first name of this person.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; lastName() <span class="keyword">const</span>;
          <span class="comment">// Return the last name of this person.</span>

      <span class="keywordtype">int</span> age() <span class="keyword">const</span>;
          <span class="comment">// Return the age of this person.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebslx_1_1OutStreamFunctions.html#a74f1889766c3cbd4427fd8370e4e734a">bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version) <span class="keyword">const</span>;
          <span class="comment">// Write this value to the specified output &#39;stream&#39; using the</span>
          <span class="comment">// specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.</span>
          <span class="comment">// If &#39;stream&#39; is initially invalid, this operation has no effect.</span>
          <span class="comment">// If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but</span>
          <span class="comment">// otherwise unmodified.  Note that &#39;version&#39; is not written to</span>
          <span class="comment">// &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more</span>
          <span class="comment">// information on BDEX streaming of value-semantic types and</span>
          <span class="comment">// containers.</span>

      <span class="comment">//...</span>

  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebdldfp.html#ae38909e0885ad40b01e80afb221e6737">operator==</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two person objects have the</span>
      <span class="comment">// same value if they have the same first name, last name, and age.</span>

  <span class="keywordtype">bool</span> <a class="code" href="namespacebdldfp.html#a3be038ba34aba97e5c03f884da729377">operator!=</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects do not</span>
      <span class="comment">// have the same value, and &#39;false&#39; otherwise.  Two person objects</span>
      <span class="comment">// differ in value if they differ in first name, last name, or age.</span>

  bsl::ostream&amp; <a class="code" href="namespacebdldfp.html#a1d862754e6d8787eb6849b24bfe6eb6e">operator&lt;&lt;</a>(bsl::ostream&amp; stream, <span class="keyword">const</span> MyPerson&amp; person);
      <span class="comment">// Write the specified &#39;person&#39; value to the specified output &#39;stream&#39;</span>
      <span class="comment">// in some reasonable format, and return a reference to &#39;stream&#39;.</span>

  <span class="comment">// ========================================================================</span>
  <span class="comment">//                  INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

  <span class="comment">// CLASS METHODS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> <a class="code" href="namespacebslx_1_1VersionFunctions__Impl.html#a0f83193663d2532a7032ccdac6fa3c28">MyPerson::maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> <span class="comment">/* serializationVersion */</span>) {
      <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyPerson::MyPerson()
  : d_firstName(<span class="stringliteral">&quot;&quot;</span>)
  , d_lastName(<span class="stringliteral">&quot;&quot;</span>)
  , d_age(0)
  {
  }

  <span class="keyword">inline</span>
  MyPerson::MyPerson(<span class="keyword">const</span> <span class="keywordtype">char</span> *firstName, <span class="keyword">const</span> <span class="keywordtype">char</span> *lastName, <span class="keywordtype">int</span> age)
  : d_firstName(firstName)
  , d_lastName(lastName)
  , d_age(age)
  {
  }

  <span class="keyword">inline</span>
  MyPerson::~MyPerson()
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebslx_1_1InStreamFunctions.html#a51ef35d627d850a81a33c3106cbf1b52">MyPerson::bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)
  {
      <span class="keywordflow">if</span> (stream) {
          <span class="keywordflow">switch</span> (version) {  <span class="comment">// switch on the &#39;bslx&#39; version</span>
            <span class="keywordflow">case</span> 1: {
              stream.getString(d_firstName);
              <span class="keywordflow">if</span> (!stream) {
                  d_firstName = <span class="stringliteral">&quot;stream error&quot;</span>;  <span class="comment">// *might* be corrupted;</span>
                                                 <span class="comment">//  value for testing</span>
                  <span class="keywordflow">return</span> stream;
              }
              stream.getString(d_lastName);
              <span class="keywordflow">if</span> (!stream) {
                  d_lastName = <span class="stringliteral">&quot;stream error&quot;</span>;  <span class="comment">// *might* be corrupted;</span>
                                                <span class="comment">//  value for testing</span>
                  <span class="keywordflow">return</span> stream;
              }
              stream.getInt32(d_age);
              <span class="keywordflow">if</span> (!stream) {
                  d_age = 999;     <span class="comment">// *might* be corrupted; value for testing</span>
                  <span class="keywordflow">return</span> stream;
              }
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">default</span>: {
              stream.invalidate();
            }
          }
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebslx_1_1OutStreamFunctions.html#a74f1889766c3cbd4427fd8370e4e734a">MyPerson::bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          stream.putString(d_firstName);
          stream.putString(d_lastName);
          stream.putInt32(d_age);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 Then, we can exercise the new <code>MyPerson</code> value-semantic class by externalizing and reconstituting an object. First, create a <code>MyPerson</code> <code>janeSmith</code> and a <code><a class="el" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a></code> <code>outStream</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson janeSmith(<span class="stringliteral">&quot;Jane&quot;</span>, <span class="stringliteral">&quot;Smith&quot;</span>, 42);
  <a class="code" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a> outStream(20131127);
  <span class="keyword">const</span> <span class="keywordtype">int</span> VERSION = 1;
  outStream.putVersion(VERSION);
  janeSmith.bdexStreamOut(outStream, VERSION);
  assert(outStream.isValid());
</pre></div><br/>
<br/>
 Next, create a <code>MyPerson</code> <code>janeCopy</code> initialized to the default value, and assert that <code>janeCopy</code> is different from <code>janeSmith</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson janeCopy;
  assert(janeCopy != janeSmith);
</pre></div><br/>
<br/>
 Then, create a <code><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a></code> <code>inStream</code> initialized with the buffer from the <code><a class="el" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a></code> object <code>outStream</code> and unexternalize this data into <code>janeCopy</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a> inStream(outStream.data(), outStream.length());
  <span class="keywordtype">int</span> version;
  inStream.getVersion(version);
  janeCopy.bdexStreamIn(inStream, version);
  assert(inStream.isValid());
</pre></div><br/>
<br/>
 Finally, <code>assert</code> the obtained values are as expected and display the results to <code>bsl::stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(version  == VERSION);
  assert(janeCopy == janeSmith);

  <span class="keywordflow">if</span> (janeCopy == janeSmith) {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Successfully serialized and de-serialized Jane Smith:&quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;\n\tFirstName: &quot;</span> &lt;&lt; janeCopy.firstName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tLastName : &quot;</span> &lt;&lt; janeCopy.lastName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tAge      : &quot;</span> &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
  }
  <span class="keywordflow">else</span> {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Serialization unsuccessful.  &#39;janeCopy&#39; holds:&quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;\n\tFirstName: &quot;</span> &lt;&lt; janeCopy.firstName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tLastName : &quot;</span> &lt;&lt; janeCopy.lastName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tAge      : &quot;</span> &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga6e4e620b6fdc3c442776032fe961bc86"></a><!-- doxytag: member="bslx_testinstream.h::BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN" ref="ga6e4e620b6fdc3c442776032fe961bc86" args="(testInStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">testInStream</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                                             \
    <span class="keyword">static</span> <span class="keywordtype">int</span> firstTime = 1;                                                 \
    <span class="keywordflow">if</span> (verbose &amp;&amp; firstTime) {                                               \
        bsl::cout &lt;&lt; <span class="stringliteral">&quot;### BSLX EXCEPTION TEST -- (NOT ENABLED) --&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;   \
        firstTime = 0;                                                        \
    }                                                                         \
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga3aaf620a84c8adb8b9a7ab81a2b37bb6"></a><!-- doxytag: member="bslx_testinstream.h::BSLX_TESTINSTREAM_EXCEPTION_TEST_END" ref="ga3aaf620a84c8adb8b9a7ab81a2b37bb6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLX_TESTINSTREAM_EXCEPTION_TEST_END</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 3 2014 19:27:31 for BDE Release 2.22.1.2 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
