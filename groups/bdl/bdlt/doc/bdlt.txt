 bdlt.txt

@PURPOSE: Provide date and time vocabulary types, and related utilities.

@MNEMONIC: Basic Development Library Time (bdlt)

@AUTHOR: Steven Breitstein (sbreitstein)

@DESCRIPTION: The 'bdlt' ("Basic Development Library Time") package provides
 vocabulary types for representing date, time, and datetime values, related
 value-types that are augmented with a timezone offset, and utilities providing
 non-primitive functionality on the value types.

 Additional utilities provide:
: o Current date, time, and local time offset values.
: o Conversion between different date and time representations.
: o Arithmetic and validation functions

 See {Value Types} and {Utilities} below.

/Hierarchical Synopsis
/---------------------
 The 'bdlt' package currently has 18 components having 7 levels of physical
 dependency.  The list below shows the hierarchical ordering of the components.
 The order of components within each level is not architecturally significant,
 just alphabetical.
..
  7. bdlt_currenttime

  6. bdlt_datetimetz
     bdlt_localtimeoffset

  5. bdlt_datetimeutil
     bdlt_datetz
     bdlt_epochutil

  4. bdlt_datetime
     bdlt_timetz

  3. bdlt_dateutil
     bdlt_intervalconversionutil
     bdlt_time

  2. bdlt_date
     bdlt_datetimeinterval
     bdlt_dayofweekset

  1. bdlt_dayofweek
     bdlt_monthofyear
     bdlt_serialdateimputil
     bdlt_timeunitratio
..

/Component Synopsis
/------------------
: 'bdlt_currenttime':
:      Provide utilities to retrieve the current time.
:
: 'bdlt_date':
:      Provide a value-semantic type to represent dates.
:
: 'bdlt_datetime':
:      Provide a value-semantic type representing both date and time.
:
: 'bdlt_datetimeinterval':
:      Provide a representation of an interval of time.
:
: 'bdlt_datetimetz':
:      Provide a representation of a date and time with time zone offset.
:
: 'bdlt_datetimeutil':
:      Provide common non-primitive operations on 'bdlt::Datetime'.
:
: 'bdlt_datetz':
:      Provide a representation of a date with time zone offset.
:
: 'bdlt_dateutil':
:      Provide common non-primitive operations on date objects.
:
: 'bdlt_dayofweek':
:      Provide an enumeration of the set of days of the week.
:
: 'bdlt_dayofweekset':
:      Provide an ordered set of (unique) 'bdlt::DayOfWeek::Enum' values.
:
: 'bdlt_epochutil':
:      Conversion between absolute/relative time with respect to epoch.
:
: 'bdlt_intervalconversionutil':
:      Provide functions to convert between time-interval representations.
:
: 'bdlt_localtimeoffset':
:      Provide utilities to retrieve the local time offset.
:
: 'bdlt_monthofyear':
:      Enumerate the set of month-of-year values.
:
: 'bdlt_serialdateimputil':
:      Provide low-level support functions for date-value manipulation.
:
: 'bdlt_time':
:      Provide a value-semantic time-of-day type (millisecond resolution).
:
: 'bdlt_timetz':
:      Provide a representation of a time with time zone offset.
:
: 'bdlt_timeunitratio':
:      Provide constants characterizing ratios between common time units.

/Value Types
/-----------

/Value Types: 'Date', 'Time' and 'Datetime'
/ - - - - - - - - - - - - - - - - - - - - -
 The 'bdlt' package defines 'bdlt::Date' to represent date values, 'bdlt::Time'
 to represent time values (to millisecond resolution) within a day, and the
 combined 'bdlt::Datetime', to represent all points in time (to millisecond
 resolution) across the range of date values.  The ranges of each type are
 shown below.
..
  Type     Range
  -------  ------------------------------------------------------
  Date     [0001/01/01              ..  9999/12/31              ]
  Time     [           00:00:00.000 ..             23:59:59.999 ]
  Datetime [0001/01/01_00:00:00.000 ..  9999/12/31_23:59:59.999 ]
..
 Further note that:
: o The date values follow the proleptic Gregorian calendar.
: o The definition of 'bdlt::Datetime' does *not* allow for leap seconds.

 The above classes define values representing points in time (e.g., dates of an
 epoch, time-of-day).  Alternatively, the 'bdlt::Datetime' class is used to
 represent the difference (to millisecond resolution) between arbitrary points
 in time.
..
  Type             Difference Type
  -------          ----------------
  Date             int (days)
  Time             DatetimeInterval
  Datetime         DatetimeInterval
  DatetimeInterval DatetimeInterval
..
 Each of these classes are designed to hold date and time values, but do not
 themselves provide means for defining values such as current time and date.
 Those values are available via separate utility components.  See {Obtaining
 Date, Time, and Local Time Offset Values}.

/Singular 'Time' and 'Datetime' Values
/-  -  -  -  -  -  -  -  -  -  -  -  -
 The 'bdlt::Time' class defines a singular value, "24:00:00.000", which is also
 the default constructed value.  This singular value is distinguished in two
 ways:

: o Relational comparisons to other time values are disallowed -- the behavior
:   is undefined.  Note that comparisons of equality and inequality to other
:   values *are* legal.
:
:   o Note that the singular value cannot appear as a key value in any of the
:     standard ordered containers (which require weak ordering of keys).
:
: o The singular value is implicitly converted to "00:00:00.000" (midnight) in
:   arithmetic operations using 'bdlt::Time' values.

 Similarly, the 'bdlt::Datetime' class defines one distinguished value,
 "0001/01/01_24:00:00.000", which happens to be the default constructed value.
 The restrictions and semantics of this value parallel those of the
 'bdtl::Time' distinguished values.

 Some applications use the distinguished values of these types as placeholders
 when a value must be provided but is not known (e.g., a 'NULL' value in a
 database).

/Timezone Augmented Value Types: 'DateTz', 'TimeTz' and 'DatetimeTz'
/- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 Each of the basic date and time types has a corresponding type that is
 augmented with a value representing a time offset (in minutes) from UTC.
 (Note that other BDE types represent time offset values in terms of seconds
 of 'bsls::TimeInterval's.)

 The timezone augmented types are:
..
  Basis Type    Timezone Augmented Type
  ----------    -----------------------
  bldt:Date     bdlt::DateTz
  bldt:Time     bdlt::TimeTz
  bldt:Datetime bdlt::DatetimeTz
..
 Equality between objects of any of these types requires that the object have
 both the same local value and the same offset value.  Additionally the objects
 can be compared for equivalence by comparing the values provided by their
 'utc*' accessor method.

 These types themselves have no facilities for validating that the dates,
 times, and offsets they hold correspond to any actual, geographic timezone.
 See {Obtaining Current Date, Time, and Local Time Offset}.

/Enumerated Values
/- - - - - - - - -
 The 'bdlt' package provides enumerations in 'bdlt_monthofyear' and
 'bdlt_dayofweek'.  The 'bdlt_dayofweekset' provides an efficient, ordered
 container of unique 'bdtl::DayofWeek::Enum' values (i.e., containing no more
 than seven elements).

/Utilities
/---------

/Obtaining Current Date, Time, and Local Time Offset
/- - - - - - - - - - - - - - - - - - - - - - - - - -
 The 'bdlt_currenttime' component provides:

: o A 'bsls::Datetime' value for the current UTC time.
: o A 'bsls::Datetime' value for the current local time.
: o A 'bsls::TimeInterval' from the start of the epoch.

 The 'bdlt_localtimeoffset' component provides:

: o A 'bsls::TimeInterval' value for the local time offset at the specified UTC
:   'bdlt::Datetime' value.

 The local time offset corresponds to the time zone set of the host machine (as
 set by the system administrator).  For local time offset values for arbitrary
 time zones see the {'baetzo'} package.

 Both 'bdlt::CurrentTime' and 'bdlt::LocalTimeOffset' obtain their values via
 use-definable callback functions.  The default callbacks obtain their values
 from platform appropriate system calls.  User-defined callbacks can be use to
 provide high-performance (e.g., caching) alternatives to the default system
 calls, for gathering statistics, and for simulating the passage of time in
 test scenarios.

/Advanced Date Arithmetic
/ - - - - - - - - - - - -
 The 'bdet_dateutil' provides calculations using 'bdlt::Date' objects that
 enhance those provided by the 'bdlt::Date' class:

: o Calculate the 'bdlt::Date' that is a specified number of months -- or years
:   -- before or after a given date.  Two different end-of-month conventions
:   are available.
:
: o Find the next -- or previous -- day of a specified 'bdlt::DayOfWeek::Enum'
:   relative to a specified date (inclusive or exclusive of that specified
:   date).
:
: o Find the date of a specified 'bdlt::DayOfWeek::Enum' that is the *nth*
:   (e.g., 1st, 3rd) or last of a specified year and month.

 Note that 'bdlt::Dateutil' also provides conversion of 'bdlt::Date' values to
 and from 'int' values in the "YYYYMMDD" format.

/Conversion of 'Date', 'Time' and 'Datetime' Values
/ - - - - - - - - - - - - - - - - - - - - - - - - -
 Several utility components of 'bdlt' provide functions for the conversion of
 date and time types to other types, some defined in the C++ Standard, others
 defined elsewhere in BDE.  In particular, the 'bdlt_epochutil' component
 provides functions that convert 'bdlt::Datetime' values (in UTC) -- an value
 of "absolute" time -- to equivalent difference values measured from the start
 of the Unix standard epoch (1970/01/01_00:00:00.000 UTC).
..
  Component          Conversions
  -----------------  --------------------------------------------------------
  bdlt_dateutil      bdlt::Date     <=> int in "YYYYMMDD" format

  bdlt_datetimeutil  bdlt::Datetime <=> bsl::tm

  bdlt_epochutil     bdlt::Datetime <=> bsl::time_t            from the epoch
                     bdlt::Datetime <=> bdlt::TimeT64          from the epoch
                     bdlt::Datetime <=> bsls::TimeInterval     from the epoch
                     bdlt::Datetime <=> bdlt::DateTimeInterval from the epoch

  bdlt_intervalconversionutil
                     bdlt::DatetimeInterval
                                    <=> bsls::TimeInterval
  bdlt_serialdateimputil
                     bdlt::Date     <=> int in the range '[1 .. 3652059]'
                                        (corresponding to
                                        '[00001/01/01 .. 9999/12/31]')
..

/Conversion of Conventional Time Units
/- - - - - - - - - - - - - - - - - - -
 The 'bdlt_timeunitratio' component provides a set of time-unit-ratio
 conversion constants between time units of units of days, hours, minutes,
 seconds, milliseconds, and nanoseconds.  (e.g.,
 'bdlt::TimeUnitRatio::k_MILLISECONDS_PER_MINUTE').

/Usage
/-----
 This section illustrates intended use of these components.

/Example 1: Celebrating Milestone Dates
/ - - - - - - - - - - - - - - - - - - -
 Date and time calculations are simple in principle but tedious and error-
 prone in practice.  Consequently, we tend to choose as milestone dates that
 allow us to avoid such awkward calculations.  For example, we consider
 ourselves one year older on our birthday (anniversaries) even though some
 years (leap years) are longer than others.  Access to a rich set of types and
 utilities for date and time calculations affords us other options.  Suppose
 one wishes to commemorate the 20,000th day since birth.

 First, create a 'bdlt::Datetime' object to represent our birthday date.
 Assume we were born at very beginning of the Unix epoch:
..
  bdlt::Datetime dtBirthday = bdlt::EpochUtil::epoch();
  assert(bdlt::Datetime(1970, 1, 1, 0, 0, 0, 0) == dtBirthday);
..
 Next, we calculate the milestone date.
..
  bdlt::Datetime dt20k(dtBirthday);  dt20k.addDays(20000);
  assert(bdlt::DatetimeInterval(20000) == dt20k - dtBirthday);

  bsl::cout << dt20k << bsl::endl;
..
 and find on the console:

 04OCT2024_00:00:00.000

 Then, we recall that the above values represent UTC datetime values but we
 reside in New York City, another time zone.  We must calculate the localtime
 offset for that future date and adjust our milestone date.
..
  bsls::TimeInterval localTimeOffset
                             = bdlt::LocalTimeOffset::localTimeOffset(dt20k);

  bsls::Types::Int64 offsetSeconds
                       =  localTimeOffset.seconds();
  bsls::Types::Int64 offsetMilliseconds
                        = localTimeOffset.nanoseconds()
                        / bdlt::TimeUnitRatio::k_NANOSECONDS_PER_MILLISECOND;

  bdlt::Datetime dt20kLocal(dt20k);
  dt20kLocal.     addSeconds(     offsetSeconds);
  dt20kLocal.addMilliseconds(offsetMilliseconds);

  bdlt::Date targetDate = dt20kLocal.date();

  bsl::cout << targetDate << bsl::endl;
..
 which is one calendar day earlier:
..
  03OCT2024
..
 Next, we recall that we prefer to hold celebrations on weekend days, not
 weekdays, so we determine where in the week target date falls.

 To aid our calculation, we define a 'bdlt::DayOfWeekSet' object set to the
 weekend days in New York City.
..
  bdlt::DayOfWeekSet weekendDays;
  weekendDays.add(bdlt::DayOfWeek::e_SATURDAY);
  weekendDays.add(bdlt::DayOfWeek::e_SUNDAY);
..
 Now, we determine if the target date is a weekend day, or not:
..
  if (weekendDays.isMember(targetDate.dayOfWeek())) {
     bsl::cout << "Target   date:"       << " "
               << targetDate.dayOfWeek() << " "
               << targetDate             << bsl::endl;

      bdlt::Date holdDate = targetDate;

      bsl::cout << "Hold the date:"     << " "
                << holdDate.dayOfWeek() << " "
                << holdDate             << bsl::endl;
  } else {
     bsl::cout << "Target   date:"       << " "
               << targetDate.dayOfWeek() << " "
               << targetDate             << bsl::endl;
..
 If the target date is midweek, we calculate the closest weekend date.  In case
 of a tie (Wednesday is equidistant from Sunday and Saturday) we (arbitrarily)
 give preference to the earlier candidate date.
..
      bdlt::Date aforeCandidate =
                 bdlt::DateUtil::previousDayOfWeek(bdlt::DayOfWeek::e_SUNDAY,
                                                   targetDate);
      bdlt::Date afterCandidate =
                   bdlt::DateUtil::nextDayOfWeek(bdlt::DayOfWeek::e_SATURDAY,
                                                 targetDate);

      bdlt::Date holdDate  = targetDate     - aforeCandidate
                          <= afterCandidate - targetDate
                          ?  aforeCandidate
                          :  afterCandidate;

      bsl::cout << "Hold the date:"     << " "
                << holdDate.dayOfWeek() << " "
                << holdDate             << bsl::endl;
  }
..
 Finally, we learn:
..
  Target   date: THU 03OCT2024
  Hold the date: SAT 05OCT2024
..
 and we can send out our hold-the-date notices.
