 bdlt.txt

@PURPOSE: Provide and time-related vocabulary types, and related utilities.

@MNEMONIC: Basic Development Library Time (bdlt)

@AUTHOR: Steven Breitstein (sbreitstein)

@DESCRIPTION: The 'bdlt' ("Basic Development Library Time") package provides
 vocabulary types for representing date and type values, utilities providing
 non-primitive functionality on those types, utilities that provide date- and
 time values (e.g., 'bdlt_currenttime'), and supporting components.

/Hierarchical Synopsis
/---------------------
 The 'bdlt' package currently has 18 components having 7 levels of physical
 dependency.  The list below shows the hierarchical ordering of the components.
 The order of components within each level is not architecturally significant,
 just alphabetical.
..
  7. bdlt_currenttime

  6. bdlt_datetimetz
     bdlt_localtimeoffset

  5. bdlt_datetimeutil
     bdlt_datetz
     bdlt_epochutil

  4. bdlt_datetime
     bdlt_timetz

  3. bdlt_dateutil
     bdlt_intervalconversionutil
     bdlt_time

  2. bdlt_date
     bdlt_datetimeinterval
     bdlt_dayofweekset

  1. bdlt_dayofweek
     bdlt_monthofyear
     bdlt_serialdateimputil
     bdlt_timeunitratio
..

/Component Synopsis
/------------------
: 'bdlt_currenttime':
:      Provide utilities to retrieve the current time.
:
: 'bdlt_date':
:      Provide a value-semantic type to represent dates.
:
: 'bdlt_datetime':
:      Provide a value-semantic type representing both date and time.
:
: 'bdlt_datetimeinterval':
:      Provide a representation of an interval of time.
:
: 'bdlt_datetimetz':
:      Provide a representation of a date and time with time zone offset.
:
: 'bdlt_datetimeutil':
:      Provide common non-primitive operations on 'bdlt::Datetime'.
:
: 'bdlt_datetz':
:      Provide a representation of a date with time zone offset.
:
: 'bdlt_dateutil':
:      Provide common non-primitive operations on date objects.
:
: 'bdlt_dayofweek':
:      Provide an enumeration of the set of days of the week.
:
: 'bdlt_dayofweekset':
:      Provide an ordered set of (unique) 'bdlt::DayOfWeek::Enum' values.
:
: 'bdlt_epochutil':
:      Conversion between absolute/relative time with respect to epoch.
:
: 'bdlt_intervalconversionutil':
:      Provide functions to convert between time-interval representations.
:
: 'bdlt_localtimeoffset':
:      Provide utilities to retrieve the local time offset.
:
: 'bdlt_monthofyear':
:      Enumerate the set of month-of-year values.
:
: 'bdlt_serialdateimputil':
:      Provide low-level support functions for date-value manipulation.
:
: 'bdlt_time':
:      Provide a value-semantic time-of-day type (millisecond resolution).
:
: 'bdlt_timetz':
:      Provide a representation of a time with time zone offset.
:
: 'bdlt_timeunitratio':
:      Provide constants characterizing ratios between common time units.

/Date and Time Values
/--------------------
 The 'bdlt' package defines 'bdlt::Date' to represent date values, 'bdlt::Time'
 to represent time values (to millisecond resolution) within a day, and the
 combined 'bdlt::Datetime', to represent all points in time (to millisecond
 resolution) across the range of date values.  The ranges of each type are
 shown below.
..
  Type     Range
  -------  ------------------------------------------------------
  Time     [           00:00:00.000 ..             23:59:59.999 ]
  Date     [0001/01/01              ..  9999/12/31              ]
  Datetime [0001/01/01_00:00:00.000 ..  9999/12/31_23:59:59.999 ]
..
 Further note that:
: o The date values are follow the proleptic Gregorian calendar.
: o The definition of 'bdlt::Datetime' does *not* allow for leap seconds.

 The above classes define values representing points in time (e.g, dates
 measured from the beginning of the epoch, time measured from the start of a
 day).  Alternatively, the 'bdlt::Datetime' class is used to represent the
 difference (to millisecond resolution) between arbitrary points in time.

 Each of these classes are designed to hold date and time values, but do not
 provide means for obtaining those values (e.g., the current time).  The
 section titled {XXXX} describes facilities for obtaining date and time values.

/Difference Values
/- - - - - - - - -
 The 'bdlt::DatetimeInterval' type is used to represent the difference -- to
 millisecond resolution -- between either two 'bdlt::Datetime' or two
 'bdlt::Time' objects.  The difference between 'bdlt::Date' objects is
 represented by 'int'.  Operators and other methods allow one to adjust (either
 foward or backward) the date and time values by a difference value.

/Distinguished Values
/ - - - - - - - - - -
 The 'bdlt::Time' class defines one distinguished value, "24:00:00.000", which
 happens to be the default constructed value.  Relational comparisons of that
 value to any other value are disallowed (the behavior is undefined) so care
 must be exercised in its use.  Notably, that value cannot be participate in
 the key value for any of the standard ordered containers (which require weak
 ordering of keys).  Otherwise, the distinguished value is implicitly to
 "00:00:00.000" in calculations that modify the value of a 'bdlt::Time' object.
 Operations that do not modify a 'bdlt::Time' object holding the distinguished
 value, evaluate as if the held value was "00:00:00.000".

 Similarly, the 'bdlt::Datetime' class defines one distinguished value,
 "0001/01/01_24:00:00.000", which happens to be the default constructed value.
 The restrictions and semantics of this value parallel those of the
 'bdtl::Time' distinguished values.

 Some applications use the distinguished values of these types as placeholders
 when a value must be provided but is not known (e.g., a "null" value in a
 database).  The default constructed value of 'bdet::Date', "0001/01/01" is
 typically used as its "null" value:
..
  Type              Distinguished Value
  --------------    -----------------------
  bdet::Date        0001/01/01
  bdet::Time                   24:00.00.000
  bdet::Datetime    0001/01/01_24:00.00.000
..

/Timezone Augmented Date and Time Values
/- - - - - - - - - - - - - - - - - - - -
 Each of the basic date and time types has a corresponding type that is
 augmented with a value representing a time offset (in minutes) from UTC.
 These types are:
..
  Basis Type    Timezone Augmented Type
  ----------    -----------------------
  bldt:Date     bdlt::DateTz
  bldt:Time     bdlt::TimeTz
  bldt:Datetime bdlt::DatetimeTz
..
 Each of these types provide a "utc" accessor that adjusts the value held to
 the corresponding UTC value which facilitates the comparison of date and time
 values in different timezones.  Note that these types have no facilities for
 validating that the dates, times, and offsets held correspond to any actual,
 geographic timezone.  The section titled {Obtaining Date, Time, and Localtime
 Offset Values} describes facilities on obtaining timezone offsets.

/Obtaining Date, Time, and Localtime Offset Values
/- - - - - - - - - - - - - - - - - - - - - - - - -
 The 'bdlt_systemtimeutil' component provides functions that return the current
 time in several forms:
: o A 'bsls::Datimetime' value, available both in UTC and for the local time
:   zone.
: o A 'bsls::TimeInterval' from the the epoch.  These values can be further
:   specified as coming from either a monotonic or realtime clock.

 The local time offset (from UTC) can be obtained for a given 'bdlt::Datetime'
 value (in UTC) as a 'bsls::TimeInterval' value from 'bdlt::LocalTimeOffset' or
 as a 'bdlt::DatetimeInterval' (for the local time zone)
 'bdlt::SystemTimeUtil'.

 Both 'bdlt::SystemTimeUtil' and 'bdlt::LocalTimeOffset' obtain their values
 from callback functions.  The default installed callbacks obtain their values
 from platform appropriate system calls.  Users are able to create and install
 their own callbacks.  This facility allows the creation of high perforamce
 alternatives, staticts gathering, and "mocking" during tests.

/Conversion of Date and Time Values to Other Representations
/- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 Several utility components of 'bdlt' provide functions for the conversion of
 date and time types to other types, some defined in the C++ Standard, others
 defined elsewhere in BDE.  In particular, the 'bdlt_epochutil' component
 provides functions that convert 'bdlt::Datetime' values (in UTC) -- an value
 of "absolute" time -- to equivalent difference values measured from the start
 of the Unix standard "epoch" (1970/01/01_00:00:00.000 UTC).
..
  Component          Conversions
  -----------------  --------------------------------------------------------
  bdlt_dateutil      bdlt::Date     <=> int in "YYYYMMDD" format

  bdlt_datetimeutil  bdlt::Datetime <=> bsl::tm

  bdlt_epochutil     bdlt::Datetime <=> bsl::time_t            from the epoch
                     bdlt::Datetime <=> bdlt::TimeT64          from the epoch
                     bdlt::Datetime <=> bsls::TimeInterval     from the epoch
                     bdlt::Datetime <=> bdlt::DateTimeInterval from the epoch
..
 TBD: 'bdlt_intervalconversionutil'

/Date Calculations
/-----------------
 TBD: 'bdlt_dateutil', the "next" and "previous" functions.
 TBD: 'bdlt_dateofweek' and 'bdtl_dateofweekset'
 TBD: 'bdlt_timeunitratio'

/Usage
/-----
 This section illustrates the intended use of these components.

/Example 1: Celebrating Milestone Dates
/ - - - - - - - - - - - - - - - - - - -
 Date and time calculations are simple in principle but tedious and error-
 prone in practice.  Consequently, we tend to choose as "milestone" dates
 that allow us to avoid such awkward calculations.  For example, we consider
 ourselves one year older on our birthday (anniversaries) even though some
 years (leap years) are longer than others.  Access to a rich set of
 types and utilities for date and time calculations affords us other options.
 Suppose one wishes to commemorate the 20,000th day of one's life.
 
 First, create a 'bdlt::Datetime' object to represent our birthday date.
 Let's assume we were born at very beginning of the Unix epoch:
..
  bdlt::Datetime dtBirthday = bdlt::EpochUtil::epoch();
  assert(bdlt::Datetime(1970, 1, 1, 0, 0, 0, 0) == dtBirthday);
..
 Next, we calculate the milestone date.
..
  bdlt::Datetime dt20k(dtBirthday);  dt20k.addDays(20000);
  assert(bdlt::DatetimeInterval(20000) == dt20k - dtBirthday);

  bsl::cout << dt20k << bsl::endl;
..
 and find on the console:

  04OCT2024_00:00:00.000

 Then, we recall that the above values represent UTC datetime values but
 we reside in another time zone (e.g., "New York City").  We must calculate
 the localtime offset for that future date and adjust our milestone date.
..
  bsls::TimeInterval localTimeOffset
                             = bdlt::LocalTimeOffset::localTimeOffset(dt20k);

  bsls::Types::Int64 offsetSeconds
                       =  localTimeOffset.seconds();
  bsls::Types::Int64 offsetMilliseconds
                        = localTimeOffset.nanoseconds()
                        / bdlt::TimeUnitRatio::k_NANOSECONDS_PER_MILLISECOND;

  bdlt::Datetime dt20kLcl(dt20k);
  dt20kLcl.     addSeconds(     offsetSeconds);
  dt20kLcl.addMilliseconds(offsetMilliseconds);

  bdlt::Date targetDate = dt20kLcl.date();

  bsl::cout << targetDate << bsl::endl;
..
 which is one calendar day earlier:

  03OCT2024
 
 Next, we recall that we prefer to hold celebrations on weekend days,
 not weekdays, so we determine where in the week target date falls:
..
  bdlt::DayOfWeekSet weekendDays;
  weekendDays.add(bdlt::DayOfWeek::e_SATURDAY);
  weekendDays.add(bdlt::DayOfWeek::e_SUNDAY);

  if (weekendDays.isMember(targetDate.dayOfWeek())) {
..
 Now, if the target date is a weekend day, we hold that date:
..
      bdlt::Date holdDate = targetDate;
      bsl::cout << "Hold the day:"      << " "
                << holdDate.dayOfWeek() << " "
                << holdDate             << bsl::endl;
      } else {
..
 Otherwise, we consider holding the celebration on the either day of
 the adjacent weekends:
..
          bsl::cout << "Target date is midweek:" << " "
                    << targetDate.dayOfWeek()    << " "
                    << targetDate                << bsl::endl;
..
 shows 
  Target date is midweek: THU 03OCT2024

 We calculate candidate dates using functions from 'bdlt::DateUtil'
 in concert with a standard container ('bsl::vector') and a standard
 algorithm ('bsl::sort)':
..
          bsl::vector<bdlt::Date> candidateDates;

          for (bdlt::DayOfWeekSet::iterator itr  = weekendDays.begin(),
                                            end  = weekendDays.end();
                                            end != itr;
                                             ++itr) {
              bdlt::Date candidateNext = bdlt::DateUtil::nextDayOfWeek(
                                                                 *itr,
                                                                 targetDate);
              bdlt::Date candidatePrev = bdlt::DateUtil::previousDayOfWeek(
                                                                *itr,
                                                                 targetDate);
              candidateDates.push_back(candidateNext);
              candidateDates.push_back(candidatePrev);
          }

          bsl::sort(candidateDates.begin(), candidateDates.end());

          for (bsl::vector<bdlt::Date>::const_iterator
                                               itr  = candidateDates.begin(),
                                               end  = candidateDates.end();
                                               end != itr;
                                               ++itr) {
              bdlt::Date candidateDate = *itr;
              bsl::cout << "Candidate:"              << " "
                        << candidateDate.dayOfWeek() << " "
                        << candidateDate             << bsl::endl;
..
 which shows:

  Candidate: SAT 28SEP2024
  Candidate: SUN 29SEP2024
  Candidate: SAT 05OCT2024
  Candidate: SUN 06OCT2024

 Finally, we decide on the best date and send out our hold-the-date notices.
