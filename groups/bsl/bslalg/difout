[36;40mdiff --git a/groups/bsl/bslalg/bslalg_arrayprimitives.h b/groups/bsl/bslalg/bslalg_arrayprimitives.h[m
[36;40mindex f1a5de1..73e4402 100644[m
[36;40m--- a/groups/bsl/bslalg/bslalg_arrayprimitives.h[m
[36;40m+++ b/groups/bsl/bslalg/bslalg_arrayprimitives.h[m
[36;44m@@ -454,6 +454,12 @@[m[30;47m [m[34;46mstruct ArrayPrimitives {[m
[30;47m                               FWD_ITER     fromBegin,[m
[30;47m                               FWD_ITER     fromEnd,[m
[30;47m                               ALLOCATOR   *allocator);[m
[32;40m+[m
[32;40m+[m[32;40m    template <class TARGET_TYPE, class SOURCE_TYPE, class ALLOCATOR>[m
[32;40m+[m[32;40m    static void copyConstruct(TARGET_TYPE *toBegin,[m
[32;40m+[m[32;40m                              SOURCE_TYPE *fromBegin,[m
[32;40m+[m[32;40m                              SOURCE_TYPE *fromEnd,[m
[32;40m+[m[32;40m                              ALLOCATOR   *allocator);[m
[30;47m         // Copy into an uninitialized array of the parameterized 'TARGET_TYPE'[m
[30;47m         // beginning at the specified 'toBegin' address, the elements in the[m
[30;47m         // array of 'TARGET_TYPE' starting at the specified 'fromBegin' address[m
[36;44m@@ -580,6 +586,13 @@[m[30;47m [m[34;46mstruct ArrayPrimitives {[m
[30;47m                        const TARGET_TYPE&  value,[m
[30;47m                        size_type           numElements,[m
[30;47m                        ALLOCATOR          *allocator);[m
[32;40m+[m[32;40m    template <class TARGET_TYPE, class SOURCE_TYPE, class ALLOCATOR>[m
[32;40m+[m[32;40m    static void insert(TARGET_TYPE        *toBegin,[m
[32;40m+[m[32;40m                       TARGET_TYPE        *toEnd,[m
[32;40m+[m[32;40m                       SOURCE_TYPE        *fromBegin,[m
[32;40m+[m[32;40m                       SOURCE_TYPE        *fromEnd,[m
[32;40m+[m[32;40m                       size_type           numElements,[m
[32;40m+[m[32;40m                       ALLOCATOR          *allocator);[m
[30;47m         // Insert the specified 'numElements' copies of the specified 'value'[m
[30;47m         // into the array of the parameterized 'TARGET_TYPE' starting at the[m
[30;47m         // 'toBegin' address and ending immediately before the specified[m
[36;44m@@ -813,12 +826,13 @@[m[30;47m [m[34;46mstruct ArrayPrimitives_Imp {[m
[30;47m         // 'TARGET_TYPE' has the traits for which the enumerator equal to 'N'[m
[30;47m         // is named.[m
[30;47m [m
[31;47m-        IS_POINTER_TO_POINTER           = 5,[m
[31;47m-        IS_FUNDAMENTAL_OR_POINTER       = 4,[m
[31;47m-        HAS_TRIVIAL_DEFAULT_CTOR_TRAITS = 3,[m
[31;47m-        BITWISE_COPYABLE_TRAITS         = 2,[m
[31;47m-        BITWISE_MOVEABLE_TRAITS         = 1,[m
[31;47m-        NIL_TRAITS                      = 0[m
[32;40m+[m[32;40m        IS_ITERATOR_TO_POINTER_TO_FUNCTION = 6,[m
[32;40m+[m[32;40m        IS_POINTER_TO_POINTER              = 5,[m
[32;40m+[m[32;40m        IS_FUNDAMENTAL_OR_POINTER          = 4,[m
[32;40m+[m[32;40m        HAS_TRIVIAL_DEFAULT_CTOR_TRAITS    = 3,[m
[32;40m+[m[32;40m        BITWISE_COPYABLE_TRAITS            = 2,[m
[32;40m+[m[32;40m        BITWISE_MOVEABLE_TRAITS            = 1,[m
[32;40m+[m[32;40m        NIL_TRAITS                         = 0[m
[30;47m     };[m
[30;47m [m
[30;47m     enum {[m
[36;44m@@ -1027,12 +1041,19 @@[m[30;47m [m[34;46mstruct ArrayPrimitives_Imp {[m
[30;47m                               FWD_ITER                    fromEnd,[m
[30;47m                               ALLOCATOR                  *allocator,[m
[30;47m                               bslmf::MetaInt<NIL_TRAITS> *);[m
[32;40m+[m[32;40m/*[m
[30;47m     template <class FWD_ITER, class ALLOCATOR>[m
[30;47m     static void copyConstruct(void                      **toBegin,[m
[30;47m                               FWD_ITER                    fromBegin,[m
[30;47m                               FWD_ITER                    fromEnd,[m
[30;47m                               ALLOCATOR                  *allocator,[m
[31;47m-                              bslmf::MetaInt<NIL_TRAITS> *);[m
[32;40m+[m[32;40m                              bslmf::MetaInt<NIL_TRAITS> *);*/[m
[32;40m+[m[32;40m    template <class FWD_ITER, class ALLOCATOR>[m
[32;40m+[m[32;40m    static void copyConstruct(void                                 **toBegin,[m
[32;40m+[m[32;40m                              FWD_ITER                               fromBegin,[m
[32;40m+[m[32;40m                              FWD_ITER                               fromEnd,[m
[32;40m+[m[32;40m                              ALLOCATOR                             *allocator,[m
[32;40m+[m[32;40m                         bslmf::MetaInt<IS_ITERATOR_TO_POINTER_TO_FUNCTION> *);[m
[30;47m         // These functions follow the 'copyConstruct' contract.  If the[m
[30;47m         // parameterized 'ALLOCATOR' is based on 'bslma::Allocator' and the[m
[30;47m         // 'TARGET_TYPE' constructors take an allocator argument, then pass the[m
[36;44m@@ -1388,7 +1409,7 @@[m[30;47m [m[34;46mstruct ArrayPrimitives_Imp {[m
[30;47m                        FWD_ITER                                 fromEnd,[m
[30;47m                        size_type                                numElements,[m
[30;47m                        ALLOCATOR                               *allocator,[m
[31;47m-                       bslmf::MetaInt<BITWISE_MOVEABLE_TRAITS> *);[m
[32;40m+[m[32;40m                       bslmf::MetaInt<IS_ITERATOR_TO_POINTER_TO_FUNCTION> *);[m
[30;47m     template <class TARGET_TYPE, class FWD_ITER, class ALLOCATOR>[m
[30;47m     static void insert(TARGET_TYPE                *toBegin,[m
[30;47m                        TARGET_TYPE                *toEnd,[m
[36;44m@@ -1586,14 +1607,40 @@[m[30;47m [m[34;46mvoid ArrayPrimitives::copyConstruct(TARGET_TYPE *toBegin,[m
[30;47m {[m
[30;47m     BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);[m
[30;47m [m
[31;47m-    typedef typename bsl::remove_pointer<FWD_ITER>::type FwdTarget;[m
[32;40m+[m[32;40m    typedef typename FWD_ITER::value_type FwdTarget;[m
[30;47m     enum {[m
[31;47m-        ARE_PTRS_TO_PTRS = bslmf::IsPointer<TARGET_TYPE>::value &&[m
[31;47m-                           bslmf::IsPointer<FWD_ITER   >::value &&[m
[31;47m-                           bslmf::IsPointer<FwdTarget  >::value,[m
[30;47m         IS_BITWISECOPYABLE = bsl::is_trivially_copyable<TARGET_TYPE>::value &&[m
[30;47m                              bslmf::IsConvertible<FWD_ITER,[m
[30;47m                                                    const TARGET_TYPE *>::value,[m
[32;40m+[m[32;40m        ARE_PTRS_TO_FNS = bslmf::IsFunctionPointer<FwdTarget>::value,[m
[32;40m+[m
[32;40m+[m[32;40m        VALUE = IS_BITWISECOPYABLE ? Imp::BITWISE_COPYABLE_TRAITS[m
[32;40m+[m[32;40m              : ARE_PTRS_TO_FNS ? Imp::IS_ITERATOR_TO_POINTER_TO_FUNCTION[m
[32;40m+[m[32;40m              : Imp::NIL_TRAITS[m
[32;40m+[m[32;40m    };[m
[32;40m+[m
[32;40m+[m[32;40m    ArrayPrimitives_Imp::copyConstruct(toBegin,[m
[32;40m+[m[32;40m                                       fromBegin,[m
[32;40m+[m[32;40m                                       fromEnd,[m
[32;40m+[m[32;40m                                       allocator,[m
[32;40m+[m[32;40m                                       (bslmf::MetaInt<VALUE>*)0);[m
[32;40m+[m[32;40m}[m
[32;40m+[m
[32;40m+[m[32;40mtemplate <class TARGET_TYPE, class SOURCE_TYPE, class ALLOCATOR>[m
[32;40m+[m[32;40minline[m
[32;40m+[m[32;40mvoid ArrayPrimitives::copyConstruct(TARGET_TYPE *toBegin,[m
[32;40m+[m[32;40m                                    SOURCE_TYPE *fromBegin,[m
[32;40m+[m[32;40m                                    SOURCE_TYPE *fromEnd,[m
[32;40m+[m[32;40m                                    ALLOCATOR   *allocator)[m
[32;40m+[m[32;40m{[m
[32;40m+[m[32;40m    BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);[m
[32;40m+[m
[32;40m+[m[32;40m    enum {[m
[32;40m+[m[32;40m        ARE_PTRS_TO_PTRS = bslmf::IsPointer<TARGET_TYPE>::value &&[m
[32;40m+[m[32;40m                           bslmf::IsPointer<SOURCE_TYPE>::value,[m
[32;40m+[m[32;40m        IS_BITWISECOPYABLE = bsl::is_trivially_copyable<TARGET_TYPE>::value &&[m
[32;40m+[m[32;40m                             bslmf::IsConvertible<SOURCE_TYPE *,[m
[32;40m+[m[32;40m                                                   const TARGET_TYPE *>::value,[m
[30;47m         VALUE = ARE_PTRS_TO_PTRS   ? Imp::IS_POINTER_TO_POINTER[m
[30;47m               : IS_BITWISECOPYABLE ? Imp::BITWISE_COPYABLE_TRAITS[m
[30;47m               : Imp::NIL_TRAITS[m
[36;44m@@ -2148,6 +2195,40 @@[m[30;47m [m[34;46mvoid ArrayPrimitives::emplace(TARGET_TYPE               *toBegin,[m
[30;47m // }}} END GENERATED CODE[m
[30;47m #endif[m
[30;47m [m
[32;40m+[m[32;40mtemplate <class TARGET_TYPE, class SOURCE_TYPE, class ALLOCATOR>[m
[32;40m+[m[32;40minline[m
[32;40m+[m[32;40mvoid ArrayPrimitives::insert(TARGET_TYPE *toBegin,[m
[32;40m+[m[32;40m                             TARGET_TYPE *toEnd,[m
[32;40m+[m[32;40m                             SOURCE_TYPE *fromBegin,[m
[32;40m+[m[32;40m                             SOURCE_TYPE *fromEnd,[m
[32;40m+[m[32;40m                             size_type    numElements,[m
[32;40m+[m[32;40m                             ALLOCATOR   *allocator)[m
[32;40m+[m[32;40m{[m
[32;40m+[m[32;40m    if (0 == numElements) {[m
[32;40m+[m[32;40m        return;                                                       // RETURN[m
[32;40m+[m[32;40m    }[m
[32;40m+[m
[32;40m+[m[32;40m    enum {[m
[32;40m+[m[32;40m        ARE_PTRS_TO_PTRS = bslmf::IsPointer<TARGET_TYPE>::value &&[m
[32;40m+[m[32;40m                           bslmf::IsPointer<SOURCE_TYPE>::value,[m
[32;40m+[m[32;40m        IS_BITWISEMOVEABLE  = bslmf::IsBitwiseMoveable<TARGET_TYPE>::value,[m
[32;40m+[m[32;40m        IS_BITWISECOPYABLE  = bslmf::IsConvertible<SOURCE_TYPE *,[m
[32;40m+[m[32;40m                                                   const TARGET_TYPE *>::value[m
[32;40m+[m[32;40m                            && bsl::is_trivially_copyable<TARGET_TYPE>::value,[m
[32;40m+[m[32;40m        VALUE = ARE_PTRS_TO_PTRS   ? Imp::IS_POINTER_TO_POINTER[m
[32;40m+[m[32;40m              : IS_BITWISECOPYABLE ? Imp::BITWISE_COPYABLE_TRAITS[m
[32;40m+[m[32;40m              : IS_BITWISEMOVEABLE ? Imp::BITWISE_MOVEABLE_TRAITS[m
[32;40m+[m[32;40m              : Imp::NIL_TRAITS[m
[32;40m+[m[32;40m    };[m
[32;40m+[m[32;40m    ArrayPrimitives_Imp::insert(toBegin,[m
[32;40m+[m[32;40m                                toEnd,[m
[32;40m+[m[32;40m                                fromBegin,[m
[32;40m+[m[32;40m                                fromEnd,[m
[32;40m+[m[32;40m                                numElements,[m
[32;40m+[m[32;40m                                allocator,[m
[32;40m+[m[32;40m                                (bslmf::MetaInt<VALUE>*)0);[m
[32;40m+[m[32;40m}[m
[32;40m+[m
[30;47m template <class TARGET_TYPE, class FWD_ITER, class ALLOCATOR>[m
[30;47m inline[m
[30;47m void ArrayPrimitives::insert(TARGET_TYPE *toBegin,[m
[36;44m@@ -2161,18 +2242,17 @@[m[30;47m [m[34;46mvoid ArrayPrimitives::insert(TARGET_TYPE *toBegin,[m
[30;47m         return;                                                       // RETURN[m
[30;47m     }[m
[30;47m [m
[31;47m-    typedef typename bsl::remove_pointer<FWD_ITER>::type FwdTarget;[m
[32;40m+[m[32;40m    typedef typename FWD_ITER::value_type FwdTarget;[m
[30;47m     enum {[m
[31;47m-        ARE_PTRS_TO_PTRS = bslmf::IsPointer<TARGET_TYPE>::value &&[m
[31;47m-                           bslmf::IsPointer<FWD_ITER   >::value &&[m
[31;47m-                           bslmf::IsPointer<FwdTarget  >::value,[m
[32;40m+[m[32;40m        ARE_PTRS_TO_FNS = bslmf::IsFunctionPointer<FwdTarget>::value,[m
[32;40m+[m
[30;47m         IS_BITWISEMOVEABLE  = bslmf::IsBitwiseMoveable<TARGET_TYPE>::value,[m
[30;47m         IS_BITWISECOPYABLE  = bslmf::IsConvertible<FWD_ITER,[m
[30;47m                                                    const TARGET_TYPE *>::value[m
[30;47m                             && bsl::is_trivially_copyable<TARGET_TYPE>::value,[m
[31;47m-        VALUE = ARE_PTRS_TO_PTRS   ? Imp::IS_POINTER_TO_POINTER[m
[31;47m-              : IS_BITWISECOPYABLE ? Imp::BITWISE_COPYABLE_TRAITS[m
[32;40m+[m[32;40m        VALUE = IS_BITWISECOPYABLE ? Imp::BITWISE_COPYABLE_TRAITS[m
[30;47m               : IS_BITWISEMOVEABLE ? Imp::BITWISE_MOVEABLE_TRAITS[m
[32;40m+[m[32;40m              : ARE_PTRS_TO_FNS ? Imp::IS_ITERATOR_TO_POINTER_TO_FUNCTION[m
[30;47m               : Imp::NIL_TRAITS[m
[30;47m     };[m
[30;47m     ArrayPrimitives_Imp::insert(toBegin,[m
[36;44m@@ -2638,6 +2718,33 @@[m[30;47m [m[34;46mvoid ArrayPrimitives_Imp::copyConstruct([m
[30;47m #endif[m
[30;47m }[m
[30;47m [m
[32;40m+[m[32;40mtemplate <class FWD_ITER, class ALLOCATOR>[m
[32;40m+[m[32;40mvoid ArrayPrimitives_Imp::copyConstruct([m
[32;40m+[m[32;40m                          void                                     **toBegin,[m
[32;40m+[m[32;40m                          FWD_ITER                                   fromBegin,[m
[32;40m+[m[32;40m                          FWD_ITER                                   fromEnd,[m
[32;40m+[m[32;40m                          ALLOCATOR                                 *allocator,[m
[32;40m+[m[32;40m                          bslmf::MetaInt<IS_ITERATOR_TO_POINTER_TO_FUNCTION> *)[m
[32;40m+[m[32;40m{[m
[32;40m+[m[32;40m    // We may be casting a func ptr to a 'void *' here, so this won't work if[m
[32;40m+[m[32;40m    // we port to an architecture where the two are of different sizes.[m
[32;40m+[m
[32;40m+[m[32;40m    BSLMF_ASSERT(sizeof(void *) == sizeof(void (*)()));[m
[32;40m+[m
[32;40m+[m[32;40m    BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);[m
[32;40m+[m[32;40m    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(fromBegin,[m
[32;40m+[m[32;40m                                                          fromEnd));[m
[32;40m+[m
[32;40m+[m[32;40m    while (fromBegin != fromEnd) {[m
[32;40m+[m[32;40m        // Note: We are not sure the value type of 'FWD_ITER' is convertible to[m
[32;40m+[m[32;40m        // 'TARGET_TYPE'.  Use 'construct' instead.[m
[32;40m+[m
[32;40m+[m[32;40m        *toBegin = reinterpret_cast<void *>(*fromBegin);[m
[32;40m+[m
[32;40m+[m[32;40m        ++fromBegin;[m
[32;40m+[m[32;40m    }[m
[32;40m+[m[32;40m}[m
[32;40m+[m
[30;47m template <class TARGET_TYPE, class ALLOCATOR>[m
[30;47m inline[m
[30;47m void ArrayPrimitives_Imp::copyConstruct([m
[36;44m@@ -2679,6 +2786,22 @@[m[30;47m [m[34;46mvoid ArrayPrimitives_Imp::copyConstruct(TARGET_TYPE                *toBegin,[m
[30;47m     guard.release();[m
[30;47m }[m
[30;47m [m
[32;40m+[m[32;40m/*[m
[32;40m+[m[32;40mtemplate <class TARGET_TYPE, class T, class ALLOCATOR>[m
[32;40m+[m[32;40mvoid ArrayPrimitives_Imp::copyConstruct(TARGET_TYPE                *toBegin,[m
[32;40m+[m[32;40m                                        T                          *fromBegin,[m
[32;40m+[m[32;40m                                        T                          *fromEnd,[m
[32;40m+[m[32;40m                                        ALLOCATOR                  *allocator,[m
[32;40m+[m[32;40m                                        bslmf::MetaInt<NIL_TRAITS> *)[m
[32;40m+[m[32;40m{[m
[32;40m+[m[32;40m    BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);[m
[32;40m+[m[32;40m    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(fromBegin,[m
[32;40m+[m
[32;40m+[m[32;40m    AutoArrayDestructor<TARGET_TYPE> guard(toBegin, toBegin);[m
[32;40m+[m[32;40m                                                       fromEnd));[m
[32;40m+[m[32;40m}[m
[32;40m+[m[32;40m*/[m
[32;40m+[m[32;40m /*[m
[30;47m template <class FWD_ITER, class ALLOCATOR>[m
[30;47m void ArrayPrimitives_Imp::copyConstruct(void                      **toBegin,[m
[30;47m                                         FWD_ITER                    fromBegin,[m
[36;44m@@ -2704,8 +2827,7 @@[m[30;47m [m[34;46mvoid ArrayPrimitives_Imp::copyConstruct(void                      **toBegin,[m
[30;47m                                     allocator);[m
[30;47m         ++fromBegin;[m
[30;47m     }[m
[31;47m-}[m
[31;47m-[m
[32;40m+[m[32;40m}*/[m
[30;47m                      // *** 'destructiveMove' overloads: ***[m
[30;47m [m
[30;47m template <class TARGET_TYPE, class ALLOCATOR>[m
[36;44m@@ -4552,7 +4674,7 @@[m[30;47m [m[34;46mvoid ArrayPrimitives_Imp::insert([m
[30;47m                           FWD_ITER,[m
[30;47m                           size_type                                numElements,[m
[30;47m                           ALLOCATOR                               *allocator,[m
[31;47m-                          bslmf::MetaInt<BITWISE_MOVEABLE_TRAITS> *)[m
[32;40m+[m[32;40m                          bslmf::MetaInt<IS_ITERATOR_TO_POINTER_TO_FUNCTION> *)[m
[30;47m {[m
[30;47m     // This very specific overload is required for the case that 'FWD_ITER' is[m
[30;47m     // an iterator that is not a pointer, iterating over function pointers.[m
[36;44m@@ -4598,9 +4720,8 @@[m[30;47m [m[34;46mvoid ArrayPrimitives_Imp::insert([m
[30;47m     std::memmove(destBegin, toBegin, tailLen * sizeof(void **));[m
[30;47m [m
[30;47m     for (int i = 0; i < numElements; i++) {[m
[31;47m-        ScalarPrimitives::construct(toBegin,[m
[31;47m-                                    reinterpret_cast<void *>(*fromBegin),[m
[31;47m-                                    allocator);[m
[32;40m+[m[32;40m        *toBegin = reinterpret_cast<void *>(*fromBegin);[m
[32;40m+[m
[30;47m         fromBegin++;[m
[30;47m     }[m
[30;47m [m
