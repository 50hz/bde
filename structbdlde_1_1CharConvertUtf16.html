<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Struct bdlde::CharConvertUtf16</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlde.html">bdlde</a>      </li>
      <li><a class="el" href="structbdlde_1_1CharConvertUtf16.html">bdlde::CharConvertUtf16</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlde::CharConvertUtf16 Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlde::CharConvertUtf16" -->
<p><code>#include &lt;<a class="el" href="bdlde__charconvertutf16_8h_source.html">bdlde_charconvertutf16.h</a>&gt;</code></p>

<p><a href="structbdlde_1_1CharConvertUtf16-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#aed0c2c39a68a4ab14372b8285ca9019e">utf8ToUtf16</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::wstring</a> *dstWstring, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcString, bsl::size_t *numCharsWritten=0, wchar_t errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a2f482bb5d9ff5fcdc9c733e21f104c76">utf8ToUtf16</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::wstring</a> *dstWstring, const char *srcString, bsl::size_t *numCharsWritten=0, wchar_t errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#af306d38a1f565c2baaa7f32e7dfc34e9">utf8ToUtf16</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned short &gt; *dstVector, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcString, bsl::size_t *numCharsWritten=0, unsigned short errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a2d32639b4e6edceb5bcdc427dde27848">utf8ToUtf16</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned short &gt; *dstVector, const char *srcString, bsl::size_t *numCharsWritten=0, unsigned short errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a20f46f01e3132b06a18a75c8439aa5b5">utf8ToUtf16</a> (unsigned short *dstBuffer, bsl::size_t dstCapacity, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numWordsWritten=0, unsigned short errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a0eb53a94a932210904c3527ab98eb28b">utf8ToUtf16</a> (unsigned short *dstBuffer, bsl::size_t dstCapacity, const char *srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numWordsWritten=0, unsigned short errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#aae7621b79101249aabc7d7da59a7d771">utf8ToUtf16</a> (wchar_t *dstBuffer, bsl::size_t dstCapacity, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numWordsWritten=0, wchar_t errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a11e59828895346ef5c565c26b0988f76">utf8ToUtf16</a> (wchar_t *dstBuffer, bsl::size_t dstCapacity, const char *srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numWordsWritten=0, wchar_t errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a914ab31260aa95b1f3de35111b7b43fa">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *dstString, const unsigned short *srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#aaa7f2e8614f8737f485eb4b8ef3f47d0">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *dstString, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a0ee957d799b50fb95c831a130f87950a">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *dstString, const wchar_t *srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a6c1b1e614ce5af209fc628247be3b428">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *dstVector, const unsigned short *srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#afc62afff05eae27b2f71fa47dd5f4bf7">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *dstVector, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a7e3d88d4be001f689c64635e66874faa">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *dstVector, const wchar_t *srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a31ed917ebd308f647382666b0c55e30c">utf16ToUtf8</a> (char *dstBuffer, bsl::size_t dstCapacity, const unsigned short *srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numBytesWritten=0, char errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a0719afa799c45736357abc0d314ea392">utf16ToUtf8</a> (char *dstBuffer, bsl::size_t dstCapacity, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numBytesWritten=0, char errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a6aab34549423d31e28387a4d84373084">utf16ToUtf8</a> (char *dstBuffer, bsl::size_t dstCapacity, const wchar_t *srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numBytesWritten=0, char errorCharacter= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for a suite of static functions to convert character buffers or containers between UTF-8 and UTF-16. Note that Byte Order Mark (BOM) characters are neither generated nor recognized as special. If a BOM is present in the input, it will be translated, whether correct (<code>0xfeff</code>) or incorrect (<code>0xfffe</code>), into the output without any special handling. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aed0c2c39a68a4ab14372b8285ca9019e"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="aed0c2c39a68a4ab14372b8285ca9019e" args="(bsl::wstring *dstWstring, const bslstl::StringRef &amp;srcString, bsl::size_t *numCharsWritten=0, wchar_t errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::wstring</a> *&nbsp;</td>
          <td class="paramname"> <em>dstWstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f482bb5d9ff5fcdc9c733e21f104c76"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="a2f482bb5d9ff5fcdc9c733e21f104c76" args="(bsl::wstring *dstWstring, const char *srcString, bsl::size_t *numCharsWritten=0, wchar_t errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::wstring</a> *&nbsp;</td>
          <td class="paramname"> <em>dstWstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstWstring</code> the result of converting the specified UTF-8 <code>srcString</code> to its UTF-16 equivalent. Optionally specify <code>numCharsWritten</code> which, if not 0, indicates the location of the modifiable variable into which the number of UTF-16 characters written, including the terminating null character, is to be loaded. Optionally specify an <code>errorCharacter</code> to be substituted, if not 0, for invalid encodings in the input string. Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 output; if <code>byteOrder</code> is not specified, the output is assumed to be in host byte order. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dab425e720aac8ed4709123fa3e376eb4e">CharConvertStatus::k_INVALID_CHARS_BIT</a></code> otherwise. Invalid encodings are multi-byte encoding parts out of sequence, non-minimal UTF-8 encodings of characters, or characters outside the ranges which UTF-16 can validly encode (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0x10ffff ]</code>). If <code>errorCharacter</code> is 0, invalid input characters are ignored (i.e., produce no corresponding output characters). The behavior is undefined unless <code>srcString</code> is null-terminated when specified as a <code>const char *</code>. Note that one <em>character</em> can occupy multiple 16-bit <em>words</em>, and that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded null bytes which will be translated to null characters embedded in the output. </p>

</div>
</div>
<a class="anchor" id="af306d38a1f565c2baaa7f32e7dfc34e9"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="af306d38a1f565c2baaa7f32e7dfc34e9" args="(bsl::vector&lt; unsigned short &gt; *dstVector, const bslstl::StringRef &amp;srcString, bsl::size_t *numCharsWritten=0, unsigned short errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned short &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d32639b4e6edceb5bcdc427dde27848"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="a2d32639b4e6edceb5bcdc427dde27848" args="(bsl::vector&lt; unsigned short &gt; *dstVector, const char *srcString, bsl::size_t *numCharsWritten=0, unsigned short errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned short &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstVector</code> the result of converting the specified UTF-8 <code>srcString</code> to its UTF-16 equivalent. Optionally specify <code>numCharsWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of UTF-16 characters (including the null terminator) written is to be loaded. Optionally specify an <code>errorCharacter</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are multi-byte encoding parts out of sequence, non-minimal UTF-8 encodings of characters, or characters outside the ranges which UTF-16 can validly encode (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0x10ffff ]</code>). If <code>errorCharacter</code> is 0, invalid input characters are ignored (i.e., produce no corresponding output characters). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 output; if <code>byteOrder</code> is not specified, the output is assumed to be in host byte order. Any previous contents of the destination are discarded. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dab425e720aac8ed4709123fa3e376eb4e">CharConvertStatus::k_INVALID_CHARS_BIT</a></code> otherwise. The behavior is undefined unless <code>errorCharacter</code> is either 0 or a valid single-word encoded UTF-16 character (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0xffff ]</code>) and <code>srcString</code> is null-terminated when specified as a <code>const char *</code>. Note that one <em>character</em> can occupy multiple 16-bit <em>words</em>. Also note that the size of the result vector is always fitted to the null-terminated result, including the terminating 0. Also note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded null bytes which will be translated to null characters embedded in the output. </p>

</div>
</div>
<a class="anchor" id="a20f46f01e3132b06a18a75c8439aa5b5"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="a20f46f01e3132b06a18a75c8439aa5b5" args="(unsigned short *dstBuffer, bsl::size_t dstCapacity, const bslstl::StringRef &amp;srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numWordsWritten=0, unsigned short errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numWordsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0eb53a94a932210904c3527ab98eb28b"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="a0eb53a94a932210904c3527ab98eb28b" args="(unsigned short *dstBuffer, bsl::size_t dstCapacity, const char *srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numWordsWritten=0, unsigned short errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numWordsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstBuffer</code> of the specified <code>dstCapacity</code>, the result of converting the specified UTF-8 <code>srcString</code> to its UTF-16 equivalent. Optionally specify <code>numCharsWritten</code> which (if not 0) indicates the location of the variable into which the number of UTF-16 characters (including the null terminator) written is to be loaded. Optionally specify <code>numWordsWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of <code>short</code> <em>memory words</em> written (including the null terminator) is to be loaded. Optionally specify an <code>errorCharacter</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are multi-byte encoding parts out of sequence, non-minimal UTF-8 encodings of characters, or characters outside the ranges which UTF-16 can validly encode (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0x10ffff ]</code>). If <code>errorCharacter</code> is 0, invalid input characters are ignored (i.e., produce no corresponding output characters). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 output; if <code>byteOrder</code> is not specified, the output is assumed to be in host byte order. Return 0 on success and a bit-wise or of the bits specified by <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2d">CharConvertStatus::Enum</a></code> otherwise to indicate that there were invalid character sequences or if <code>dstCapacity</code> was inadequate to store the output. If <code>dstCapacity &gt; 0</code> yet <code>dstCapacity</code> specifies a buffer too small to hold the output, the maximal null-terminated prefix of the properly converted result string is loaded into <code>dstBuffer</code>. The behavior is undefined unless <code>dstBuffer</code> refers to an array of at least <code>dstCapacity</code> elements, <code>errorCharacter</code> is either 0 or a valid single-word encoded UTF-16 character (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0xffff ]</code>), and <code>srcString</code> is null-terminated when supplied as a <code>const char *</code>. Note that if <code>dstCapacity</code> is 0, <code>*dstBuffer</code> is not modified and this function returns a value with <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> set and 0 is written into <code>*numCharsWritten</code> and <code>*numWordsWritten</code> (if those pointers are non-null), since there is insufficient space for even a null terminator alone. Also note that one <em>character</em> can occupy multiple 16-bit <em>words</em>, so that <code>*numWordsWritten</code> may be greater than <code>*numCharsWritten</code>, and therefore that an input <code>srcString</code> of <code>dstCapacity</code> <em>characters</em> may not fit into <code>dstBuffer</code>, however, an input <code>srcString</code> of <code>dstCapacity</code> <em>bytes</em> (including null terminator, if present) will always fit (since the UTF-8 encoding of a character requires at least as many bytes as the UTF-16 encoding requires words). Also note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded null bytes which will be translated to null characters embedded in the output. </p>

</div>
</div>
<a class="anchor" id="aae7621b79101249aabc7d7da59a7d771"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="aae7621b79101249aabc7d7da59a7d771" args="(wchar_t *dstBuffer, bsl::size_t dstCapacity, const bslstl::StringRef &amp;srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numWordsWritten=0, wchar_t errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numWordsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a11e59828895346ef5c565c26b0988f76"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="a11e59828895346ef5c565c26b0988f76" args="(wchar_t *dstBuffer, bsl::size_t dstCapacity, const char *srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numWordsWritten=0, wchar_t errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numWordsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstBuffer</code> of the specified <code>dstCapacity</code>, the result of converting the specified UTF-8 <code>srcString</code> to its UTF-16 equivalent. Optionally specify <code>numCharsWritten</code> which (if not 0) indicates the location of the variable into which the number of UTF-16 characters (including the terminating 0) written is to be loaded. Optionally specify <code>numWordsWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of <code>short</code> <em>memory words</em> written (including the null terminator) is to be loaded. Optionally specify an <code>errorCharacter</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are multi-byte encoding parts out of sequence, non-minimal UTF-8 encodings of characters, or characters outside the ranges which UTF-16 can validly encode (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xde00 .. 0x10ffff ]</code>). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 output; if <code>byteOrder</code> is not specified, the output is assumed to be in host byte order. If <code>errorCharacter</code> is 0, invalid input characters are ignored (i.e., produce no corresponding output characters). Return 0 on success and a bit-wise or of the bits specified by <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2d">CharConvertStatus::Enum</a></code> otherwise to indicate that there were invalid character sequences or if <code>dstCapacity</code> was inadequate to store the output. If <code>dstCapacity &gt; 0</code> yet <code>dstCapacity</code> specifies a buffer too small to hold the output, the maximal null-terminated prefix of the properly converted result string is loaded into <code>dstBuffer</code>. The behavior is undefined unless <code>dstBuffer</code>, if specified, refers to an array of at least <code>dstCapacity</code> elements, <code>errorCharacter</code> is either 0 or a valid single-word encoded UTF-16 character (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0xffff ]</code>), and <code>srcString</code> is null-terminated if supplied as a <code>const char *</code>. Note that if <code>dstCapacity</code> is 0, <code>*dstBuffer</code> is not modified and this function returns a value with <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> set and 0 is written into <code>*numCharsWritten</code> and <code>*numWordsWritten</code> (if those pointers are non-null), since there is insufficient space for even a null terminator alone. Also note that one <em>character</em> can occupy multiple 16-bit <em>words</em>, so that <code>*numWordsWritten</code> may be greater than <code>*numCharsWritten</code>, and therefore that an input <code>srcString</code> of <code>dstCapacity</code> <em>characters</em> may not fit into <code>dstBuffer</code>. However, an input <code>srcString</code> of <code>dstCapacity</code> <em>bytes</em> (including terminating 0, if present) will always fit (since the UTF-8 encoding of a character requires at least as many bytes as the UTF-16 encoding requires words). Also note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded null bytes which will be translated to null characters embedded in the output. </p>

</div>
</div>
<a class="anchor" id="a914ab31260aa95b1f3de35111b7b43fa"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="a914ab31260aa95b1f3de35111b7b43fa" args="(bsl::string *dstString, const unsigned short *srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>dstString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstString</code> the result of converting the specified null-terminated UTF-16 <code>*srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCharsWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of Unicode <em>characters</em> written, including the null terminator, is to be loaded, where one <em>character</em> may occupy multiple <em>bytes</em>. Optionally specify an <code>errorCharacter</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorCharacter</code> is 0, invalid input characters are ignored (i.e., produce no corresponding output characters). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Any previous contents of the destination are discarded. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dab425e720aac8ed4709123fa3e376eb4e">CharConvertStatus::k_INVALID_CHARS_BIT</a></code> if one or more invalid character sequences were encountered in the input. The behavior is undefined unless <code>srcString</code> is null-terminated and <code>errorCharacter</code> is either 0 or a valid single-byte encoded UTF-8 character (<code>0 &lt; errorCharacter &lt; 0x80</code>). Note that the string length will be sized to the length of the output, such that <code>strlen(dstString-&gt;c_str()) == dstString-&gt;length()</code>. </p>

</div>
</div>
<a class="anchor" id="aaa7f2e8614f8737f485eb4b8ef3f47d0"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="aaa7f2e8614f8737f485eb4b8ef3f47d0" args="(bsl::string *dstString, const bslstl::StringRefWide &amp;srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>dstString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ee957d799b50fb95c831a130f87950a"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="a0ee957d799b50fb95c831a130f87950a" args="(bsl::string *dstString, const wchar_t *srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>dstString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstString</code> the result of converting the specified UTF-16 <code>srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCharsWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of Unicode <em>characters</em> written, including the null terminator, is to be loaded, where one <em>character</em> may occupy multiple <em>bytes</em>. Optionally specify an <code>errorCharacter</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorCharacter</code> is 0, invalid input characters are ignored (i.e., produce no corresponding output characters). Any previous contents of the destination are discarded. Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dab425e720aac8ed4709123fa3e376eb4e">CharConvertStatus::k_INVALID_CHARS_BIT</a></code> if one or more invalid character sequences were encountered in the input. The behavior is undefined unless <code>errorCharacter</code> is either 0 or a valid single-byte encoded UTF-8 character (<code>0 &lt; errorCharacter &lt; 0x80</code>) and <code>srcString</code> is null-terminated if supplied as a <code>const wchar_t *</code>. Note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#adb41ff59615d4ad2799e48a19ed5c1b1">bslstl::StringRefWide</a></code>, it may contain embedded 0 words which will be translated to null characters embedded in the output. </p>

</div>
</div>
<a class="anchor" id="a6c1b1e614ce5af209fc628247be3b428"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="a6c1b1e614ce5af209fc628247be3b428" args="(bsl::vector&lt; char &gt; *dstVector, const unsigned short *srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstVector</code> the result of converting the specified null-terminated UTF-16 <code>*srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCharsWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of Unicode <em>characters</em> written, including the null terminator, is to be loaded, where one <em>character</em> may occupy multiple <em>bytes</em>. Optionally specify an <code>errorCharacter</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorCharacter</code> is 0, invalid input characters are ignored (i.e., produce no corresponding output characters). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Any previous contents of the destination are discarded. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dab425e720aac8ed4709123fa3e376eb4e">CharConvertStatus::k_INVALID_CHARS_BIT</a></code> if one or more invalid character sequences were encountered in the input. The behavior is undefined unless <code>srcString</code> is null-terminated and <code>errorCharacter</code> is either 0 or a valid single-byte encoded UTF-8 character (<code>0 &lt; errorCharacter &lt; 0x80</code>). </p>

</div>
</div>
<a class="anchor" id="afc62afff05eae27b2f71fa47dd5f4bf7"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="afc62afff05eae27b2f71fa47dd5f4bf7" args="(bsl::vector&lt; char &gt; *dstVector, const bslstl::StringRefWide &amp;srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e3d88d4be001f689c64635e66874faa"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="a7e3d88d4be001f689c64635e66874faa" args="(bsl::vector&lt; char &gt; *dstVector, const wchar_t *srcString, bsl::size_t *numCharsWritten=0, char errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstVector</code> the result of converting the specified UTF-16 <code>srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCharsWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of Unicode <em>characters</em> written, including the null terminator, is to be loaded, where one <em>character</em> may occupy multiple <em>bytes</em>. Optionally specify an <code>errorCharacter</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorCharacter</code> is 0, invalid input characters are ignored (i.e., produce no corresponding output characters). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Any previous contents of the destination are discarded. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dab425e720aac8ed4709123fa3e376eb4e">CharConvertStatus::k_INVALID_CHARS_BIT</a></code> if one or more invalid character sequences were encountered in the input. The behavior is undefined unless <code>errorCharacter</code> is either 0 or a valid single-byte encoded UTF-8 character (<code>0 &lt; errorCharacter &lt; 0x80</code>) and <code>srcString</code> is null-terminated if supplied as a <code>const wchar_t *</code>. Note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded 0 words which will be translated to null characters embedded in the output. </p>

</div>
</div>
<a class="anchor" id="a31ed917ebd308f647382666b0c55e30c"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="a31ed917ebd308f647382666b0c55e30c" args="(char *dstBuffer, bsl::size_t dstCapacity, const unsigned short *srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numBytesWritten=0, char errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numBytesWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>dstBuffer</code> of the specified <code>dstCapacity</code>, the result of converting the specified null-terminated UTF-16 <code>*srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCharsWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of Unicode <em>characters</em> (including the terminating 0, if any) written is to be loaded, where one <em>character</em> can occupy multiple <em>bytes</em>. Optionally specify <code>numBytesWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of bytes written (including the null terminator, if any) is to be loaded. Optionally specify an <code>errorCharacter</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorCharacter</code> is 0, invalid input characters are ignored (i.e., produce no corresponding output characters). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Return 0 on success and a bitwise-or of the masks defined by <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2d">CharConvertStatus::Enum</a></code> otherwise, where <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dab425e720aac8ed4709123fa3e376eb4e">CharConvertStatus::k_INVALID_CHARS_BIT</a></code> will be set if one or more invalid character sequences were encountered in the input, and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> will be set if the output space was exhausted before conversion was complete. The behavior is undefined unless <code>dstBuffer</code> refers to an array of at least <code>dstCapacity</code> elements, <code>srcString</code> is null-terminated, and <code>errorCharacter</code> is either 0 or a valid single-byte encoded UTF-8 character (<code>0 &lt; errorCharacter &lt; 0x80</code>). Note that if <code>dstCapacity</code> is 0, this function returns <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> set and 0 is written into <code>*numCharsWritten</code> and <code>*numBytesWritten</code> (if those pointers are non-null), since there is insufficient space for even a null terminator alone. Also note that since UTF-8 is a variable-length encoding, <code>numBytesWritten</code> may be up to four times <code>numCharsWritten</code>, and therefore that an input <code>srcString</code> of <code>dstCapacity</code> <em>characters</em> (including the terminating 0) may not fit into <code>dstBuffer</code>. A one-word (two-byte) UTF-16 character will require one to three UTF-8 octets (bytes); a two-word (four-byte) UTF-16 character will always require four UTF-8 octets. Also note that the amount of room needed will vary with the contents of the data and the language being translated, but never will the number of <em>bytes</em> output exceed three times the number of <em>short words</em> input. Also note that, if <code>dstCapacity &gt; 0</code>, then, after completion, <code>strlen(dstBuffer) + 1 == *numBytesWritten</code>. </p>

</div>
</div>
<a class="anchor" id="a0719afa799c45736357abc0d314ea392"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="a0719afa799c45736357abc0d314ea392" args="(char *dstBuffer, bsl::size_t dstCapacity, const bslstl::StringRefWide &amp;srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numBytesWritten=0, char errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numBytesWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6aab34549423d31e28387a4d84373084"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="a6aab34549423d31e28387a4d84373084" args="(char *dstBuffer, bsl::size_t dstCapacity, const wchar_t *srcString, bsl::size_t *numCharsWritten=0, bsl::size_t *numBytesWritten=0, char errorCharacter= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCharsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numBytesWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorCharacter</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>dstBuffer</code> of the specified <code>dstCapacity</code>, the result of converting the specified UTF-16 <code>srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCharsWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of Unicode <em>characters</em> (including the terminating 0, if any) written is to be loaded, where one <em>character</em> can occupy multiple <em>bytes</em>. Optionally specify <code>numBytesWritten</code> which (if not 0) indicates the location of the modifiable variable into which the number of bytes written (including the null terminator, if any) is to be loaded. Optionally specify an <code>errorCharacter</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorCharacter</code> is 0, invalid input characters are ignored (i.e., produce no corresponding output characters). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Return 0 on success and a bitwise-or of the flags defined by <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2d">CharConvertStatus::Enum</a></code> otherwise. <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dab425e720aac8ed4709123fa3e376eb4e">CharConvertStatus::k_INVALID_CHARS_BIT</a></code> will be set if one or more invalid character sequences were encountered in the input, and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> will be set if the output space was exhausted before conversion was complete. The behavior is undefined unless <code>dstBuffer</code> refers to an array of at least <code>dstCapacity</code> elements, <code>errorCharacter</code> is either 0 or a valid single-byte encoded UTF-8 character (<code>0 &lt; errorCharacter &lt; 0x80</code>), and <code>srcString</code> is null-terminated if supplied as a <code>const wchar_t *</code>. Note that if <code>dstCapacity</code> is 0, this function returns <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> set and 0 is written into <code>*numCharsWritten</code> and <code>*numBytesWritten</code> (if those pointers are non-null), since there is insufficient space for even a null terminator alone. Also note that since UTF-8 is a variable-length encoding, <code>numBytesWritten</code> may be up to four times <code>numCharsWritten</code>, and therefore that an input <code>srcString</code> of <code>dstCapacity</code> <em>characters</em> (including the terminating 0, if present) may not fit into <code>dstBuffer</code>. A one-word (two-byte) UTF-16 character will require one to three UTF-8 octets (bytes); a two-word (four-byte) UTF-16 character will always require four UTF-8 octets. Also note that the amount of room needed will vary with the contents of the data and the language being translated, but never will the number of <em>bytes</em> output exceed three times the number of *short words* input. Also note that, if <code>dstCapacity &gt; 0</code>, then, after completion, <code>strlen(dstBuffer) + 1 == *numBytesWritten</code>. Also note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded 0 words which will be translated to null characters embedded in the output. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bdlde__charconvertutf16_8h_source.html">bdlde_charconvertutf16.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:40 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
