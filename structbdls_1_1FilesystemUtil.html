<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Struct bdls::FilesystemUtil</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdls.html">bdls</a>      </li>
      <li><a class="el" href="structbdls_1_1FilesystemUtil.html">bdls::FilesystemUtil</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<h1>bdls::FilesystemUtil Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdls::FilesystemUtil" -->
<p><code>#include &lt;<a class="el" href="bdls__filesystemutil_8h_source.html">bdls_filesystemutil.h</a>&gt;</code></p>

<p><a href="structbdls_1_1FilesystemUtil-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a58bf107a8193356bdedef8cd4f113c58">Whence</a> { <a class="el" href="structbdls_1_1FilesystemUtil.html#a58bf107a8193356bdedef8cd4f113c58a66812b6ca9deb161d284d1c0b79623d5">e_SEEK_FROM_BEGINNING</a> =  0, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#a58bf107a8193356bdedef8cd4f113c58a205150e726a7864811d00d41b8a7aad9">e_SEEK_FROM_CURRENT</a> =  1, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#a58bf107a8193356bdedef8cd4f113c58a1ce8f2d753a1b90f618d33cd16faf79b">e_SEEK_FROM_END</a> =  2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structbdls_1_1FilesystemUtil.html#aa022326552362820851c9e933a1ce16fa4c737ba4540e64b6f23c0a5e97b8b8b0">k_DEFAULT_FILE_GROWTH_INCREMENT</a> =  65536
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structbdls_1_1FilesystemUtil.html#a07d703e938149eaf211611a29994b9daa9caf9d8808fff857e210fb698a84164f">k_ERROR_LOCKING_CONFLICT</a> =  1, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#a07d703e938149eaf211611a29994b9daa2102f87be97d5f80fc942329c2eeaaa4">k_BAD_FILE_DESCRIPTOR</a> =  -1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">FileOpenPolicy</a> { <a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3ba7114b36af4dfaace24aa27a575b1d7d1">e_OPEN</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3ba5f3858914719d2049f7b07b7bd2933fb">e_CREATE</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3baba2fe73a44186f61aff5f6c4fded38ba">e_OPEN_OR_CREATE</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">FileIOPolicy</a> { <br/>
&nbsp;&nbsp;<a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908a2731e60ab78302664a9bb939282f2f7d">e_READ_ONLY</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908a6ec4f46eed129ea073804985cdcf78ae">e_WRITE_ONLY</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908a698c0294cc81e95320fabf4ecbdb93d9">e_APPEND_ONLY</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908a2ffe2d27677b466194b884c43690fa56">e_READ_WRITE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908abb3f4c66dcdae74a34dca657522a33e7">e_READ_APPEND</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">FileTruncatePolicy</a> { <a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27a655b834e46a2587a51933afdf5c89ad3">e_TRUNCATE</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27aac93bd7d2d50a9b48d8d6c38bdac53ea">e_KEEP</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef off64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ac68835c410c78ead136a647058738062">open</a> (const char *path, <a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">FileOpenPolicy</a> openPolicy, <a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">FileIOPolicy</a> ioPolicy, <a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">FileTruncatePolicy</a> truncatePolicy=e_KEEP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a9fcd2d3f34f074b3b7be5623eb3203af">open</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, <a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">FileOpenPolicy</a> openPolicy, <a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">FileIOPolicy</a> ioPolicy, <a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">FileTruncatePolicy</a> truncatePolicy=e_KEEP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a9857925958dae54768746c017ea35d3f">close</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a478afba224e4ccf6a17fb8041dfc9268">getWorkingDirectory</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a6447c46c773acef5c45f893be7130d43">setWorkingDirectory</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a07cf457be848ba3095a387ee56a77e77">setWorkingDirectory</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a6a5769072861d4afd4d279377cfbeaf9">exists</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a9c02c1ff06ffb8f48bafaf3bc3d05bb1">exists</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ac810127967fda609116beb43189135a5">isRegularFile</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, bool followLinksFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a299e4b323bf4ce59cc05f8e060b2bc09">isRegularFile</a> (const char *path, bool followLinksFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a8fbf125093c50c3fd71d5efe00621843">isDirectory</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, bool followLinksFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aaa85f39d76a05927a03d2ab9a4c060b7">isDirectory</a> (const char *path, bool followLinksFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a92ecfdd7a6fbecaabb7a4ff218058b9b">getLastModificationTime</a> (<a class="el" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> *time, const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ac3144f9ffdb5975a7c442345d8a33286">getLastModificationTime</a> (<a class="el" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> *time, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#acee8e6117d6907d4fd6f2725e098f9ae">createDirectories</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, bool isLeafDirectoryFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a20d68d8eb8c6b5cab43754d3d0606932">createDirectories</a> (const char *path, bool isLeafDirectoryFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ac2624b29e9562de9b813e432d35ab1cc">visitPaths</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a68525ed232c20371319d1abd46a330d7">visitPaths</a> (const char *pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aeaff1fd7c247091e669bfdb6f0654c4f">findMatchingPaths</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &gt; *result, const char *pattern)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a88bb46abc6dd65ed3d5bb42c997b614c">getAvailableSpace</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a8c6cfe997793e8dca74ead92307f72f9">getAvailableSpace</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a905d89507296e671d83736fd1e68b04a">getAvailableSpace</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a2fd441b1e0edbb5f31cd2259559d8607">getFileSize</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#abfd91f2cc2315d5a5f3130dad6212627">getFileSize</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a9e1cdfc1d899b484b0a851d3b58f8056">getFileSizeLimit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a5aefcccfd061efa182d86cae61ba8cac">lock</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, bool lockWriteFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#acef17924a4a6bd1600dd7a1cef9f3ec8">tryLock</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, bool lockWriteFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ad6cc8d4dfa44a8a5ccb95e8b60b112a4">unlock</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a4c0cfd2fd52c49393845a87932ab7e86">map</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, void **address, <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> offset, int size, int mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a103e4024d8f8091b0c563416980d1ab4">unmap</a> (void *address, int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aa858002e1614eb830f1c78cfc8a3b1c6">sync</a> (char *address, int numBytes, bool syncFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab26712088ebce2519f7b5e7396e1436a">seek</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> offset, int whence)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a160d397df5ff5df49fd93a8560acbf99">read</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, void *buffer, int numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aec68946bf27cba1c0aadf32b9e47fd4f">remove</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, bool recursiveFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#afb060aeb3b2c9776bdf3412c860341a9">remove</a> (const char *path, bool recursiveFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a095e12d100d235c503f242e38632c793">rollFileChain</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, int maxSuffix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a5a7ba7c7fc6ed2ac6eeb728067493b89">rollFileChain</a> (const char *path, int maxSuffix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a67adb857280699a27c26153b9146e702">move</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;oldPath, const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;newPath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ad804cd9857919e82d9dded54e6dfefc2">move</a> (const char *oldPath, const char *newPath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#abc5fe7e103cd5035f4e2cd2d71f51676">write</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, const void *buffer, int numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aec34a82f2a4824a17e0728450e6578e6">growFile</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> size, bool reserveFlag=false, bsl::size_t increment=k_DEFAULT_FILE_GROWTH_INCREMENT)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a20f0a6a45e778c787ea12fb5f5b140c9">k_OFFSET_MAX</a> = (9223372036854775807LL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a750eef508b438afee8674462c7612a29">k_OFFSET_MIN</a> = (-9223372036854775807LL-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">k_INVALID_FD</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for utility functions dealing with platform-independent filesystem access. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="af177603b027970757c45b67984235d36"></a><!-- doxytag: member="bdls::FilesystemUtil::FileDescriptor" ref="af177603b027970757c45b67984235d36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">bdls::FilesystemUtil::FileDescriptor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab783252d8c9d7d97680f2a371e402acc"></a><!-- doxytag: member="bdls::FilesystemUtil::Offset" ref="ab783252d8c9d7d97680f2a371e402acc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef off64_t <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">bdls::FilesystemUtil::Offset</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a58bf107a8193356bdedef8cd4f113c58"></a><!-- doxytag: member="bdls::FilesystemUtil::Whence" ref="a58bf107a8193356bdedef8cd4f113c58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbdls_1_1FilesystemUtil.html#a58bf107a8193356bdedef8cd4f113c58">bdls::FilesystemUtil::Whence</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumeration used to distinguish among different starting points for a seek operation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a58bf107a8193356bdedef8cd4f113c58a66812b6ca9deb161d284d1c0b79623d5"></a><!-- doxytag: member="e_SEEK_FROM_BEGINNING" ref="a58bf107a8193356bdedef8cd4f113c58a66812b6ca9deb161d284d1c0b79623d5" args="" -->e_SEEK_FROM_BEGINNING</em>&nbsp;</td><td>
<p>Seek from beginning of file. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a58bf107a8193356bdedef8cd4f113c58a205150e726a7864811d00d41b8a7aad9"></a><!-- doxytag: member="e_SEEK_FROM_CURRENT" ref="a58bf107a8193356bdedef8cd4f113c58a205150e726a7864811d00d41b8a7aad9" args="" -->e_SEEK_FROM_CURRENT</em>&nbsp;</td><td>
<p>Seek from current position. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a58bf107a8193356bdedef8cd4f113c58a1ce8f2d753a1b90f618d33cd16faf79b"></a><!-- doxytag: member="e_SEEK_FROM_END" ref="a58bf107a8193356bdedef8cd4f113c58a1ce8f2d753a1b90f618d33cd16faf79b" args="" -->e_SEEK_FROM_END</em>&nbsp;</td><td>
<p>Seek from end of file. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa022326552362820851c9e933a1ce16f"></a><!-- doxytag: member="bdls::FilesystemUtil::@219" ref="aa022326552362820851c9e933a1ce16f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa022326552362820851c9e933a1ce16fa4c737ba4540e64b6f23c0a5e97b8b8b0"></a><!-- doxytag: member="k_DEFAULT_FILE_GROWTH_INCREMENT" ref="aa022326552362820851c9e933a1ce16fa4c737ba4540e64b6f23c0a5e97b8b8b0" args="" -->k_DEFAULT_FILE_GROWTH_INCREMENT</em>&nbsp;</td><td>
<p>default block size by which to grow files </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a07d703e938149eaf211611a29994b9da"></a><!-- doxytag: member="bdls::FilesystemUtil::@220" ref="a07d703e938149eaf211611a29994b9da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a07d703e938149eaf211611a29994b9daa9caf9d8808fff857e210fb698a84164f"></a><!-- doxytag: member="k_ERROR_LOCKING_CONFLICT" ref="a07d703e938149eaf211611a29994b9daa9caf9d8808fff857e210fb698a84164f" args="" -->k_ERROR_LOCKING_CONFLICT</em>&nbsp;</td><td>
<p>value representing a failure to obtain a lock on a file </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a07d703e938149eaf211611a29994b9daa2102f87be97d5f80fc942329c2eeaaa4"></a><!-- doxytag: member="k_BAD_FILE_DESCRIPTOR" ref="a07d703e938149eaf211611a29994b9daa2102f87be97d5f80fc942329c2eeaaa4" args="" -->k_BAD_FILE_DESCRIPTOR</em>&nbsp;</td><td>
<p>value indicating a bad file descriptor was supplied </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf288297e2a9b65fdcdd18c2aec66c3b"></a><!-- doxytag: member="bdls::FilesystemUtil::FileOpenPolicy" ref="aaf288297e2a9b65fdcdd18c2aec66c3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">bdls::FilesystemUtil::FileOpenPolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumeration used to determine whether <code>open</code> should open an existing file, or create a new file. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aaf288297e2a9b65fdcdd18c2aec66c3ba7114b36af4dfaace24aa27a575b1d7d1"></a><!-- doxytag: member="e_OPEN" ref="aaf288297e2a9b65fdcdd18c2aec66c3ba7114b36af4dfaace24aa27a575b1d7d1" args="" -->e_OPEN</em>&nbsp;</td><td>
<p>Open a file if it exists, and fail otherwise. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aaf288297e2a9b65fdcdd18c2aec66c3ba5f3858914719d2049f7b07b7bd2933fb"></a><!-- doxytag: member="e_CREATE" ref="aaf288297e2a9b65fdcdd18c2aec66c3ba5f3858914719d2049f7b07b7bd2933fb" args="" -->e_CREATE</em>&nbsp;</td><td>
<p>Create a new file, and fail if the file already exists. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aaf288297e2a9b65fdcdd18c2aec66c3baba2fe73a44186f61aff5f6c4fded38ba"></a><!-- doxytag: member="e_OPEN_OR_CREATE" ref="aaf288297e2a9b65fdcdd18c2aec66c3baba2fe73a44186f61aff5f6c4fded38ba" args="" -->e_OPEN_OR_CREATE</em>&nbsp;</td><td>
<p>Open a file if it exists, and create a new file otherwise. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ab79b11034df3e25311be375da986b908"></a><!-- doxytag: member="bdls::FilesystemUtil::FileIOPolicy" ref="ab79b11034df3e25311be375da986b908" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">bdls::FilesystemUtil::FileIOPolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumeration used to distinguish between different sets of actions permitted on an open file descriptor. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab79b11034df3e25311be375da986b908a2731e60ab78302664a9bb939282f2f7d"></a><!-- doxytag: member="e_READ_ONLY" ref="ab79b11034df3e25311be375da986b908a2731e60ab78302664a9bb939282f2f7d" args="" -->e_READ_ONLY</em>&nbsp;</td><td>
<p>Allow reading only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab79b11034df3e25311be375da986b908a6ec4f46eed129ea073804985cdcf78ae"></a><!-- doxytag: member="e_WRITE_ONLY" ref="ab79b11034df3e25311be375da986b908a6ec4f46eed129ea073804985cdcf78ae" args="" -->e_WRITE_ONLY</em>&nbsp;</td><td>
<p>Allow writing only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab79b11034df3e25311be375da986b908a698c0294cc81e95320fabf4ecbdb93d9"></a><!-- doxytag: member="e_APPEND_ONLY" ref="ab79b11034df3e25311be375da986b908a698c0294cc81e95320fabf4ecbdb93d9" args="" -->e_APPEND_ONLY</em>&nbsp;</td><td>
<p>Allow appending to end-of-file only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab79b11034df3e25311be375da986b908a2ffe2d27677b466194b884c43690fa56"></a><!-- doxytag: member="e_READ_WRITE" ref="ab79b11034df3e25311be375da986b908a2ffe2d27677b466194b884c43690fa56" args="" -->e_READ_WRITE</em>&nbsp;</td><td>
<p>Allow both reading and writing. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab79b11034df3e25311be375da986b908abb3f4c66dcdae74a34dca657522a33e7"></a><!-- doxytag: member="e_READ_APPEND" ref="ab79b11034df3e25311be375da986b908abb3f4c66dcdae74a34dca657522a33e7" args="" -->e_READ_APPEND</em>&nbsp;</td><td>
<p>Allow both reading and appending to end-of-file. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c2d86c5eb644a39e3a40cc5594b3b27"></a><!-- doxytag: member="bdls::FilesystemUtil::FileTruncatePolicy" ref="a8c2d86c5eb644a39e3a40cc5594b3b27" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">bdls::FilesystemUtil::FileTruncatePolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumeration used to distinguish between different ways to handle the contents, if any, of an existing file immediately upon opening the file. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8c2d86c5eb644a39e3a40cc5594b3b27a655b834e46a2587a51933afdf5c89ad3"></a><!-- doxytag: member="e_TRUNCATE" ref="a8c2d86c5eb644a39e3a40cc5594b3b27a655b834e46a2587a51933afdf5c89ad3" args="" -->e_TRUNCATE</em>&nbsp;</td><td>
<p>Delete the file's contents on open. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8c2d86c5eb644a39e3a40cc5594b3b27aac93bd7d2d50a9b48d8d6c38bdac53ea"></a><!-- doxytag: member="e_KEEP" ref="a8c2d86c5eb644a39e3a40cc5594b3b27aac93bd7d2d50a9b48d8d6c38bdac53ea" args="" -->e_KEEP</em>&nbsp;</td><td>
<p>Keep the file's contents. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac68835c410c78ead136a647058738062"></a><!-- doxytag: member="bdls::FilesystemUtil::open" ref="ac68835c410c78ead136a647058738062" args="(const char *path, FileOpenPolicy openPolicy, FileIOPolicy ioPolicy, FileTruncatePolicy truncatePolicy=e_KEEP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> bdls::FilesystemUtil::open </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">FileOpenPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>openPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">FileIOPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ioPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">FileTruncatePolicy</a>&nbsp;</td>
          <td class="paramname"> <em>truncatePolicy</em> = <code>e_KEEP</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9fcd2d3f34f074b3b7be5623eb3203af"></a><!-- doxytag: member="bdls::FilesystemUtil::open" ref="a9fcd2d3f34f074b3b7be5623eb3203af" args="(const bsl::string &amp;path, FileOpenPolicy openPolicy, FileIOPolicy ioPolicy, FileTruncatePolicy truncatePolicy=e_KEEP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> bdls::FilesystemUtil::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">FileOpenPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>openPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">FileIOPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ioPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">FileTruncatePolicy</a>&nbsp;</td>
          <td class="paramname"> <em>truncatePolicy</em> = <code>e_KEEP</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open the file at the specified <code>path</code>, using the specified <code>openPolicy</code> to determine whether to open an existing file or create a new file, and using the specified <code>ioPolicy</code> to determine whether the file will be opened for reading, writing, or both. Optionally specify a <code>truncatePolicy</code> to determine whether any contents of the file will be deleted before <code>open</code> returns. If <code>truncatePolicy</code> is not supplied, the value <code>e_KEEP</code> will be used. Return a valid <code>FileDescriptor</code> for the file on success, or <code>k_INVALID_FD</code> otherwise. If <code>openPolicy</code> is <code>e_OPEN</code>, the file will be opened if it exists, and <code>open</code> will fail otherwise. If <code>openPolicy</code> is <code>e_CREATE</code>, and no file exists at <code>path</code>, a new file will be created, and <code>open</code> will fail otherwise. If <code>openPolicy</code> is <code>e_OPEN_OR_CREATE</code>, the file will be opened if it exists, and a new file will be created otherwise. If <code>ioPolicy</code> is <code>e_READ_ONLY</code>, the returned <code>FileDescriptor</code> will allow only read operations on the file. If <code>ioPolicy</code> is <code>e_WRITE_ONLY</code> or <code>e_APPEND_ONLY</code>, the returned <code>FileDescriptor</code> will allow only write operations on the file. If <code>ioPolicy</code> is <code>e_READ_WRITE</code> or <code>e_READ_APPEND</code>, the returned <code>FileDescriptor</code> will allow both read and write operations on the file. Additionally, if <code>ioPolicy</code> is <code>e_APPEND_ONLY</code> or <code>e_READ_APPEND</code> all writes will be made to the end of the file ("append mode"). If <code>truncatePolicy</code> is <code>e_TRUNCATE</code>, the file will have zero length when <code>open</code> returns. If <code>truncatePolicy</code> is <code>e_KEEP</code>, the file will be opened with its existing contents, if any. Note that when a file is opened in <code>append</code> mode, all writes will go to the end of the file, even if there has been seeking on the file descriptor or another process has changed the length of the file, though append-mode writes are not guaranteed to be atomic. Note that <code>open</code> will fail to open a file with a <code>truncatePolicy</code> of <code>e_TRUNCATE</code> unless at least one of the following policies is specified for <code>openPolicy</code> or <code>ioPolicy</code>: </p>
<ul>
<li>
<code>e_CREATE</code>  </li>
<li>
<code>e_OPEN_OR_CREATE</code>  </li>
<li>
'e_WRITE_ONLY  </li>
<li>
<code>e_READ_WRITE</code>  </li>
</ul>

</div>
</div>
<a class="anchor" id="a9857925958dae54768746c017ea35d3f"></a><!-- doxytag: member="bdls::FilesystemUtil::close" ref="a9857925958dae54768746c017ea35d3f" args="(FileDescriptor descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the specified <code>descriptor</code>. Return 0 on success and a non-zero value otherwise. A return value of <code>k_BAD_FILE_DESCRIPTOR</code> indicates that the supplied <code>descriptor</code> is invalid. </p>

</div>
</div>
<a class="anchor" id="a478afba224e4ccf6a17fb8041dfc9268"></a><!-- doxytag: member="bdls::FilesystemUtil::getWorkingDirectory" ref="a478afba224e4ccf6a17fb8041dfc9268" args="(bsl::string *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::getWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>path</code> the absolute pathname of the current working directory. Return 0 on success and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a6447c46c773acef5c45f893be7130d43"></a><!-- doxytag: member="bdls::FilesystemUtil::setWorkingDirectory" ref="a6447c46c773acef5c45f893be7130d43" args="(const bsl::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::setWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a07cf457be848ba3095a387ee56a77e77"></a><!-- doxytag: member="bdls::FilesystemUtil::setWorkingDirectory" ref="a07cf457be848ba3095a387ee56a77e77" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::setWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the working directory of the current process to the specified <code>path</code>. Return 0 on success and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a6a5769072861d4afd4d279377cfbeaf9"></a><!-- doxytag: member="bdls::FilesystemUtil::exists" ref="a6a5769072861d4afd4d279377cfbeaf9" args="(const bsl::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c02c1ff06ffb8f48bafaf3bc3d05bb1"></a><!-- doxytag: member="bdls::FilesystemUtil::exists" ref="a9c02c1ff06ffb8f48bafaf3bc3d05bb1" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::exists </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if there currently exists a file or directory at the specified <code>path</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ac810127967fda609116beb43189135a5"></a><!-- doxytag: member="bdls::FilesystemUtil::isRegularFile" ref="ac810127967fda609116beb43189135a5" args="(const bsl::string &amp;path, bool followLinksFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::isRegularFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>followLinksFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a299e4b323bf4ce59cc05f8e060b2bc09"></a><!-- doxytag: member="bdls::FilesystemUtil::isRegularFile" ref="a299e4b323bf4ce59cc05f8e060b2bc09" args="(const char *path, bool followLinksFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::isRegularFile </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>followLinksFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if there currently exists a regular file at the specified <code>path</code>, and <code>false</code> otherwise. If there is a symbolic link at <code>path</code>, follow it only if the optionally specified <code>followLinksFlag</code> is <code>true</code> (otherwise, return <code>false</code> as the symbolic link itself is not a regular file irrespective of the file to which it points). Platform-specific note: On POSIX, this is a positive test on the "regular file" mode; on Windows, this is a negative test on the "directory" attribute, i.e., on Windows, everything that exists and is not a directory is a regular file. </p>

</div>
</div>
<a class="anchor" id="a8fbf125093c50c3fd71d5efe00621843"></a><!-- doxytag: member="bdls::FilesystemUtil::isDirectory" ref="a8fbf125093c50c3fd71d5efe00621843" args="(const bsl::string &amp;path, bool followLinksFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::isDirectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>followLinksFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa85f39d76a05927a03d2ab9a4c060b7"></a><!-- doxytag: member="bdls::FilesystemUtil::isDirectory" ref="aaa85f39d76a05927a03d2ab9a4c060b7" args="(const char *path, bool followLinksFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::isDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>followLinksFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if there currently exists a directory at the specified <code>path</code>, and <code>false</code> otherwise. If there is a symbolic link at <code>path</code>, follow it only if the optionally specified <code>followLinksFlag</code> is <code>true</code> (otherwise return <code>false</code>). Platform-specific note: On Windows, a "shortcut" is not a symbolic link. </p>

</div>
</div>
<a class="anchor" id="a92ecfdd7a6fbecaabb7a4ff218058b9b"></a><!-- doxytag: member="bdls::FilesystemUtil::getLastModificationTime" ref="a92ecfdd7a6fbecaabb7a4ff218058b9b" args="(bdlt::Datetime *time, const bsl::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::getLastModificationTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> *&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac3144f9ffdb5975a7c442345d8a33286"></a><!-- doxytag: member="bdls::FilesystemUtil::getLastModificationTime" ref="ac3144f9ffdb5975a7c442345d8a33286" args="(bdlt::Datetime *time, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::getLastModificationTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> *&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>time</code> the last modification time of the file at the specified <code>path</code>, as reported by the filesystem. Return 0 on success, and a non-zero value otherwise. Note that the time is reported in UTC. </p>

</div>
</div>
<a class="anchor" id="acee8e6117d6907d4fd6f2725e098f9ae"></a><!-- doxytag: member="bdls::FilesystemUtil::createDirectories" ref="acee8e6117d6907d4fd6f2725e098f9ae" args="(const bsl::string &amp;path, bool isLeafDirectoryFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::createDirectories </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isLeafDirectoryFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a20d68d8eb8c6b5cab43754d3d0606932"></a><!-- doxytag: member="bdls::FilesystemUtil::createDirectories" ref="a20d68d8eb8c6b5cab43754d3d0606932" args="(const char *path, bool isLeafDirectoryFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::createDirectories </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isLeafDirectoryFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create any directories in the specified <code>path</code> that do not exist. If the optionally specified <code>isLeafDirectoryFlag</code> is <code>true</code>, then treat the last filename in <code>path</code> as a directory and attempt to create it. Otherwise, treat the last filename as a regular file and ignore it. Return 0 on success, and a non-zero value if any needed directories in <code>path</code> could not be created. Note that this function may return an error status if another task attempts to create a directory in <code>path</code> concurrently to this function call. </p>

</div>
</div>
<a class="anchor" id="ac2624b29e9562de9b813e432d35ab1cc"></a><!-- doxytag: member="bdls::FilesystemUtil::visitPaths" ref="ac2624b29e9562de9b813e432d35ab1cc" args="(const bsl::string &amp;pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdls::FilesystemUtil::visitPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void(const char *path)&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a68525ed232c20371319d1abd46a330d7"></a><!-- doxytag: member="bdls::FilesystemUtil::visitPaths" ref="a68525ed232c20371319d1abd46a330d7" args="(const char *pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdls::FilesystemUtil::visitPaths </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void(const char *path)&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call the specified <code>visitor</code> functor for each path in the filesystem matching the specified <code>pattern</code>. If <code>visitor</code> deletes files or directories during the search, the behavior is implementation-dependent: <code>visitor</code> may subsequently be called with paths which have already been deleted, or it may not. Note that there is no stability risk in that case. See <code>findMatchingPaths</code> for a discussion of how <code>pattern</code> is interpreted. </p>

</div>
</div>
<a class="anchor" id="aeaff1fd7c247091e669bfdb6f0654c4f"></a><!-- doxytag: member="bdls::FilesystemUtil::findMatchingPaths" ref="aeaff1fd7c247091e669bfdb6f0654c4f" args="(bsl::vector&lt; bsl::string &gt; *result, const char *pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdls::FilesystemUtil::findMatchingPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pattern</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> vector all paths in the filesystem matching the specified <code>pattern</code>. The <code>*</code> character will match any number of characters in a filename; however, this matching will not span a directory separator (e.g., "logs/m*.txt" will not match "logs/march/001.txt"). <code>?</code> will match any one character. <code>*</code> and <code>?</code> may be used any number of times in the pattern. The special directories "." and ".." will not be matched against any pattern. Note that any initial contents of <code>result</code> will be erased, and that the paths in <code>result</code> will not be in any particular guaranteed order.</p>
<p>WINDOWS-SPECIFIC NOTE: To support DOS idioms, the OS-provided search function has behavior that we have chosen not to work around: an extension consisting of wild-card characters (<code>?</code>, <code>*</code>) can match an extension or <em>no</em> extension. E.g., "file.?" matches "file.z", but not "file.txt"; however, it also matches "file" (without any extension). Likewise, "*.*" matches any filename, including filenames having no extension. </p>

</div>
</div>
<a class="anchor" id="a88bb46abc6dd65ed3d5bb42c997b614c"></a><!-- doxytag: member="bdls::FilesystemUtil::getAvailableSpace" ref="a88bb46abc6dd65ed3d5bb42c997b614c" args="(const bsl::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getAvailableSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c6cfe997793e8dca74ead92307f72f9"></a><!-- doxytag: member="bdls::FilesystemUtil::getAvailableSpace" ref="a8c6cfe997793e8dca74ead92307f72f9" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getAvailableSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bytes available for allocation in the file system where the file or directory with the specified <code>path</code> resides, or a negative value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="a905d89507296e671d83736fd1e68b04a"></a><!-- doxytag: member="bdls::FilesystemUtil::getAvailableSpace" ref="a905d89507296e671d83736fd1e68b04a" args="(FileDescriptor descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getAvailableSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bytes available for allocation in the file system where the file with the specified <code>descriptor</code> resides, or a negative value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="a2fd441b1e0edbb5f31cd2259559d8607"></a><!-- doxytag: member="bdls::FilesystemUtil::getFileSize" ref="a2fd441b1e0edbb5f31cd2259559d8607" args="(const bsl::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getFileSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abfd91f2cc2315d5a5f3130dad6212627"></a><!-- doxytag: member="bdls::FilesystemUtil::getFileSize" ref="abfd91f2cc2315d5a5f3130dad6212627" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getFileSize </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the size, in bytes, of the file or directory at the specified <code>path</code>, or a negative value if an error occurs. Note that the size of a symbolic link is the size of the file or directory to which it points. </p>

</div>
</div>
<a class="anchor" id="a9e1cdfc1d899b484b0a851d3b58f8056"></a><!-- doxytag: member="bdls::FilesystemUtil::getFileSizeLimit" ref="a9e1cdfc1d899b484b0a851d3b58f8056" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getFileSizeLimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the file size limit for this process, <code>k_OFFSET_MAX</code> if no limit is set, or a negative value if an error occurs. Note that if you are doing any calculations involving the returned value, it is recommended to check for <code>k_OFFSET_MAX</code> specifically to avoid integer overflow in your calculations. </p>

</div>
</div>
<a class="anchor" id="a5aefcccfd061efa182d86cae61ba8cac"></a><!-- doxytag: member="bdls::FilesystemUtil::lock" ref="a5aefcccfd061efa182d86cae61ba8cac" args="(FileDescriptor descriptor, bool lockWriteFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lockWriteFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire a lock for the file with the specified <code>descriptor</code>. If <code>lockWriteFlag</code> is true, acquire an exclusive write lock; otherwise acquire a (possibly) shared read lock. The calling thread will block until the lock is acquired. Return 0 on success, and a non-zero value otherwise. Note that this operation locks the indicated file for use by the current <em>process</em>, but the behavior is unspecified (and platform-dependent) when either attempting to lock <code>descriptor</code> multiple times, or attempting to lock another descriptor referring to the same file, within a single process. </p>

</div>
</div>
<a class="anchor" id="acef17924a4a6bd1600dd7a1cef9f3ec8"></a><!-- doxytag: member="bdls::FilesystemUtil::tryLock" ref="acef17924a4a6bd1600dd7a1cef9f3ec8" args="(FileDescriptor descriptor, bool lockWriteFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::tryLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lockWriteFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire a lock for the file with the specified <code>descriptor</code> if it is currently available. If the specified <code>lockWriteFlag</code> is true, acquire an exclusive write lock unless another process has any type of lock on the file. If <code>lockWriteFlag</code> is false, acquire a shared read lock unless a process has a write lock. This method will not block. Return 0 on success, <code>k_ERROR_LOCKING_CONFLICT</code> if the platform reports the lock could not be acquired because another process holds a conflicting lock, and a negative value for any other kind of error. Note that this operation locks the indicated file for the current <em>process</em>, but the behavior is unspecified (and platform-dependent) when either attempting to lock <code>descriptor</code> multiple times, or attempting to lock another descriptor referring to the same file, within a single process. </p>

</div>
</div>
<a class="anchor" id="ad6cc8d4dfa44a8a5ccb95e8b60b112a4"></a><!-- doxytag: member="bdls::FilesystemUtil::unlock" ref="ad6cc8d4dfa44a8a5ccb95e8b60b112a4" args="(FileDescriptor descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release any lock this process holds on the file with the specified <code>descriptor</code>. Return 0 on success, and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a4c0cfd2fd52c49393845a87932ab7e86"></a><!-- doxytag: member="bdls::FilesystemUtil::map" ref="a4c0cfd2fd52c49393845a87932ab7e86" args="(FileDescriptor descriptor, void **address, Offset offset, int size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Map the region of the specified <code>size</code> bytes, starting at the specified <code>offset</code> bytes into the file with the specified <code>descriptor</code> to memory, and load into the specified <code>address</code> of the mapped area. Return 0 on success, and a non-zero value otherwise. The access permissions for mapping memory are defined by the specified <code>mode</code>, which may be a combination of <code><a class="el" href="structbdls_1_1MemoryUtil.html#a7367de98ca1d46c39f33eb99e3157bd3a487a5baded9415448e805f78ed74f31d">MemoryUtil::k_ACCESS_READ</a></code>, <code><a class="el" href="structbdls_1_1MemoryUtil.html#a7367de98ca1d46c39f33eb99e3157bd3aafbc14902cb796205b602885220a81bb">MemoryUtil::k_ACCESS_WRITE</a></code> and <code><a class="el" href="structbdls_1_1MemoryUtil.html#a7367de98ca1d46c39f33eb99e3157bd3a5235425b6994824cad7d4669618a1192">MemoryUtil::k_ACCESS_EXECUTE</a></code>. Note that on failure, the value of <code>address</code> is undefined. Also note that mapping will succeed even if there are fewer than <code>offset + size</code> bytes in the specified file, and an attempt to access the mapped memory beyond the end of the file will result in undefined behavior (i.e., this function does not grow the file to guarantee it can accommodate the mapped region). </p>

</div>
</div>
<a class="anchor" id="a103e4024d8f8091b0c563416980d1ab4"></a><!-- doxytag: member="bdls::FilesystemUtil::unmap" ref="a103e4024d8f8091b0c563416980d1ab4" args="(void *address, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::unmap </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unmap the memory mapping with the specified base <code>address</code> and specified <code>size</code>. Return 0 on success, and a non-zero value otherwise. The behavior is undefined unless this area with <code>address</code> and <code>size</code> was previously mapped with a <code>map</code> call. </p>

</div>
</div>
<a class="anchor" id="aa858002e1614eb830f1c78cfc8a3b1c6"></a><!-- doxytag: member="bdls::FilesystemUtil::sync" ref="aa858002e1614eb830f1c78cfc8a3b1c6" args="(char *address, int numBytes, bool syncFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::sync </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>syncFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronize the contents of the specified <code>numBytes</code> of mapped memory beginning at the specified <code>address</code> with the underlying file on disk. If the specified <code>syncFlag</code> is true, block until all writes to nonvolatile media have actually completed, otherwise, return once they have been scheduled. Return 0 on success, and a non-zero value otherwise. The behavior is undefined unless <code>address</code> is aligned on a page boundary, <code>numBytes</code> is a multiple of <code>pageSize()</code>, and <code>0 &lt;= numBytes</code>. </p>

</div>
</div>
<a class="anchor" id="ab26712088ebce2519f7b5e7396e1436a"></a><!-- doxytag: member="bdls::FilesystemUtil::seek" ref="ab26712088ebce2519f7b5e7396e1436a" args="(FileDescriptor descriptor, Offset offset, int whence)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>whence</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the file pointer associated with the specified <code>descriptor</code> (used by calls to the <code>read</code> and <code>write</code> system calls) according to the specified <code>whence</code> behavior: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment"> If <span class="stringliteral">&#39;whence&#39;</span> is e_SEEK_FROM_BEGINNING, <span class="keyword">set</span> the pointer to
             <span class="stringliteral">&#39;offset&#39;</span> bytes from the beginning of the file.
 If <span class="stringliteral">&#39;whence&#39;</span> is e_SEEK_FROM_CURRENT, advance the pointer by
             <span class="stringliteral">&#39;offset&#39;</span> bytes
 If <span class="stringliteral">&#39;whence&#39;</span> is e_SEEK_FROM_END, <span class="keyword">set</span> the pointer to <span class="stringliteral">&#39;offset&#39;</span>
             bytes beyond the end of the file.
</pre></div><p><br/>
<br/>
 Return the new location of the file pointer, in bytes from the beginning of the file, on success; and -1 otherwise. The effect on the file pointer is undefined unless the file is on a device capable of seeking. Note that <code>seek</code> does not change the size of the file if the pointer advances beyond the end of the file; instead, the next write at the pointer will increase the file size. </p>

</div>
</div>
<a class="anchor" id="a160d397df5ff5df49fd93a8560acbf99"></a><!-- doxytag: member="bdls::FilesystemUtil::read" ref="a160d397df5ff5df49fd93a8560acbf99" args="(FileDescriptor descriptor, void *buffer, int numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the specified <code>numBytes</code> bytes beginning at the file pointer of the file with the specified <code>descriptor</code> into the specified <code>bufffer</code>. Return <code>numBytes</code> on success; the number of bytes read if there were not enough available; or a negative number on some other error. </p>

</div>
</div>
<a class="anchor" id="aec68946bf27cba1c0aadf32b9e47fd4f"></a><!-- doxytag: member="bdls::FilesystemUtil::remove" ref="aec68946bf27cba1c0aadf32b9e47fd4f" args="(const bsl::string &amp;path, bool recursiveFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>recursiveFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afb060aeb3b2c9776bdf3412c860341a9"></a><!-- doxytag: member="bdls::FilesystemUtil::remove" ref="afb060aeb3b2c9776bdf3412c860341a9" args="(const char *path, bool recursiveFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::remove </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>recursiveFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the file or directory at the specified <code>path</code>. If the <code>path</code> refers to a directory and the optionally specified <code>recursiveFlag</code> is <code>true</code>, recursively remove all files and directories within the specified directory before removing the directory itself. Return 0 on success and a non-zero value otherwise. Note that if <code>path</code> is a directory, and the directory is not empty, and recursive is <code>false</code>, this method will fail. Also note that if the function fails when <code>recursive</code> is <code>true</code>, it may or may not have removed <em>some</em> files or directories before failing. </p>

</div>
</div>
<a class="anchor" id="a095e12d100d235c503f242e38632c793"></a><!-- doxytag: member="bdls::FilesystemUtil::rollFileChain" ref="a095e12d100d235c503f242e38632c793" args="(const bsl::string &amp;path, int maxSuffix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::rollFileChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSuffix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5a7ba7c7fc6ed2ac6eeb728067493b89"></a><!-- doxytag: member="bdls::FilesystemUtil::rollFileChain" ref="a5a7ba7c7fc6ed2ac6eeb728067493b89" args="(const char *path, int maxSuffix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::rollFileChain </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSuffix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the file at the specified <code>path</code> appended with the specified <code>maxSuffix</code> using a <code>.</code> as a separator. Then move the files with the suffixes <code>.1</code> to <code>.maxSuffix-1</code> so they have new suffixes from <code>.2</code> to <code>.maxSuffix</code>. Finally, move <code>path</code> to <code>path</code> with a <code>.1</code> suffix. Return 0 on success, and non-zero otherwise. </p>

</div>
</div>
<a class="anchor" id="a67adb857280699a27c26153b9146e702"></a><!-- doxytag: member="bdls::FilesystemUtil::move" ref="a67adb857280699a27c26153b9146e702" args="(const bsl::string &amp;oldPath, const bsl::string &amp;newPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad804cd9857919e82d9dded54e6dfefc2"></a><!-- doxytag: member="bdls::FilesystemUtil::move" ref="ad804cd9857919e82d9dded54e6dfefc2" args="(const char *oldPath, const char *newPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::move </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>newPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the file or directory at the specified <code>oldPath</code> to the specified <code>newPath</code>. If there is a file or directory at <code>newPath</code>, it will be removed and replaced. In that case, <code>newPath</code> must refer to the same type of filesystem item as <code>oldPath</code> - that is, they must both be directories or both be files. Return 0 on success, and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="abc5fe7e103cd5035f4e2cd2d71f51676"></a><!-- doxytag: member="bdls::FilesystemUtil::write" ref="abc5fe7e103cd5035f4e2cd2d71f51676" args="(FileDescriptor descriptor, const void *buffer, int numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>numBytes</code> from the specified <code>buffer</code> address to the file with the specified <code>descriptor</code>. Return <code>numBytes</code> on success; the number of bytes written if space was exhausted; or a negative value on some other error. </p>

</div>
</div>
<a class="anchor" id="aec34a82f2a4824a17e0728450e6578e6"></a><!-- doxytag: member="bdls::FilesystemUtil::growFile" ref="aec34a82f2a4824a17e0728450e6578e6" args="(FileDescriptor descriptor, Offset size, bool reserveFlag=false, bsl::size_t increment=k_DEFAULT_FILE_GROWTH_INCREMENT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::growFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reserveFlag</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>increment</em> = <code>k_DEFAULT_FILE_GROWTH_INCREMENT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Grow the file with the specified <code>descriptor</code> to the size of at least the specified <code>size</code> bytes. Return 0 on success, and a non-zero value otherwise. If the optionally specified <code>reserveFlag</code> is true, make sure the space on disk is preallocated and not allocated on demand, preventing a possible out-of-disk-space error when accessing the data on file systems with sparse file support. Preallocation is done by writing unspecified data to file in blocks of the optionally specified <code>increment</code>. Note that if the size of the file is greater than or equal to <code>size</code>, this function has no effect. Also note that the contents of the newly grown portion of the file is undefined. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a20f0a6a45e778c787ea12fb5f5b140c9"></a><!-- doxytag: member="bdls::FilesystemUtil::k_OFFSET_MAX" ref="a20f0a6a45e778c787ea12fb5f5b140c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> <a class="el" href="structbdls_1_1FilesystemUtil.html#a20f0a6a45e778c787ea12fb5f5b140c9">bdls::FilesystemUtil::k_OFFSET_MAX</a> = (9223372036854775807LL)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>maximum representable file offset value </p>

</div>
</div>
<a class="anchor" id="a750eef508b438afee8674462c7612a29"></a><!-- doxytag: member="bdls::FilesystemUtil::k_OFFSET_MIN" ref="a750eef508b438afee8674462c7612a29" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> <a class="el" href="structbdls_1_1FilesystemUtil.html#a750eef508b438afee8674462c7612a29">bdls::FilesystemUtil::k_OFFSET_MIN</a> = (-9223372036854775807LL-1)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minimum representable file offset value </p>

</div>
</div>
<a class="anchor" id="af6eb8fae5d490a49997d7e4fc59ae467"></a><!-- doxytag: member="bdls::FilesystemUtil::k_INVALID_FD" ref="af6eb8fae5d490a49997d7e4fc59ae467" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> <a class="el" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">bdls::FilesystemUtil::k_INVALID_FD</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>FileDescriptor</code> value </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bdls__filesystemutil_8h_source.html">bdls_filesystemutil.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:47 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
