<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Struct bslalg::ArrayPrimitives_Imp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslalg.html">bslalg</a>      </li>
      <li><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html">bslalg::ArrayPrimitives_Imp</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslalg::ArrayPrimitives_Imp Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslalg::ArrayPrimitives_Imp" -->
<p><code>#include &lt;<a class="el" href="bslalg__arrayprimitives_8h_source.html">bslalg_arrayprimitives.h</a>&gt;</code></p>

<p><a href="structbslalg_1_1ArrayPrimitives__Imp-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a92d6fe005379c1fa29e91626b845eed4a5a3ec95df84d12c0d8d99a4402c0da85">IS_POINTER_TO_POINTER</a> =  5, 
<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a92d6fe005379c1fa29e91626b845eed4a2a83d9acd99bcbabf51bfabce222c22a">IS_FUNDAMENTAL_OR_POINTER</a> =  4, 
<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a92d6fe005379c1fa29e91626b845eed4a46388bb95dfc1ba4afe90ac4baf227c4">HAS_TRIVIAL_DEFAULT_CTOR_TRAITS</a> =  3, 
<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a92d6fe005379c1fa29e91626b845eed4a28d075b1e04edecacf6b0b2dd78fc107">BITWISE_COPYABLE_TRAITS</a> =  2, 
<br/>
&nbsp;&nbsp;<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a92d6fe005379c1fa29e91626b845eed4ac0dc9a924707cc1ec0aa74222eae06b8">BITWISE_MOVEABLE_TRAITS</a> =  1, 
<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a92d6fe005379c1fa29e91626b845eed4ab216844c4801e1a904ffb223e3008a78">NIL_TRAITS</a> =  0
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ad6a8b23aa1160942848b5cf0ebf70d2ea63f1fa5c5f8cd3dc46b8f75a86e0ab4c">INPLACE_BUFFER_SIZE</a> =  16 * bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">ArrayPrimitives::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structbslalg_1_1ArrayPrimitives.html#ac756e623500f4007bf4aac5ab654f487">ArrayPrimitives::difference_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8b51214119c3bc6ee5b5a7b89faf33e6">difference_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a3fbcaf3c3516a6e4286b80b9f930006a">defaultConstruct</a> (TARGET_TYPE *begin, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; HAS_TRIVIAL_DEFAULT_CTOR_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a511dacb018af778a940968da0eed8487">defaultConstruct</a> (TARGET_TYPE *begin, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_COPYABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8e22213a46abf7dae068a5a1d744ba4d">defaultConstruct</a> (TARGET_TYPE *begin, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a4d63e544f8af2100c4b932b55a848eaf">bitwiseFillN</a> (char *begin, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numBytesInitialized, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a094d638b130a4fb8bd7ddb32f441e532">uninitializedFillN</a> (bool *begin, bool value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#af0c59deeb657017de6291f783d52fe9d">uninitializedFillN</a> (char *begin, char value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac22a8ec0aa9c932cf3ea274fe42af024">uninitializedFillN</a> (unsigned char *begin, unsigned char value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8f058035087988836c28e98970362edc">uninitializedFillN</a> (signed char *begin, signed char value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a52942f099a4908d0d424f9ec36b97aa3">uninitializedFillN</a> (wchar_t *begin, wchar_t value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8aefdd03c42773c0c2c822c16f89819b">uninitializedFillN</a> (short *begin, short value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a13fbf27d7b06e5814c7a0960fad2588a">uninitializedFillN</a> (unsigned short *begin, unsigned short value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a936629394f729d74e281345cd65dae88">uninitializedFillN</a> (int *begin, int value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ab6f0e81b9b532ab48eba19eef280301b">uninitializedFillN</a> (unsigned int *begin, unsigned int value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a1d98cba87dad2a38afecc2014a03b4f7">uninitializedFillN</a> (long *begin, long value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a590cf2e4b6363b70c85b02e5a31d5fbc">uninitializedFillN</a> (unsigned long *begin, unsigned long value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#af4c472fd68922d4b05e5724c86ce8eda">uninitializedFillN</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *begin, <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ae39b8ec66cb2c7d1bbeb0a627039dfde">uninitializedFillN</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *begin, <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a82ccb9b955c2cb5b05454f1436ef7299">uninitializedFillN</a> (float *begin, float value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a7978a1b3d28198db93731afc4e70210c">uninitializedFillN</a> (double *begin, double value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a1844623af10e09109860b2eb7aab10ae">uninitializedFillN</a> (long double *begin, long double value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a27409558ef61f28cb360d8ec498000b9">uninitializedFillN</a> (void **begin, void *value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a23246e46954d1e279467b0f1bbbe77bb">uninitializedFillN</a> (const void **begin, const void *value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#af4c38238a3a75a09a85111ad39ef8f7c">uninitializedFillN</a> (TARGET_TYPE **begin, TARGET_TYPE *value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a2b34c5acdfc239bf843486c5fe6fa595">uninitializedFillN</a> (const TARGET_TYPE **begin, const TARGET_TYPE *value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a19004272286093f842844fb7e4af79ee">uninitializedFillN</a> (TARGET_TYPE *begin, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_COPYABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ae0688ac7ff9bc75952a9b0cc6e4c7f42">uninitializedFillN</a> (TARGET_TYPE *begin, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a0a3fb2f7aa2caa4d4d1c50857971e9de">copyConstruct</a> (TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_POINTER_TO_POINTER &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a677e824ad6ff8d74eb7da9d7f8a27f2b">copyConstruct</a> (TARGET_TYPE *toBegin, const TARGET_TYPE *fromBegin, const TARGET_TYPE *fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_COPYABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#af0f42b45c0dac86f99110d369f4f7f84">copyConstruct</a> (TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a3a88f9a4684191e407558e15282f79a3">destructiveMove</a> (TARGET_TYPE *toBegin, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ad1d4b0425a84bf9bd9834699c50f8d7f">destructiveMove</a> (TARGET_TYPE *toBegin, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aba78ae5fa22c92e5dd90363ba64d938b">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_COPYABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a09d45245ee9085a305545053717e51cd">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a7670c8a76fd1a1f814dfbb4739e78b80">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aec645088cb3c4789bdb18fd5ab00f646">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_POINTER_TO_POINTER &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ad54e27ffe34266ca2d2e2864f7a05c06">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE *fromBegin, const TARGET_TYPE *fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_COPYABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a6f318b960ace282041a2ee2db239c29f">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a5ae4e7b10be5eff5f9fda33f93d849f7">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac38e559b4eec8d47afaaf473847d700a">moveInsert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, TARGET_TYPE **lastPtr, TARGET_TYPE *first, TARGET_TYPE *last, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a47082482658bed68a5c0a6bdd790d024">moveInsert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, TARGET_TYPE **lastPtr, TARGET_TYPE *first, TARGET_TYPE *last, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a5d671fda49f738bb8880f1ad33c81fe2">erase</a> (TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a3358c2563965685edacbc9b52b6516c4">erase</a> (TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a56a7c164ad1a06dc1393727680df2062">bitwiseSwapRanges</a> (char *begin, char *middle, char *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a2688725ce6ac6998762609895e76785a">bitwiseRotateBackward</a> (char *begin, char *middle, char *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8fb32a2c58d13ee43448d1296d98b35d">bitwiseRotateForward</a> (char *begin, char *middle, char *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a2b40fb18c00545727b37647ffb26530a">bitwiseRotate</a> (char *begin, char *middle, char *end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ad05148699546c5d0fd1622375b94903c">rotate</a> (TARGET_TYPE *begin, TARGET_TYPE *middle, TARGET_TYPE *end, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a6c914838353dc78529f80a7af79c009b">rotate</a> (TARGET_TYPE *begin, TARGET_TYPE *middle, TARGET_TYPE *end, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FORWARD_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aee46e724062e785d68b04c901e37b420">isInvalidRange</a> (FORWARD_ITERATOR begin, FORWARD_ITERATOR end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a302ae10bbbda71b91c986ea83e31bd1b">isInvalidRange</a> (TARGET_TYPE *begin, TARGET_TYPE *end)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for a suite of independent utility functions that operate on arrays of elements of a parameterized <code>TARGET_TYPE</code>. These utility functions are only for the purpose of implementing those in the <code><a class="el" href="structbslalg_1_1ArrayPrimitives.html">ArrayPrimitives</a></code> utility. For brevity, we do not repeat the main contracts here, but instead refer to the corresponding contract in the <code>ArrayPrimitive</code> utility. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aa3d2e68766698f07a79e998b29f2d1e7"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::size_type" ref="aa3d2e68766698f07a79e998b29f2d1e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">ArrayPrimitives::size_type</a> <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">bslalg::ArrayPrimitives_Imp::size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b51214119c3bc6ee5b5a7b89faf33e6"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::difference_type" ref="a8b51214119c3bc6ee5b5a7b89faf33e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbslalg_1_1ArrayPrimitives.html#ac756e623500f4007bf4aac5ab654f487">ArrayPrimitives::difference_type</a> <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8b51214119c3bc6ee5b5a7b89faf33e6">bslalg::ArrayPrimitives_Imp::difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a92d6fe005379c1fa29e91626b845eed4"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::@0" ref="a92d6fe005379c1fa29e91626b845eed4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These constants are used in the overloads below, when the last argument is of type <code><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt;N&gt; *</code>, indicating that <code>TARGET_TYPE</code> has the traits for which the enumerator equal to <code>N</code> is named. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a92d6fe005379c1fa29e91626b845eed4a5a3ec95df84d12c0d8d99a4402c0da85"></a><!-- doxytag: member="IS_POINTER_TO_POINTER" ref="a92d6fe005379c1fa29e91626b845eed4a5a3ec95df84d12c0d8d99a4402c0da85" args="" -->IS_POINTER_TO_POINTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a92d6fe005379c1fa29e91626b845eed4a2a83d9acd99bcbabf51bfabce222c22a"></a><!-- doxytag: member="IS_FUNDAMENTAL_OR_POINTER" ref="a92d6fe005379c1fa29e91626b845eed4a2a83d9acd99bcbabf51bfabce222c22a" args="" -->IS_FUNDAMENTAL_OR_POINTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a92d6fe005379c1fa29e91626b845eed4a46388bb95dfc1ba4afe90ac4baf227c4"></a><!-- doxytag: member="HAS_TRIVIAL_DEFAULT_CTOR_TRAITS" ref="a92d6fe005379c1fa29e91626b845eed4a46388bb95dfc1ba4afe90ac4baf227c4" args="" -->HAS_TRIVIAL_DEFAULT_CTOR_TRAITS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a92d6fe005379c1fa29e91626b845eed4a28d075b1e04edecacf6b0b2dd78fc107"></a><!-- doxytag: member="BITWISE_COPYABLE_TRAITS" ref="a92d6fe005379c1fa29e91626b845eed4a28d075b1e04edecacf6b0b2dd78fc107" args="" -->BITWISE_COPYABLE_TRAITS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a92d6fe005379c1fa29e91626b845eed4ac0dc9a924707cc1ec0aa74222eae06b8"></a><!-- doxytag: member="BITWISE_MOVEABLE_TRAITS" ref="a92d6fe005379c1fa29e91626b845eed4ac0dc9a924707cc1ec0aa74222eae06b8" args="" -->BITWISE_MOVEABLE_TRAITS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a92d6fe005379c1fa29e91626b845eed4ab216844c4801e1a904ffb223e3008a78"></a><!-- doxytag: member="NIL_TRAITS" ref="a92d6fe005379c1fa29e91626b845eed4ab216844c4801e1a904ffb223e3008a78" args="" -->NIL_TRAITS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6a8b23aa1160942848b5cf0ebf70d2e"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::@1" ref="ad6a8b23aa1160942848b5cf0ebf70d2e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of bytes for which a stack-allocated buffer can be comfortably obtained to optimize bitwise moves. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad6a8b23aa1160942848b5cf0ebf70d2ea63f1fa5c5f8cd3dc46b8f75a86e0ab4c"></a><!-- doxytag: member="INPLACE_BUFFER_SIZE" ref="ad6a8b23aa1160942848b5cf0ebf70d2ea63f1fa5c5f8cd3dc46b8f75a86e0ab4c" args="" -->INPLACE_BUFFER_SIZE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3fbcaf3c3516a6e4286b80b9f930006a"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::defaultConstruct" ref="a3fbcaf3c3516a6e4286b80b9f930006a" args="(TARGET_TYPE *begin, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; HAS_TRIVIAL_DEFAULT_CTOR_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::defaultConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; HAS_TRIVIAL_DEFAULT_CTOR_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a511dacb018af778a940968da0eed8487"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::defaultConstruct" ref="a511dacb018af778a940968da0eed8487" args="(TARGET_TYPE *begin, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; BITWISE_COPYABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::defaultConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e22213a46abf7dae068a5a1d744ba4d"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::defaultConstruct" ref="a8e22213a46abf7dae068a5a1d744ba4d" args="(TARGET_TYPE *begin, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::defaultConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the default constructor of the parameterized <code>TARGET_TYPE</code> (or <code>memset</code> to 0 if <code>TARGET_TYPE</code> has a trivial default constructor) on each element of the array starting at the <code>begin</code> address and ending immediately before the <code>end</code> address. Pass the specified <code>allocator</code> to the default constructor if appropriate. The last argument is for traits overloading resolution only and its value is ignored. </p>

</div>
</div>
<a class="anchor" id="a4d63e544f8af2100c4b932b55a848eaf"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::bitwiseFillN" ref="a4d63e544f8af2100c4b932b55a848eaf" args="(char *begin, size_type numBytesInitialized, size_type numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::bitwiseFillN </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numBytesInitialized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the specified <code>numBytes</code> in the array starting at the specified <code>begin</code> address, as if by bit-wise copying the specified <code>numBytesInitialized</code> at every offset that is a multiple of <code>numBytesInitialized</code> within the output array. The behavior is undefined unless <code>numBytesInitialized &lt;= numBytes</code>. Note that <code>numBytes</code> usually is, but does not have to be, a multiple of <code>numBytesInitialized</code>. </p>

</div>
</div>
<a class="anchor" id="a094d638b130a4fb8bd7ddb32f441e532"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a094d638b130a4fb8bd7ddb32f441e532" args="(bool *begin, bool value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af0c59deeb657017de6291f783d52fe9d"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="af0c59deeb657017de6291f783d52fe9d" args="(char *begin, char value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac22a8ec0aa9c932cf3ea274fe42af024"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="ac22a8ec0aa9c932cf3ea274fe42af024" args="(unsigned char *begin, unsigned char value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f058035087988836c28e98970362edc"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a8f058035087988836c28e98970362edc" args="(signed char *begin, signed char value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">signed char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a52942f099a4908d0d424f9ec36b97aa3"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a52942f099a4908d0d424f9ec36b97aa3" args="(wchar_t *begin, wchar_t value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8aefdd03c42773c0c2c822c16f89819b"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a8aefdd03c42773c0c2c822c16f89819b" args="(short *begin, short value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a13fbf27d7b06e5814c7a0960fad2588a"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a13fbf27d7b06e5814c7a0960fad2588a" args="(unsigned short *begin, unsigned short value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a936629394f729d74e281345cd65dae88"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a936629394f729d74e281345cd65dae88" args="(int *begin, int value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6f0e81b9b532ab48eba19eef280301b"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="ab6f0e81b9b532ab48eba19eef280301b" args="(unsigned int *begin, unsigned int value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d98cba87dad2a38afecc2014a03b4f7"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a1d98cba87dad2a38afecc2014a03b4f7" args="(long *begin, long value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a590cf2e4b6363b70c85b02e5a31d5fbc"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a590cf2e4b6363b70c85b02e5a31d5fbc" args="(unsigned long *begin, unsigned long value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af4c472fd68922d4b05e5724c86ce8eda"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="af4c472fd68922d4b05e5724c86ce8eda" args="(bsls::Types::Int64 *begin, bsls::Types::Int64 value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae39b8ec66cb2c7d1bbeb0a627039dfde"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="ae39b8ec66cb2c7d1bbeb0a627039dfde" args="(bsls::Types::Uint64 *begin, bsls::Types::Uint64 value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a82ccb9b955c2cb5b05454f1436ef7299"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a82ccb9b955c2cb5b05454f1436ef7299" args="(float *begin, float value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7978a1b3d28198db93731afc4e70210c"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a7978a1b3d28198db93731afc4e70210c" args="(double *begin, double value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1844623af10e09109860b2eb7aab10ae"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a1844623af10e09109860b2eb7aab10ae" args="(long double *begin, long double value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">long double *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a27409558ef61f28cb360d8ec498000b9"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a27409558ef61f28cb360d8ec498000b9" args="(void **begin, void *value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a23246e46954d1e279467b0f1bbbe77bb"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a23246e46954d1e279467b0f1bbbe77bb" args="(const void **begin, const void *value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">const void **&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af4c38238a3a75a09a85111ad39ef8f7c"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="af4c38238a3a75a09a85111ad39ef8f7c" args="(TARGET_TYPE **begin, TARGET_TYPE *value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b34c5acdfc239bf843486c5fe6fa595"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a2b34c5acdfc239bf843486c5fe6fa595" args="(const TARGET_TYPE **begin, const TARGET_TYPE *value, size_type numElements, void *=0, bslmf::MetaInt&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">const TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a19004272286093f842844fb7e4af79ee"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a19004272286093f842844fb7e4af79ee" args="(TARGET_TYPE *begin, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; BITWISE_COPYABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae0688ac7ff9bc75952a9b0cc6e4c7f42"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="ae0688ac7ff9bc75952a9b0cc6e4c7f42" args="(TARGET_TYPE *begin, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy the specified <code>value</code> of the parameterized <code>TARGET_TYPE</code> into every of the specified <code>numElements</code> in the array starting at the specified <code>begin</code> address. Pass the specified <code>allocator</code> to the copy constructor if appropriate. Note that if <code>TARGET_TYPE</code> is bit-wise copyable or is not based on <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, <code>allocator</code> is ignored. The last argument is for removing overload ambiguities and is not used. </p>

</div>
</div>
<a class="anchor" id="a0a3fb2f7aa2caa4d4d1c50857971e9de"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::copyConstruct" ref="a0a3fb2f7aa2caa4d4d1c50857971e9de" args="(TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; IS_POINTER_TO_POINTER &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::copyConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_POINTER_TO_POINTER &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a677e824ad6ff8d74eb7da9d7f8a27f2b"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::copyConstruct" ref="a677e824ad6ff8d74eb7da9d7f8a27f2b" args="(TARGET_TYPE *toBegin, const TARGET_TYPE *fromBegin, const TARGET_TYPE *fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; BITWISE_COPYABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::copyConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af0f42b45c0dac86f99110d369f4f7f84"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::copyConstruct" ref="af0f42b45c0dac86f99110d369f4f7f84" args="(TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::copyConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>copyConstruct</code> contract. If the parameterized <code>ALLOCATOR</code> is based on <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> and the <code>TARGET_TYPE</code> constructors take an allocator argument, then pass the specified <code>allocator</code> to the copy constructor. The behavior is undefined unless the output array has length at least the distance from <code>fromBegin</code> to <code>fromEnd</code>. Note that if <code>FWD_ITER</code> is the <code>TARGET_TYPE *</code> pointer type and <code>TARGET_TYPE</code> is bit-wise copyable, then this operation is simply <code>memcpy</code>. The last argument is for removing overload ambiguities and is not used. </p>

</div>
</div>
<a class="anchor" id="a3a88f9a4684191e407558e15282f79a3"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::destructiveMove" ref="a3a88f9a4684191e407558e15282f79a3" args="(TARGET_TYPE *toBegin, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::destructiveMove </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad1d4b0425a84bf9bd9834699c50f8d7f"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::destructiveMove" ref="ad1d4b0425a84bf9bd9834699c50f8d7f" args="(TARGET_TYPE *toBegin, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::destructiveMove </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>destructiveMove</code> contract. Note that both arrays cannot overlap (one contains only initialized elements and the other only uninitialized elements), and that if <code>TARGET_TYPE</code> is bit-wise moveable, then this operation is simply <code>memcpy</code>. The last argument is for removing overload ambiguities and is not used. </p>

</div>
</div>
<a class="anchor" id="aba78ae5fa22c92e5dd90363ba64d938b"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="aba78ae5fa22c92e5dd90363ba64d938b" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; BITWISE_COPYABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a09d45245ee9085a305545053717e51cd"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="a09d45245ee9085a305545053717e51cd" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7670c8a76fd1a1f814dfbb4739e78b80"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="a7670c8a76fd1a1f814dfbb4739e78b80" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>insert</code> contract. Note that if <code>TARGET_TYPE</code> is bit-wise copyable, then this operation is simply <code>memmove</code> followed by <code>bitwiseFillN</code>. If <code>TARGET_TYPE</code> is bit-wise moveable, then this operation can still be optimized using <code>memmove</code> followed by repeated assignments, but a guard needs to be set up. The last argument is for removing overload ambiguities and is not used. </p>

</div>
</div>
<a class="anchor" id="aec645088cb3c4789bdb18fd5ab00f646"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="aec645088cb3c4789bdb18fd5ab00f646" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; IS_POINTER_TO_POINTER &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; IS_POINTER_TO_POINTER &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad54e27ffe34266ca2d2e2864f7a05c06"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="ad54e27ffe34266ca2d2e2864f7a05c06" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE *fromBegin, const TARGET_TYPE *fromEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; BITWISE_COPYABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6f318b960ace282041a2ee2db239c29f"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="a6f318b960ace282041a2ee2db239c29f" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ae4e7b10be5eff5f9fda33f93d849f7"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="a5ae4e7b10be5eff5f9fda33f93d849f7" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>insert</code> contract. Note that if <code>TARGET_TYPE</code> is bit-wise copyable and <code>FWD_ITER</code> is convertible to <code>const TARGET_TYPE *</code>, then this operation is simply <code>memmove</code> followed by <code>memcopy</code>. If <code>TARGET_TYPE</code> is bit-wise moveable and <code>FWD_ITER</code> is convertible to <code>const TARGET_TYPE *</code>, then this operation can still be optimized using <code>memmove</code> followed by repeated copies. The last argument is for removing overload ambiguities and is not used. </p>

</div>
</div>
<a class="anchor" id="ac38e559b4eec8d47afaaf473847d700a"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::moveInsert" ref="ac38e559b4eec8d47afaaf473847d700a" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, TARGET_TYPE **lastPtr, TARGET_TYPE *first, TARGET_TYPE *last, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::moveInsert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>lastPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a47082482658bed68a5c0a6bdd790d024"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::moveInsert" ref="a47082482658bed68a5c0a6bdd790d024" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, TARGET_TYPE **lastPtr, TARGET_TYPE *first, TARGET_TYPE *last, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::moveInsert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>lastPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>moveInsert</code> contract. Note that if <code>TARGET_TYPE</code> is at least bit-wise moveable, then this operation is simply <code>memmove</code> followed by <code>memcpy</code>. </p>

</div>
</div>
<a class="anchor" id="a5d671fda49f738bb8880f1ad33c81fe2"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::erase" ref="a5d671fda49f738bb8880f1ad33c81fe2" args="(TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last, ALLOCATOR *allocator, bslmf::MetaInt&lt; BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::erase </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3358c2563965685edacbc9b52b6516c4"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::erase" ref="a3358c2563965685edacbc9b52b6516c4" args="(TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last, ALLOCATOR *allocator, bslmf::MetaInt&lt; NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::erase </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>erase</code> contract. Note that if <code>TARGET_TYPE</code> is bit-wise moveable, then this operation can be implemented by first bit-wise moving the elements in <code>[ middle, last)</code> towards first, and destroying <code>[ last - (middle - first), last)</code>; note that this cannot throw exceptions. </p>

</div>
</div>
<a class="anchor" id="a56a7c164ad1a06dc1393727680df2062"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::bitwiseSwapRanges" ref="a56a7c164ad1a06dc1393727680df2062" args="(char *begin, char *middle, char *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::bitwiseSwapRanges </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the characters in the array starting at the specified <code>first</code> address and ending immediately before the specified <code>middle</code> address with the array of the same length starting at the <code>middle</code> address and ending at the specified <code>last</code> address. The behavior is undefined unless <code>middle - begin == end - middle</code>. </p>

</div>
</div>
<a class="anchor" id="a2688725ce6ac6998762609895e76785a"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::bitwiseRotateBackward" ref="a2688725ce6ac6998762609895e76785a" args="(char *begin, char *middle, char *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::bitwiseRotateBackward </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the characters in the array starting at the specified <code>first</code> address and ending immediately before the specified <code>middle</code> address to the array of the same length ending at the specified <code>last</code> address (and thus starting at the <code>last - (middle - first)</code> address), and move the elements previously in the array starting at <code>middle</code> and ending at <code>last</code> down to the <code>first</code> address. The behavior is undefined unless <code>middle - begin &lt;= INPLACE_BUFFER_SIZE</code>. </p>

</div>
</div>
<a class="anchor" id="a8fb32a2c58d13ee43448d1296d98b35d"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::bitwiseRotateForward" ref="a8fb32a2c58d13ee43448d1296d98b35d" args="(char *begin, char *middle, char *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::bitwiseRotateForward </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the characters in the array starting at the specified <code>first</code> address and ending immediately before the specified <code>middle</code> address to the array of the same length ending at the specified <code>last</code> address (and thus starting at the <code>last - (middle - first)</code> address), and move the elements previously in the array starting at <code>middle</code> and ending at <code>last</code> down to the <code>first</code> address. The behavior is undefined unless <code>end - middle &lt;= INPLACE_BUFFER_SIZE</code>. </p>

</div>
</div>
<a class="anchor" id="a2b40fb18c00545727b37647ffb26530a"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::bitwiseRotate" ref="a2b40fb18c00545727b37647ffb26530a" args="(char *begin, char *middle, char *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::bitwiseRotate </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function follows the <code>rotate</code> contract, but by using bit-wise moves on the underlying <code>char</code> array. </p>

</div>
</div>
<a class="anchor" id="ad05148699546c5d0fd1622375b94903c"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::rotate" ref="ad05148699546c5d0fd1622375b94903c" args="(TARGET_TYPE *begin, TARGET_TYPE *middle, TARGET_TYPE *end, bslmf::MetaInt&lt; BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::rotate </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c914838353dc78529f80a7af79c009b"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::rotate" ref="a6c914838353dc78529f80a7af79c009b" args="(TARGET_TYPE *begin, TARGET_TYPE *middle, TARGET_TYPE *end, bslmf::MetaInt&lt; NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::rotate </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>rotate</code> contract, but the first overload is optimized when the parameterized <code>TARGET_TYPE</code> is bit-wise moveable. The last argument is for removing overload ambiguities and is not used. Note that if <code>TARGET_TYPE</code> is bit-wise moveable, the <code>rotate(char*, char*, char*)</code> can be used, enabling to take the whole implementation out-of-line. </p>

</div>
</div>
<a class="anchor" id="aee46e724062e785d68b04c901e37b420"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::isInvalidRange" ref="aee46e724062e785d68b04c901e37b420" args="(FORWARD_ITERATOR begin, FORWARD_ITERATOR end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FORWARD_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::ArrayPrimitives_Imp::isInvalidRange </td>
          <td>(</td>
          <td class="paramtype">FORWARD_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FORWARD_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a302ae10bbbda71b91c986ea83e31bd1b"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::isInvalidRange" ref="a302ae10bbbda71b91c986ea83e31bd1b" args="(TARGET_TYPE *begin, TARGET_TYPE *end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::ArrayPrimitives_Imp::isInvalidRange </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if <code>[begin, end)</code> provably do not form a valid range, and <code>false</code> otherwise. Note that <code>begin == null == end</code> produces a valid range, and any other use of the null pointer value will return <code>true</code>. Also not that this function is intended to support testing, primarily through assertions, so will return <code>true</code> unless it can <em>prove</em> that the passed range is invalid. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bslalg__arrayprimitives_8h_source.html">bslalg_arrayprimitives.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:51 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
