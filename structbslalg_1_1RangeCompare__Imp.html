<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Struct bslalg::RangeCompare_Imp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslalg.html">bslalg</a>      </li>
      <li><a class="el" href="structbslalg_1_1RangeCompare__Imp.html">bslalg::RangeCompare_Imp</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslalg::RangeCompare_Imp Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslalg::RangeCompare_Imp" -->
<p><code>#include &lt;<a class="el" href="bslalg__rangecompare_8h_source.html">bslalg_rangecompare.h</a>&gt;</code></p>

<p><a href="structbslalg_1_1RangeCompare__Imp-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VALUE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#ae9432a82a56ef04c4a3627fb523822b0">equal</a> (const VALUE_TYPE *start1, const VALUE_TYPE *end1, const VALUE_TYPE *start2, const VALUE_TYPE *end2, const VALUE_TYPE &amp;, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 1 &gt;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#a353a950d2fc2b279c5ab1f1dbaff53af">equal</a> (INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, INPUT_ITER end2, const VALUE_TYPE &amp;, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 0 &gt;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#a175d8d338ee971261d552a6a56496a23">equal</a> (INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, INPUT_ITER end2, const VALUE_TYPE &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#a753927c67049529cf8ae2d5dd932e8f6">equal</a> (INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, const VALUE_TYPE &amp;, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 1 &gt;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#ab3949347f542c8d5155e46fbb4c14c95">equal</a> (INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, const VALUE_TYPE &amp;, <a class="el" href="structbslmf_1_1MatchAnyType.html">bslmf::MatchAnyType</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#ae3c082701846c49b389766cb0c19deda">equal</a> (INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, const VALUE_TYPE &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VALUE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#aa6c674f0b5cb031c2a965766abb0ac1c">equalBitwiseEqualityComparable</a> (const VALUE_TYPE *start1, const VALUE_TYPE *end1, const VALUE_TYPE *start2, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 1 &gt;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#a9b3b4f268c9308e04f46d2b64fe31727">equalBitwiseEqualityComparable</a> (INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 0 &gt;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VALUE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#abce9f24f57263343a3d44c48067e4f21">lexicographical</a> (const VALUE_TYPE *start1, const VALUE_TYPE *end1, const VALUE_TYPE *start2, const VALUE_TYPE *end2, const VALUE_TYPE &amp;, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 1 &gt;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#a162d9e37837f107071f15017ed3a4828">lexicographical</a> (INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, INPUT_ITER end2, const VALUE_TYPE &amp;, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 0 &gt;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#a8cff6575391cfc8911f2ee2348a0143a">lexicographical</a> (INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, INPUT_ITER end2, const VALUE_TYPE &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#ac241d9ad171fa50a8e7aa58e5660cacf">lexicographical</a> (const char *start1, const char *end1, const char *start2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#ae0cffd3b9164707aa0ba2d07609c1b13">lexicographical</a> (const unsigned char *start1, const unsigned char *end1, const unsigned char *start2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#ad876df8d4c745f99e22deda4f7e89861">lexicographical</a> (const wchar_t *start1, const wchar_t *end1, const wchar_t *start2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#a51129c8e7406426cf78f6e7ad82a3d68">lexicographical</a> (INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, <a class="el" href="structbslmf_1_1MatchAnyType.html">bslmf::MatchAnyType</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RangeCompare__Imp.html#a67c23983e7764f569763c6d36bb5eea6">lexicographical</a> (INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This utility <code>struct</code> provides the implementations for <code><a class="el" href="structbslalg_1_1RangeCompare.html">bslalg::RangeCompare</a></code>. Multiple implementations are provided for each method in <code><a class="el" href="structbslalg_1_1RangeCompare.html">bslalg::RangeCompare</a></code>, and the most efficient version is found by disambiguating based on the iterator type, the value type, or the presence of nested traits. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae9432a82a56ef04c4a3627fb523822b0"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::equal" ref="ae9432a82a56ef04c4a3627fb523822b0" args="(const VALUE_TYPE *start1, const VALUE_TYPE *end1, const VALUE_TYPE *start2, const VALUE_TYPE *end2, const VALUE_TYPE &amp;, bslmf::MetaInt&lt; 1 &gt;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RangeCompare_Imp::equal </td>
          <td>(</td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 1 &gt;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a353a950d2fc2b279c5ab1f1dbaff53af"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::equal" ref="a353a950d2fc2b279c5ab1f1dbaff53af" args="(INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, INPUT_ITER end2, const VALUE_TYPE &amp;, bslmf::MetaInt&lt; 0 &gt;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RangeCompare_Imp::equal </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 0 &gt;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a175d8d338ee971261d552a6a56496a23"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::equal" ref="a175d8d338ee971261d552a6a56496a23" args="(INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, INPUT_ITER end2, const VALUE_TYPE &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RangeCompare_Imp::equal </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare the range beginning at the specified <code>start1</code> position and ending immediately before the specified <code>end1</code> position with the range beginning at the specified <code>start2</code> position and ending immediately before the specified <code>end2</code> position, as if using <code>operator==</code> element-by-element. The unnamed <code>VALUE_TYPE</code> argument is for automatic type deduction, and is ignored. The fifth argument is for overloading resolution, and is also ignored. </p>

</div>
</div>
<a class="anchor" id="a753927c67049529cf8ae2d5dd932e8f6"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::equal" ref="a753927c67049529cf8ae2d5dd932e8f6" args="(INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, const VALUE_TYPE &amp;, bslmf::MetaInt&lt; 1 &gt;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RangeCompare_Imp::equal </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 1 &gt;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3949347f542c8d5155e46fbb4c14c95"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::equal" ref="ab3949347f542c8d5155e46fbb4c14c95" args="(INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, const VALUE_TYPE &amp;, bslmf::MatchAnyType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RangeCompare_Imp::equal </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MatchAnyType.html">bslmf::MatchAnyType</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae3c082701846c49b389766cb0c19deda"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::equal" ref="ae3c082701846c49b389766cb0c19deda" args="(INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, const VALUE_TYPE &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RangeCompare_Imp::equal </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare the range beginning at the specified <code>start1</code> position and ending immediately before the specified <code>end1</code> position with the range beginning at the specified <code>start2</code> position of the same length (namely, <code>end1 - start1</code>), as if using <code>operator==</code> element-by-element. The unnamed <code>VALUE_TYPE</code> argument is for automatic type deduction, and is ignored. The fifth argument is for overloading resolution, and is also ignored. </p>

</div>
</div>
<a class="anchor" id="aa6c674f0b5cb031c2a965766abb0ac1c"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::equalBitwiseEqualityComparable" ref="aa6c674f0b5cb031c2a965766abb0ac1c" args="(const VALUE_TYPE *start1, const VALUE_TYPE *end1, const VALUE_TYPE *start2, bslmf::MetaInt&lt; 1 &gt;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RangeCompare_Imp::equalBitwiseEqualityComparable </td>
          <td>(</td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 1 &gt;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare the range beginning at the specified <code>start1</code> position and ending immediately before the specified <code>end1</code> position with the range beginning at the specified <code>start2</code> position of the same length (namely, <code>end1 - start1</code>), using bit-wise comparison across the entire ranges. The last argument is for removing overload ambiguities, and is not used. Return <code>true</code> if the ranges are bit-wise equal, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a9b3b4f268c9308e04f46d2b64fe31727"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::equalBitwiseEqualityComparable" ref="a9b3b4f268c9308e04f46d2b64fe31727" args="(INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, bslmf::MetaInt&lt; 0 &gt;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RangeCompare_Imp::equalBitwiseEqualityComparable </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 0 &gt;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare the range beginning at the specified <code>start1</code> position and ending immediately before the specified <code>end1</code> position with the range beginning at the specified <code>start2</code> position of the same length (namely, <code>end1 - start1</code>), using <code>operator==</code> element-by-element. The last argument is for removing overload ambiguities, and is not used. Return <code>true</code> if each element in the first range is equal to the corresponding element in the second range, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="abce9f24f57263343a3d44c48067e4f21"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::lexicographical" ref="abce9f24f57263343a3d44c48067e4f21" args="(const VALUE_TYPE *start1, const VALUE_TYPE *end1, const VALUE_TYPE *start2, const VALUE_TYPE *end2, const VALUE_TYPE &amp;, bslmf::MetaInt&lt; 1 &gt;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslalg::RangeCompare_Imp::lexicographical </td>
          <td>(</td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 1 &gt;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare the range beginning at the specified <code>start1</code> position and ending immediately before the specified <code>end1</code> position with the range beginning at the specified <code>start2</code> position and ending immediately before the specified <code>end2</code> position. The last two arguments are for removing overload ambiguities and are not used. Return a negative value if the first range compares lexicographically less than the second range, 0 if they are the same length and compare lexicographically equal, and a positive value if the first range compares lexicographically greater than the second range. </p>

</div>
</div>
<a class="anchor" id="a162d9e37837f107071f15017ed3a4828"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::lexicographical" ref="a162d9e37837f107071f15017ed3a4828" args="(INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, INPUT_ITER end2, const VALUE_TYPE &amp;, bslmf::MetaInt&lt; 0 &gt;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslalg::RangeCompare_Imp::lexicographical </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; 0 &gt;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare each element in the range beginning at the specified <code>start1</code> position and ending immediately before the specified <code>end1</code> position with the corresponding element in the range beginning at the specified <code>start2</code> position and ending immediately before the specified <code>end2</code> position using <code>operator&lt;</code>. The last two arguments are for removing overload ambiguities and are not used. Return a negative value if the first range compares lexicographically less than the second range, 0 if they are the same length and compare lexicographically equal, and a positive value if the first range compares lexicographically greater than the second range. </p>

</div>
</div>
<a class="anchor" id="a8cff6575391cfc8911f2ee2348a0143a"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::lexicographical" ref="a8cff6575391cfc8911f2ee2348a0143a" args="(INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, INPUT_ITER end2, const VALUE_TYPE &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INPUT_ITER , typename VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslalg::RangeCompare_Imp::lexicographical </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare the range beginning at the specified <code>start1</code> position and ending immediately before the specified <code>end1</code> position with the range beginning at the specified <code>start2</code> position and ending immediately before the specified <code>end2</code> position. The type of the last argument is considered in determining what optimizations, if any, can be applied to the comparison. The last argument is not used in any other way. Return a negative value if the first range compares lexicographically less than the second range, 0 if they are the same length and compare lexicographically equal, and a positive value if the first range compares lexicographically greater than the second range. </p>

</div>
</div>
<a class="anchor" id="ac241d9ad171fa50a8e7aa58e5660cacf"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::lexicographical" ref="ac241d9ad171fa50a8e7aa58e5660cacf" args="(const char *start1, const char *end1, const char *start2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslalg::RangeCompare_Imp::lexicographical </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>start2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare the range beginning at the specified <code>start1</code> position and ending immediately before the specified <code>end1</code> position with the range beginning at the specified <code>start2</code> position of the same length (namely, <code>end1 - start1</code>), using a bit-wise comparison across the entire range, if <code>const char</code> is unsigned, and using <code>operator&lt;</code> otherwise. Return a negative value if the first range compares lexicographically less than the second range, 0 if they are the same length and compare lexicographically equal, and a positive value if the first range compares lexicographically greater than the second range. </p>

</div>
</div>
<a class="anchor" id="ae0cffd3b9164707aa0ba2d07609c1b13"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::lexicographical" ref="ae0cffd3b9164707aa0ba2d07609c1b13" args="(const unsigned char *start1, const unsigned char *end1, const unsigned char *start2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslalg::RangeCompare_Imp::lexicographical </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>start2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad876df8d4c745f99e22deda4f7e89861"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::lexicographical" ref="ad876df8d4c745f99e22deda4f7e89861" args="(const wchar_t *start1, const wchar_t *end1, const wchar_t *start2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslalg::RangeCompare_Imp::lexicographical </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>start2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a51129c8e7406426cf78f6e7ad82a3d68"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::lexicographical" ref="a51129c8e7406426cf78f6e7ad82a3d68" args="(INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2, bslmf::MatchAnyType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslalg::RangeCompare_Imp::lexicographical </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MatchAnyType.html">bslmf::MatchAnyType</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a67c23983e7764f569763c6d36bb5eea6"></a><!-- doxytag: member="bslalg::RangeCompare_Imp::lexicographical" ref="a67c23983e7764f569763c6d36bb5eea6" args="(INPUT_ITER start1, INPUT_ITER end1, INPUT_ITER start2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslalg::RangeCompare_Imp::lexicographical </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>start2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare each element in the range beginning at the specified <code>start1</code> position and ending immediately before the specified <code>end1</code> position with the corresponding element in the range of the same length beginning at the specified <code>start2</code> position. Return a negative value if the first range compares lexicographically less than the second range, 0 if they are the same length and compare lexicographically equal, and a positive value if the first range compares lexicographically greater than the second range. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bslalg__rangecompare_8h_source.html">bslalg_rangecompare.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:52 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
